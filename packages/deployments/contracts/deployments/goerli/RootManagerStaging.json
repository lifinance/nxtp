{
  "address": "0xD864761B8480F57E78060485f442A9A51f1DA0d1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_delayBlocks",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_merkle",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_watcherManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__acceptProposedOwner_delayNotElapsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyOwner_notOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyProposed_notProposedOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_noOwnershipChange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_delayNotElapsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_noProposal",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "connector",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32[]",
          "name": "domains",
          "type": "uint32[]"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "connectors",
          "type": "address[]"
        }
      ],
      "name": "ConnectorAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "connector",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32[]",
          "name": "domains",
          "type": "uint32[]"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "connectors",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "ConnectorRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previous",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "updated",
          "type": "uint256"
        }
      ],
      "name": "DelayBlocksUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposedOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipProposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "receivedRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "queueIndex",
          "type": "uint256"
        }
      ],
      "name": "RootAggregated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "aggregateRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32[]",
          "name": "domains",
          "type": "uint32[]"
        },
        {
          "indexed": false,
          "internalType": "bytes32[]",
          "name": "aggregatedMessageRoots",
          "type": "bytes32[]"
        }
      ],
      "name": "RootPropagated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "watcherManager",
          "type": "address"
        }
      ],
      "name": "WatcherManagerChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MERKLE",
      "outputs": [
        {
          "internalType": "contract MerkleTreeManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptProposedOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_connector",
          "type": "address"
        }
      ],
      "name": "addConnector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_inbound",
          "type": "bytes32"
        }
      ],
      "name": "aggregate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "connectors",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "connectorsHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delayBlocks",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "domains",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "domainsHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "getConnectorForDomain",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "getDomainIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPendingInboundRootsCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "isDomainSupported",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingInboundRoots",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "first",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "last",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32[]",
          "name": "_domains",
          "type": "uint32[]"
        },
        {
          "internalType": "address[]",
          "name": "_connectors",
          "type": "address[]"
        }
      ],
      "name": "propagate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newlyProposed",
          "type": "address"
        }
      ],
      "name": "proposeNewOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposed",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "removeConnector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounced",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_delayBlocks",
          "type": "uint256"
        }
      ],
      "name": "setDelayBlocks",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_watcherManager",
          "type": "address"
        }
      ],
      "name": "setWatcherManager",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32[]",
          "name": "_domains",
          "type": "uint32[]"
        },
        {
          "internalType": "address[]",
          "name": "_connectors",
          "type": "address[]"
        }
      ],
      "name": "validateDomains",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x26361845b70eed238444c904a86b13a30059c1f91feab670b77187cc051e949a",
  "receipt": {
    "to": null,
    "from": "0x54BAA998771639628ffC0206c3b916c466b79c89",
    "contractAddress": "0xD864761B8480F57E78060485f442A9A51f1DA0d1",
    "transactionIndex": 48,
    "gasUsed": "1885483",
    "logsBloom": "0x00000000000000000000000000000000000010000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401000000000000000000000000000000000020020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000080000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7438a2a27344218a4a5b2ed46a0245642e9799fb06bbd277c2c8a117ff61a33b",
    "transactionHash": "0x26361845b70eed238444c904a86b13a30059c1f91feab670b77187cc051e949a",
    "logs": [
      {
        "transactionIndex": 48,
        "blockNumber": 7795132,
        "transactionHash": "0x26361845b70eed238444c904a86b13a30059c1f91feab670b77187cc051e949a",
        "address": "0xD864761B8480F57E78060485f442A9A51f1DA0d1",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000054baa998771639628ffc0206c3b916c466b79c89"
        ],
        "data": "0x",
        "logIndex": 94,
        "blockHash": "0x7438a2a27344218a4a5b2ed46a0245642e9799fb06bbd277c2c8a117ff61a33b"
      }
    ],
    "blockNumber": 7795132,
    "cumulativeGasUsed": "16637485",
    "status": 1,
    "byzantium": true
  },
  "args": [
    100,
    "0x223202126ce50556Afd127a5ADfc5a32554B867F",
    "0xce7012894B6b6e74C972D377D68EEca5B6048178"
  ],
  "numDeployments": 1,
  "solcInputHash": "2cb19c6ff260c62b0df6791111e721e0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_merkle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_watcherManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ProposedOwnable__acceptProposedOwner_delayNotElapsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyOwner_notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyProposed_notProposedOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_noOwnershipChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_delayNotElapsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_noProposal\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"domains\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"connectors\",\"type\":\"address[]\"}],\"name\":\"ConnectorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"domains\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"connectors\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ConnectorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updated\",\"type\":\"uint256\"}],\"name\":\"DelayBlocksUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"receivedRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"queueIndex\",\"type\":\"uint256\"}],\"name\":\"RootAggregated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"aggregateRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"domains\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"aggregatedMessageRoots\",\"type\":\"bytes32[]\"}],\"name\":\"RootPropagated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcherManager\",\"type\":\"address\"}],\"name\":\"WatcherManagerChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MERKLE\",\"outputs\":[{\"internalType\":\"contract MerkleTreeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptProposedOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_connector\",\"type\":\"address\"}],\"name\":\"addConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_inbound\",\"type\":\"bytes32\"}],\"name\":\"aggregate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"connectors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"domains\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"getConnectorForDomain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"getDomainIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingInboundRootsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"isDomainSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingInboundRoots\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"first\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"last\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_domains\",\"type\":\"uint32[]\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"propagate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newlyProposed\",\"type\":\"address\"}],\"name\":\"proposeNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"removeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delayBlocks\",\"type\":\"uint256\"}],\"name\":\"setDelayBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_watcherManager\",\"type\":\"address\"}],\"name\":\"setWatcherManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_domains\",\"type\":\"uint32[]\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"validateDomains\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addConnector(uint32,address)\":{\"details\":\"Only owner can add a new connector. Address should be the connector on L1.Cannot add address(0) to avoid duplicated domain in array and reduce gas fee while propagating.\",\"params\":{\"_connector\":\"Address of the hub connector.\",\"_domain\":\"The target spoke domain of the given connector.\"}},\"aggregate(uint32,bytes32)\":{\"details\":\"The aggregate tree's root, which will include this inbound root, will be propagated to all spoke domains (via `propagate`) on a regular basis assuming the verification period is surpassed without dispute.\",\"params\":{\"_domain\":\"The source domain of the given root.\",\"_inbound\":\"The inbound root coming from the given domain.\"}},\"constructor\":{\"params\":{\"_delayBlocks\":\"The delay for the validation period for incoming messages in blocks.\",\"_merkle\":\"The address of the MerkleTreeManager on this domain.\",\"_watcherManager\":\"The address of the WatcherManager on this domain.\"}},\"getConnectorForDomain(uint32)\":{\"details\":\"Inefficient, should only be used by caller if they have no index reference.\",\"params\":{\"_domain\":\"The domain for which to get the hub connector address.\"}},\"getDomainIndex(uint32)\":{\"details\":\"Reverts if domain is not supported.\",\"params\":{\"_domain\":\"The domain for which to get the index value.\"}},\"isDomainSupported(uint32)\":{\"params\":{\"_domain\":\"Domain to check.\"}},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"propagate(uint32[],address[])\":{\"details\":\"Should be called by relayers at a regular interval.\",\"params\":{\"_connectors\":\"Array of connectors: should match exactly the array of `connectors` in storage (see `_domains` param's info on reducing gas costs).\",\"_domains\":\"Array of domains: should match exactly the array of `domains` in storage; used here to reduce gas costs, and keep them static regardless of number of supported domains.\"}},\"removeConnector(uint32)\":{\"details\":\"Only watcher can remove a connector. TODO: Could add a metatx-able `removeConnectorWithSig` if we want to use relayers?\",\"params\":{\"_domain\":\"The spoke domain of the target connector we want to remove.\"}},\"setWatcherManager(address)\":{\"details\":\"Owner can enroll a watcher (abilities are defined by inheriting contracts)\"},\"validateDomains(uint32[],address[])\":{\"details\":\"Reverts if domains or connectors do not match, including ordering.\"}},\"stateVariables\":{\"pendingInboundRoots\":{\"details\":\"Watchers should be able to watch this queue for fraudulent messages and pause this contract if fraud is detected.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"MERKLE()\":{\"notice\":\"MerkleTreeManager contract instance. Will hold the active tree of aggregated inbound roots. The root of this tree will be distributed crosschain to all spoke domains.\"},\"acceptProposedOwner()\":{\"notice\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"addConnector(uint32,address)\":{\"notice\":\"Add a new supported domain and corresponding hub connector to the system. This new domain will receive the propagated aggregate root.\"},\"aggregate(uint32,bytes32)\":{\"notice\":\"Accept an inbound root coming from a given domain's hub connector, enqueuing this incoming root into the current queue as it awaits the verification period.\"},\"connectors(uint256)\":{\"notice\":\"Tracks the addresses of the hub connector contracts corresponding to subscribed spoke domains. The index of any given connector in this array should match the index of that connector's target spoke domain in the `domains` array above.\"},\"connectorsHash()\":{\"notice\":\"A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided array of connectors matches the one we have in storage.\"},\"constructor\":{\"notice\":\"Creates a new RootManager instance.\"},\"delay()\":{\"notice\":\"Returns the delay period before a new owner can be accepted.\"},\"delayBlocks()\":{\"notice\":\"Number of blocks to delay the processing of a message to allow for watchers to verify the validity and pause if necessary.\"},\"domains(uint256)\":{\"notice\":\"Domains array tracks currently subscribed domains to this hub aggregator. We should distribute the aggregate root to all of these domains in the `propagate` method.\"},\"domainsHash()\":{\"notice\":\"A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided array of domains matches the one we have in storage.\"},\"getConnectorForDomain(uint32)\":{\"notice\":\"Gets the corresponding hub connector address for a given spoke domain.\"},\"getDomainIndex(uint32)\":{\"notice\":\"Gets the index of a given domain in the domains and connectors arrays.\"},\"isDomainSupported(uint32)\":{\"notice\":\"Convenience shortcut for supported domains. Used to sanity check adding new domains.\"},\"owner()\":{\"notice\":\"Returns the address of the current owner.\"},\"pendingInboundRoots()\":{\"notice\":\"Queue used for management of verification for inbound roots from spoke chains. Once the verification period elapses, the inbound messages can be aggregated into the merkle tree for propagation to spoke chains.\"},\"propagate(uint32[],address[])\":{\"notice\":\"This is called by relayers to take the current aggregate tree root and propagate it to all spoke domains (via their respective hub connectors).\"},\"proposeNewOwner(address)\":{\"notice\":\"Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process\"},\"proposed()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"proposedTimestamp()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"removeConnector(uint32)\":{\"notice\":\"Remove support for a connector and respective domain. That connector/domain will no longer receive updates for the latest aggregate root.\"},\"renounceOwnership()\":{\"notice\":\"Renounces ownership of the contract after a delay\"},\"renounced()\":{\"notice\":\"Indicates if the ownership has been renounced() by checking if current owner is address(0)\"},\"setDelayBlocks(uint256)\":{\"notice\":\"Set the `delayBlocks`, the period in blocks over which an incoming message is verified.\"},\"validateDomains(uint32[],address[])\":{\"notice\":\"Validate given domains and connectors arrays are correct (i.e. they mirror what is currently saved in storage).\"}},\"notice\":\"This contract exists at cluster hubs, and aggregates all transfer roots from messaging spokes into a single merkle root\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/messaging/RootManager.sol\":\"RootManager\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0203dcadc5737d9ef2c211d6fa15d18ebc3b30dfa51903b64870b01a062b0b4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x611aa3f23e59cfdd1863c536776407b3e33d695152a266fa7cfb34440a29a8a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x0849d93b16c9940beb286a7864ed02724b248b93e0d80ef6355af5ef15c64773\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/messaging/Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport {ProposedOwnableUpgradeable} from \\\"../shared/ProposedOwnable.sol\\\";\\nimport {MerkleLib} from \\\"./libraries/Merkle.sol\\\";\\n\\n/**\\n * @title MerkleTreeManager\\n * @notice Contains a Merkle tree instance and exposes read/write functions for the tree.\\n */\\ncontract MerkleTreeManager is ProposedOwnableUpgradeable {\\n  // ========== Custom Errors ===========\\n\\n  error MerkleTreeManager__setArborist_zeroAddress();\\n  error MerkleTreeManager__setArborist_alreadyArborist();\\n\\n  // ============ Libraries ============\\n\\n  using MerkleLib for MerkleLib.Tree;\\n\\n  // ============ Public Storage ============\\n\\n  /**\\n   * @notice Core data structure with which this contract is tasked with keeping custody.\\n   * Writable only by the designated arborist.\\n   */\\n  MerkleLib.Tree public tree;\\n\\n  /**\\n   * @notice The arborist contract that has permission to write to this tree.\\n   * @dev This could be the root manager contract or a spoke connector contract, for example.\\n   */\\n  mapping(address => bool) public arborists;\\n\\n  // ============ Upgrade Gap ============\\n\\n  uint256[49] private __GAP; // gap for upgrade safety\\n\\n  // ============ Modifiers ============\\n\\n  modifier onlyArborist() {\\n    require(arborists[msg.sender], \\\"!arborist\\\");\\n    _;\\n  }\\n\\n  // ============ Getters ============\\n\\n  /**\\n   * @notice Returns the current branch.\\n   */\\n  function branch() public view returns (bytes32[32] memory) {\\n    return tree.branch;\\n  }\\n\\n  /**\\n   * @notice Calculates and returns the current root.\\n   */\\n  function root() public view returns (bytes32) {\\n    return tree.root();\\n  }\\n\\n  /**\\n   * @notice Returns the number of inserted leaves in the tree (current index).\\n   */\\n  function count() public view returns (uint256) {\\n    return tree.count;\\n  }\\n\\n  // ======== Initializer =========\\n\\n  function initialize(address _arborist) public initializer {\\n    __MerkleTreeManager_init(_arborist);\\n    __ProposedOwnable_init();\\n  }\\n\\n  /**\\n   * @dev Initializes MerkleTreeManager instance. Sets the msg.sender as the initial permissioned\\n   */\\n  function __MerkleTreeManager_init(address _arborist) internal onlyInitializing {\\n    __MerkleTreeManager_init_unchained(_arborist);\\n  }\\n\\n  function __MerkleTreeManager_init_unchained(address _arborist) internal onlyInitializing {\\n    arborists[_arborist] = true;\\n  }\\n\\n  // ============ Admin Functions ==============\\n\\n  /**\\n   * @notice Method for the current arborist to assign write permissions to a new arborist.\\n   * @param newArborist The new address to set as the current arborist.\\n   */\\n  function setArborist(address newArborist) external onlyOwner {\\n    if (newArborist == address(0)) revert MerkleTreeManager__setArborist_zeroAddress();\\n    if (arborists[newArborist]) revert MerkleTreeManager__setArborist_alreadyArborist();\\n    arborists[newArborist] = true;\\n  }\\n\\n  // ========= Public Functions =========\\n\\n  /**\\n   * @notice Inserts the given leaves into the tree.\\n   * @param leaves The leaves to be inserted into the tree.\\n   * @return _root Current root for convenience.\\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\\n   * provided for convenience.\\n   */\\n  function insert(bytes32[] memory leaves) public onlyArborist returns (bytes32 _root, uint256 _count) {\\n    // TODO: Considerably more efficient to put this tree into memory, conduct operations,\\n    // then re-assign it to storage - *especially* if we have multiple leaves to insert.\\n    // MerkleLib.Tree memory _tree = tree;\\n\\n    for (uint256 i; i < leaves.length; ) {\\n      // Insert the new node.\\n      tree.insert(leaves[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Get return details for convenience.\\n    _root = tree.root();\\n    _count = tree.count;\\n\\n    // TODO: IFF using tree assigned to memory, write the newly updated tree to storage.\\n    // tree = _tree;\\n  }\\n\\n  /**\\n   * @notice Inserts the given leaf into the tree.\\n   * @param leaf The leaf to be inserted into the tree.\\n   * @return _root Current root for convenience.\\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\\n   * provided for convenience.\\n   */\\n  function insert(bytes32 leaf) public onlyArborist returns (bytes32 _root, uint256 _count) {\\n    // Insert the new node.\\n    tree.insert(leaf);\\n    _count = tree.count;\\n    _root = tree.root();\\n  }\\n}\\n\",\"keccak256\":\"0x4e67ceb1524ac144f16f0346138e22b462692e02926e0b1273d9ff3c4c9e070d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/RootManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport {ProposedOwnable} from \\\"../shared/ProposedOwnable.sol\\\";\\n\\nimport {IRootManager} from \\\"./interfaces/IRootManager.sol\\\";\\nimport {IHubConnector} from \\\"./interfaces/IHubConnector.sol\\\";\\nimport {Message} from \\\"./libraries/Message.sol\\\";\\nimport {QueueLib} from \\\"./libraries/Queue.sol\\\";\\nimport {DomainIndexer} from \\\"./libraries/DomainIndexer.sol\\\";\\n\\nimport {MerkleTreeManager} from \\\"./Merkle.sol\\\";\\nimport {WatcherClient} from \\\"./WatcherClient.sol\\\";\\n\\n/**\\n * @notice This contract exists at cluster hubs, and aggregates all transfer roots from messaging\\n * spokes into a single merkle root\\n */\\ncontract RootManager is ProposedOwnable, IRootManager, WatcherClient, DomainIndexer {\\n  // ============ Libraries ============\\n\\n  using QueueLib for QueueLib.Queue;\\n\\n  // ============ Events ============\\n\\n  event DelayBlocksUpdated(uint256 previous, uint256 updated);\\n\\n  event RootAggregated(uint32 domain, bytes32 receivedRoot, uint256 queueIndex);\\n\\n  event RootPropagated(bytes32 aggregateRoot, uint256 count, uint32[] domains, bytes32[] aggregatedMessageRoots);\\n\\n  event ConnectorAdded(uint32 domain, address connector, uint32[] domains, address[] connectors);\\n\\n  event ConnectorRemoved(uint32 domain, address connector, uint32[] domains, address[] connectors, address caller);\\n\\n  // ============ Properties ============\\n\\n  /**\\n   * @notice Number of blocks to delay the processing of a message to allow for watchers to verify\\n   * the validity and pause if necessary.\\n   */\\n  uint256 public delayBlocks;\\n\\n  /**\\n   * @notice Queue used for management of verification for inbound roots from spoke chains. Once\\n   * the verification period elapses, the inbound messages can be aggregated into the merkle tree\\n   * for propagation to spoke chains.\\n   * @dev Watchers should be able to watch this queue for fraudulent messages and pause this contract\\n   * if fraud is detected.\\n   */\\n  QueueLib.Queue public pendingInboundRoots;\\n\\n  /**\\n   * @notice MerkleTreeManager contract instance. Will hold the active tree of aggregated inbound roots.\\n   * The root of this tree will be distributed crosschain to all spoke domains.\\n   */\\n  MerkleTreeManager public immutable MERKLE;\\n\\n  // ============ Modifiers ============\\n\\n  modifier onlyConnector(uint32 _domain) {\\n    require(getConnectorForDomain(_domain) == msg.sender, \\\"!connector\\\");\\n    _;\\n  }\\n\\n  // ============ Constructor ============\\n\\n  /**\\n   * @notice Creates a new RootManager instance.\\n   * @param _delayBlocks The delay for the validation period for incoming messages in blocks.\\n   * @param _merkle The address of the MerkleTreeManager on this domain.\\n   * @param _watcherManager The address of the WatcherManager on this domain.\\n   */\\n  constructor(\\n    uint256 _delayBlocks,\\n    address _merkle,\\n    address _watcherManager\\n  ) ProposedOwnable() WatcherClient(_watcherManager) {\\n    _setOwner(msg.sender);\\n\\n    require(_merkle != address(0), \\\"!zero merkle\\\");\\n    MERKLE = MerkleTreeManager(_merkle);\\n\\n    delayBlocks = _delayBlocks;\\n\\n    // Initialize pending inbound root queue.\\n    pendingInboundRoots.initialize();\\n  }\\n\\n  // ================ Getters ================\\n\\n  function getPendingInboundRootsCount() public view returns (uint256) {\\n    return pendingInboundRoots.length();\\n  }\\n\\n  // ============ Admin Functions ============\\n\\n  /**\\n   * @notice Set the `delayBlocks`, the period in blocks over which an incoming message\\n   * is verified.\\n   */\\n  function setDelayBlocks(uint256 _delayBlocks) public onlyOwner {\\n    require(_delayBlocks != delayBlocks, \\\"!delayBlocks\\\");\\n    emit DelayBlocksUpdated(_delayBlocks, delayBlocks);\\n    delayBlocks = _delayBlocks;\\n  }\\n\\n  /**\\n   * @notice Add a new supported domain and corresponding hub connector to the system. This new domain\\n   * will receive the propagated aggregate root.\\n   * @dev Only owner can add a new connector. Address should be the connector on L1.\\n   * @dev Cannot add address(0) to avoid duplicated domain in array and reduce gas fee while propagating.\\n   *\\n   * @param _domain The target spoke domain of the given connector.\\n   * @param _connector Address of the hub connector.\\n   */\\n  function addConnector(uint32 _domain, address _connector) external onlyOwner {\\n    addDomain(_domain, _connector);\\n    emit ConnectorAdded(_domain, _connector, domains, connectors);\\n  }\\n\\n  /**\\n   * @notice Remove support for a connector and respective domain. That connector/domain will no longer\\n   * receive updates for the latest aggregate root.\\n   * @dev Only watcher can remove a connector.\\n   * TODO: Could add a metatx-able `removeConnectorWithSig` if we want to use relayers?\\n   *\\n   * @param _domain The spoke domain of the target connector we want to remove.\\n   */\\n  function removeConnector(uint32 _domain) public onlyWatcher {\\n    address _connector = removeDomain(_domain);\\n    emit ConnectorRemoved(_domain, _connector, domains, connectors, msg.sender);\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice This is called by relayers to take the current aggregate tree root and propagate it to all\\n   * spoke domains (via their respective hub connectors).\\n   * @dev Should be called by relayers at a regular interval.\\n   *\\n   * @param _domains Array of domains: should match exactly the array of `domains` in storage; used here\\n   * to reduce gas costs, and keep them static regardless of number of supported domains.\\n   * @param _connectors Array of connectors: should match exactly the array of `connectors` in storage\\n   * (see `_domains` param's info on reducing gas costs).\\n   */\\n  function propagate(uint32[] calldata _domains, address[] calldata _connectors) external whenNotPaused {\\n    uint256 _numDomains = _domains.length;\\n\\n    // Sanity check: domains length matches connectors length.\\n    require(_connectors.length == _numDomains, \\\"invalid lengths\\\");\\n    validateDomains(_domains, _connectors);\\n\\n    // Get all of the verified roots from the queue.\\n    bytes32[] memory _verifiedInboundRoots = pendingInboundRoots.dequeueVerified(delayBlocks);\\n\\n    // Sanity check: there must be some verified roots to aggregate and send: otherwise we would be\\n    // propagating a redundant aggregate root.\\n    require(_verifiedInboundRoots.length != 0, \\\"no verified roots\\\");\\n\\n    // Insert the leaves into the aggregator tree (method will also calculate and return the current\\n    // aggregate root and count).\\n    (bytes32 _aggregateRoot, uint256 _count) = MERKLE.insert(_verifiedInboundRoots);\\n\\n    for (uint32 i; i < _numDomains; ) {\\n      IHubConnector(_connectors[i]).sendMessage(abi.encodePacked(_aggregateRoot));\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    emit RootPropagated(_aggregateRoot, _count, _domains, _verifiedInboundRoots);\\n  }\\n\\n  /**\\n   * @notice Accept an inbound root coming from a given domain's hub connector, enqueuing this incoming\\n   * root into the current queue as it awaits the verification period.\\n   * @dev The aggregate tree's root, which will include this inbound root, will be propagated to all spoke\\n   * domains (via `propagate`) on a regular basis assuming the verification period is surpassed without\\n   * dispute.\\n   *\\n   * @param _domain The source domain of the given root.\\n   * @param _inbound The inbound root coming from the given domain.\\n   */\\n  function aggregate(uint32 _domain, bytes32 _inbound) external whenNotPaused onlyConnector(_domain) {\\n    uint128 lastIndex = pendingInboundRoots.enqueue(_inbound);\\n    emit RootAggregated(_domain, _inbound, lastIndex);\\n  }\\n}\\n\",\"keccak256\":\"0xb40c30d7ee3cc467bdf5e92dbb92e3cf37964d26c5458058bb2fe3d5f77e78fc\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/WatcherClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport {ProposedOwnable} from \\\"../shared/ProposedOwnable.sol\\\";\\nimport {WatcherManager} from \\\"./WatcherManager.sol\\\";\\n\\n/**\\n * @notice This contract abstracts the functionality of the watcher manager.\\n * Contracts can inherit this contract to be able to use the watcher manager's shared watcher set.\\n */\\n\\ncontract WatcherClient is ProposedOwnable, Pausable {\\n  // ============ Events ============\\n  event WatcherManagerChanged(address watcherManager);\\n\\n  // ============ Properties ============\\n  WatcherManager watcherManager;\\n\\n  // ============ Constructor ============\\n  constructor(address _watcherManager) {\\n    watcherManager = WatcherManager(_watcherManager);\\n  }\\n\\n  // ============ Modifiers ============\\n  modifier onlyWatcher() {\\n    require(watcherManager.isWatcher(msg.sender), \\\"!watcher\\\");\\n    _;\\n  }\\n\\n  // ============ Admin fns ============\\n  /**\\n   * @dev Owner can enroll a watcher (abilities are defined by inheriting contracts)\\n   */\\n  function setWatcherManager(address _watcherManager) external onlyOwner {\\n    require(_watcherManager != address(watcherManager), \\\"already watcher manager\\\");\\n    emit WatcherManagerChanged(_watcherManager);\\n  }\\n\\n  function unpause() external onlyOwner whenPaused {\\n    _unpause();\\n  }\\n\\n  // ============ Watcher fns ============\\n  function pause() external onlyWatcher whenNotPaused {\\n    _pause();\\n  }\\n}\\n\",\"keccak256\":\"0x514af3a812ca16aa1bf486a26a3c8140ca8ca8d7ef815e02c0e25105988485ee\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/WatcherManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport {ProposedOwnable} from \\\"../shared/ProposedOwnable.sol\\\";\\n\\n/**\\n * @notice This contract manages a set of watchers. This is meant to be used as a shared resource that contracts can\\n * inherit to make use of the same watcher set.\\n */\\n\\ncontract WatcherManager is ProposedOwnable {\\n  // ============ Events ============\\n  event WatcherAdded(address watcher);\\n\\n  event WatcherRemoved(address watcher);\\n\\n  // ============ Properties ============\\n  mapping(address => bool) private watchers;\\n\\n  // ============ Constructor ============\\n  constructor() ProposedOwnable() {\\n    _setOwner(msg.sender);\\n  }\\n\\n  // ============ Modifiers ============\\n\\n  // ============ Admin fns ============\\n  /**\\n   * @dev Owner can enroll a watcher (abilities are defined by inheriting contracts)\\n   */\\n  function addWatcher(address _watcher) external onlyOwner {\\n    require(!watchers[_watcher], \\\"already watcher\\\");\\n    watchers[_watcher] = true;\\n    emit WatcherAdded(_watcher);\\n  }\\n\\n  /**\\n   * @dev Owner can unenroll a watcher (abilities are defined by inheriting contracts)\\n   */\\n  function removeWatcher(address _watcher) external onlyOwner {\\n    require(watchers[_watcher], \\\"!exist\\\");\\n    watchers[_watcher] = false;\\n    emit WatcherRemoved(_watcher);\\n  }\\n\\n  // ============ Getters ============\\n  function isWatcher(address _watcher) external view returns (bool) {\\n    return watchers[_watcher];\\n  }\\n}\\n\",\"keccak256\":\"0xe4dbdffe99260d395ba8c0c5d41a9ec584dbc0466f38ddc01981a6392f858226\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport {IProposedOwnable} from \\\"../../shared/interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @notice This interface is what the Connext contract will send and receive messages through.\\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\\n * could be Nomad or a generic AMB under the hood).\\n *\\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\\n *\\n * Flow from transfer from polygon to optimism:\\n * 1. User calls `xcall` with destination specified\\n * 2. This will swap in to the bridge assets\\n * 3. The swapped assets will get burned\\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\\n *    to the root\\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\\n *    mainnet. This is done on all \\\"spoke\\\" domains.\\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\\n *    root from all of the AMBs\\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\\n *      tree root\\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\\n *    process on the `Connext` contract\\n * 9. Takes minted bridge tokens and credits the LP\\n *\\n * AMB requirements:\\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\\n * - Ability to read *our root* from the AMB\\n *\\n * AMBs:\\n * - PoS bridge from polygon\\n * - arbitrum bridge\\n * - optimism bridge\\n * - gnosis chain\\n * - bsc (use multichain for messaging)\\n */\\ninterface IConnector is IProposedOwnable {\\n  // ============ Events ============\\n  /**\\n   * @notice Emitted whenever a message is successfully sent over an AMB\\n   * @param data The contents of the message\\n   * @param caller Who called the function (sent the message)\\n   */\\n  event MessageSent(bytes data, address caller);\\n\\n  /**\\n   * @notice Emitted whenever a message is successfully received over an AMB\\n   * @param data The contents of the message\\n   * @param caller Who called the function\\n   */\\n  event MessageProcessed(bytes data, address caller);\\n\\n  // ============ Public fns ============\\n\\n  function processMessage(bytes memory _data) external;\\n\\n  function verifySender(address _expected) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4a68506b623f3b6e54552bace2d56e53602473faa24c3e2e5b78ff43bb99120d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IHubConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport {IConnector} from \\\"./IConnector.sol\\\";\\n\\ninterface IHubConnector is IConnector {\\n  function sendMessage(bytes memory _data) external;\\n}\\n\",\"keccak256\":\"0xb302b9cd48c15cc308fb88a4539e8b8b9694e95c8e73fe31c4e20509ad1399b9\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IRootManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\ninterface IRootManager {\\n  /**\\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\\n   * spoke domains.\\n   * @dev This must read information for the root from the registered AMBs.\\n   */\\n  function propagate(uint32[] calldata _domains, address[] calldata _connectors) external;\\n\\n  /**\\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\\n   * inbound root.\\n   * @dev This must read information for the root from the registered AMBs\\n   */\\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\\n}\\n\",\"keccak256\":\"0x63a56570ba3c6e4622c1172c79d924fd91a0ff0d103e15885bcbe99cc783048d\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/DomainIndexer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\n/**\\n * @notice This abstract contract was written to ensure domain and connector mutex is scalable for the\\n * purposes of messaging layer operations. In particular, it aims to reduce gas costs to be relatively\\n * static regardless of the number of domains kept in storage by enabling callers of `RootManager.propagate`\\n * to supply the `domains` and `connectors` arrays as params, and check the hashes of those params against\\n * those we keep in storage.\\n */\\nabstract contract DomainIndexer {\\n  // ============ Properties ============\\n\\n  /**\\n   * @notice Domains array tracks currently subscribed domains to this hub aggregator.\\n   * We should distribute the aggregate root to all of these domains in the `propagate` method.\\n   * @dev Whenever this domains array is updated, the connectors array should also be updated.\\n   */\\n  uint32[] public domains;\\n\\n  /**\\n   * @notice A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided\\n   * array of domains matches the one we have in storage.\\n   * @dev This hash should be re-calculated whenever the domains array is updated.\\n   */\\n  bytes32 public domainsHash;\\n\\n  /**\\n   * @notice Tracks the addresses of the hub connector contracts corresponding to subscribed spoke domains.\\n   * The index of any given connector in this array should match the index of that connector's target spoke\\n   * domain in the `domains` array above.\\n   * @dev This should be updated whenever the domains array is updated.\\n   */\\n  address[] public connectors;\\n\\n  /**\\n   * @notice A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided\\n   * array of connectors matches the one we have in storage.\\n   * @dev This hash should be re-calculated whenever the connectors array is updated.\\n   */\\n  bytes32 public connectorsHash;\\n\\n  /**\\n   * @notice Shortcut to reverse lookup the index by domain. We index starting at one so the zero value can\\n   * be considered invalid (see fn: `isDomainSupported`).\\n   * @dev This should be updated whenever the domains array is updated.\\n   */\\n  mapping(uint32 => uint256) private domainToIndexPlusOne;\\n\\n  // ============ Getters ============\\n\\n  /**\\n   * @notice Convenience shortcut for supported domains. Used to sanity check adding new domains.\\n   * @param _domain Domain to check.\\n   */\\n  function isDomainSupported(uint32 _domain) public view returns (bool) {\\n    return domainToIndexPlusOne[_domain] != 0;\\n  }\\n\\n  /**\\n   * @notice Gets the index of a given domain in the domains and connectors arrays.\\n   * @dev Reverts if domain is not supported.\\n   * @param _domain The domain for which to get the index value.\\n   */\\n  function getDomainIndex(uint32 _domain) public view returns (uint256) {\\n    uint256 index = domainToIndexPlusOne[_domain];\\n    require(index != 0, \\\"!supported\\\");\\n    return index - 1;\\n  }\\n\\n  /**\\n   * @notice Gets the corresponding hub connector address for a given spoke domain.\\n   * @dev Inefficient, should only be used by caller if they have no index reference.\\n   * @param _domain The domain for which to get the hub connector address.\\n   */\\n  function getConnectorForDomain(uint32 _domain) public view returns (address) {\\n    return connectors[getDomainIndex(_domain)];\\n  }\\n\\n  /**\\n   * @notice Validate given domains and connectors arrays are correct (i.e. they mirror what is\\n   * currently saved in storage).\\n   * @dev Reverts if domains or connectors do not match, including ordering.\\n   */\\n  function validateDomains(uint32[] calldata _domains, address[] calldata _connectors) public view {\\n    // Validate that given domains match the current array in storage.\\n    require(keccak256(abi.encode(_domains)) == domainsHash, \\\"!domains\\\");\\n    // Validate that given connectors match the current array in storage.\\n    require(keccak256(abi.encode(_connectors)) == connectorsHash, \\\"!connectors\\\");\\n  }\\n\\n  // ============ Helper Functions ============\\n\\n  /**\\n   * @notice Handles all mutex for adding support for a given domain.\\n   * @param _domain Domain for which we are adding support.\\n   * @param _connector Corresponding hub connector address belonging to given domain.\\n   */\\n  function addDomain(uint32 _domain, address _connector) internal {\\n    // Sanity check: domain does not already exist.\\n    require(!isDomainSupported(_domain), \\\"exists\\\");\\n    // Sanity check: connector is reasonable.\\n    require(_connector != address(0), \\\"!connector\\\");\\n\\n    // Push domain and connector to respective arrays.\\n    domains.push(_domain);\\n    connectors.push(_connector);\\n    // Set reverse lookup.\\n    uint256 _indexPlusOne = domains.length;\\n    domainToIndexPlusOne[_domain] = _indexPlusOne;\\n\\n    // Update the hashes for the given arrays.\\n    updateHashes();\\n  }\\n\\n  /**\\n   * @notice Handles all mutex for removing support for a given domain.\\n   * @param _domain Domain we are removing.\\n   * @return address of the hub connector for the domain we removed.\\n   */\\n  function removeDomain(uint32 _domain) internal returns (address) {\\n    uint256 _index = getDomainIndex(_domain);\\n    // Get the connector at the given index.\\n    address _connector = connectors[_index];\\n    // Sanity check: connector exists.\\n    require(_connector != address(0), \\\"connector !exists\\\");\\n\\n    // Shortcut: is the index the last index in the domains/connectors arrays?\\n    // IFF not, we'll need to swap the target with the current last so we can pop().\\n    uint256 _lastIndex = domains.length - 1;\\n    if (_index < _lastIndex) {\\n      // If the target index for removal is not the last index, we'll need to move the last index\\n      // item to the target index's place so we can conveniently pop the last item.\\n      // Replace domain in domains array with the domain in the final index.\\n      domains[_index] = domains[_lastIndex];\\n      connectors[_index] = connectors[_lastIndex];\\n    }\\n\\n    // Pop the last item in the arrays.\\n    domains.pop();\\n    connectors.pop();\\n    // Erase reverse lookup.\\n    delete domainToIndexPlusOne[_domain];\\n\\n    // Update the hashes for the given arrays.\\n    updateHashes();\\n\\n    return _connector;\\n  }\\n\\n  /**\\n   * @notice Calculate the new hashes for the domains and connectors arrays and update storage refs.\\n   * @dev Used for the Connector update functions `addConnector`, `removeConnector`.\\n   */\\n  function updateHashes() internal {\\n    uint32[] memory _domains = domains;\\n    address[] memory _connectors = connectors;\\n    domainsHash = keccak256(abi.encode(_domains));\\n    connectorsHash = keccak256(abi.encode(_connectors));\\n  }\\n}\\n\",\"keccak256\":\"0x83a275c5a53c13c7cd1e58994f2cc565e321d77d31a040fb2f58d0fdda65228c\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\n/**\\n * @title MerkleLib\\n * @author Illusory Systems Inc.\\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\\n **/\\nlibrary MerkleLib {\\n  // ========== Custom Errors ===========\\n\\n  error MerkleLib__insert_treeIsFull();\\n\\n  // ============ Constants =============\\n\\n  uint256 internal constant TREE_DEPTH = 32;\\n  uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\\n\\n  /**\\n   * @notice Struct representing incremental merkle tree. Contains current\\n   * branch and the number of inserted leaves in the tree.\\n   **/\\n  struct Tree {\\n    bytes32[TREE_DEPTH] branch;\\n    uint256 count;\\n  }\\n\\n  // ========= In-Memory Methods =========\\n\\n  /**\\n   * @notice Inserts a given node (leaf) into merkle tree. Operates on an in-memory tree and\\n   * returns an updated version of that tree.\\n   * @dev Reverts if the tree is already full.\\n   * @param node Element to insert into tree.\\n   * @return Tree Updated tree.\\n   **/\\n  // function insert(Tree memory tree, bytes32 node) internal pure returns (Tree memory) {\\n  //   uint256 size = tree.count + 1; // Add 1 since we'll be including a new node.\\n  //   if (size >= MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\\n\\n  //   // Update tree.count to increase the current count by 1.\\n  //   tree.count = size;\\n\\n  //   // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\\n  //   // the active branch. Each loop we cut size in half, hashing the inserted node up the active\\n  //   // branch along the way.\\n  //   for (uint256 i; i < TREE_DEPTH; ) {\\n  //     // Check if the current size is odd; if so, we set this index in the branch to be the node.\\n  //     if ((size & 1) == 1) {\\n  //       // If i > 0, then this node will be a hash of the original node with every layer up\\n  //       // until layer `i`.\\n  //       tree.branch[i] = node;\\n  //       return tree;\\n  //     }\\n  //     // If the size is not yet odd, we hash the current index in the tree branch with the node.\\n  //     node = keccak256(abi.encodePacked(tree.branch[i], node));\\n  //     size /= 2;\\n\\n  //     unchecked {\\n  //       ++i;\\n  //     }\\n  //   }\\n  //   // As the loop should always end prematurely with the `return` statement, this code should\\n  //   // be unreachable. We revert here just to be safe.\\n  //   revert MerkleLib__insert_treeIsFull();\\n  // }\\n\\n  // ========= Storage Methods =========\\n\\n  /**\\n   * @notice Inserts a given node (leaf) into merkle tree.\\n   * @dev Reverts if the tree is already full.\\n   * @param node Element to insert into tree.\\n   * @return uint256 Updated count (number of nodes in the tree).\\n   **/\\n  function insert(Tree storage tree, bytes32 node) internal returns (uint256) {\\n    uint256 size = tree.count + 1; // Add 1 since we'll be including a new node.\\n    if (size >= MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\\n\\n    // Update tree.count to increase the current count by 1.\\n    tree.count = size;\\n\\n    // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\\n    // the active branch. Each loop we cut size in half, hashing the inserted node up the active\\n    // branch along the way.\\n    for (uint256 i; i < TREE_DEPTH; ) {\\n      // Check if the current size is odd; if so, we set this index in the branch to be the node.\\n      if ((size & 1) == 1) {\\n        // If i > 0, then this node will be a hash of the original node with every layer up\\n        // until layer `i`.\\n        tree.branch[i] = node;\\n        return size;\\n      }\\n      // If the size is not yet odd, we hash the current index in the tree branch with the node.\\n      node = keccak256(abi.encodePacked(tree.branch[i], node));\\n      size /= 2;\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    // As the loop should always end prematurely with the `return` statement, this code should\\n    // be unreachable. We revert here just to be safe.\\n    revert MerkleLib__insert_treeIsFull();\\n  }\\n\\n  /**\\n   * @notice Calculates and returns tree's current root.\\n   * @return bytes32 root.\\n   **/\\n  function root(Tree storage tree) internal view returns (bytes32) {\\n    return rootWithCtx(tree, zeroHashes());\\n  }\\n\\n  // ========= Helper Methods =========\\n\\n  /**\\n   * @notice Calculates and returns tree's current root given array of zero hashes.\\n   * @param _zeroes Array of zero hashes.\\n   * @return _current Calculated root of tree.\\n   **/\\n  function rootWithCtx(Tree storage tree, bytes32[TREE_DEPTH] memory _zeroes) internal view returns (bytes32 _current) {\\n    uint256 _index = tree.count;\\n\\n    // TODO: Optimization: skip the first N loops where the ith bits are all 0 - start at that\\n    // depth with zero hashes.\\n    for (uint256 i; i < TREE_DEPTH; ) {\\n      uint256 _ithBit = (_index >> i) & 0x01;\\n      if (_ithBit == 1) {\\n        _current = keccak256(abi.encodePacked(tree.branch[i], _current));\\n      } else {\\n        _current = keccak256(abi.encodePacked(_current, _zeroes[i]));\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates and returns the merkle root for the given leaf `_item`,\\n   * a merkle branch, and the index of `_item` in the tree.\\n   * @param _item Merkle leaf\\n   * @param _branch Merkle proof\\n   * @param _index Index of `_item` in tree\\n   * @return _current Calculated merkle root\\n   **/\\n  function branchRoot(\\n    bytes32 _item,\\n    bytes32[TREE_DEPTH] memory _branch,\\n    uint256 _index\\n  ) internal pure returns (bytes32 _current) {\\n    _current = _item;\\n\\n    for (uint256 i; i < TREE_DEPTH; ) {\\n      uint256 _ithBit = (_index >> i) & 0x01;\\n      bytes32 _next = _branch[i];\\n      if (_ithBit == 1) {\\n        _current = keccak256(abi.encodePacked(_next, _current));\\n      } else {\\n        _current = keccak256(abi.encodePacked(_current, _next));\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Returns array of TREE_DEPTH zero hashes\\n  /// @return _zeroes Array of TREE_DEPTH zero hashes\\n  function zeroHashes() internal pure returns (bytes32[TREE_DEPTH] memory _zeroes) {\\n    _zeroes[0] = Z_0;\\n    _zeroes[1] = Z_1;\\n    _zeroes[2] = Z_2;\\n    _zeroes[3] = Z_3;\\n    _zeroes[4] = Z_4;\\n    _zeroes[5] = Z_5;\\n    _zeroes[6] = Z_6;\\n    _zeroes[7] = Z_7;\\n    _zeroes[8] = Z_8;\\n    _zeroes[9] = Z_9;\\n    _zeroes[10] = Z_10;\\n    _zeroes[11] = Z_11;\\n    _zeroes[12] = Z_12;\\n    _zeroes[13] = Z_13;\\n    _zeroes[14] = Z_14;\\n    _zeroes[15] = Z_15;\\n    _zeroes[16] = Z_16;\\n    _zeroes[17] = Z_17;\\n    _zeroes[18] = Z_18;\\n    _zeroes[19] = Z_19;\\n    _zeroes[20] = Z_20;\\n    _zeroes[21] = Z_21;\\n    _zeroes[22] = Z_22;\\n    _zeroes[23] = Z_23;\\n    _zeroes[24] = Z_24;\\n    _zeroes[25] = Z_25;\\n    _zeroes[26] = Z_26;\\n    _zeroes[27] = Z_27;\\n    _zeroes[28] = Z_28;\\n    _zeroes[29] = Z_29;\\n    _zeroes[30] = Z_30;\\n    _zeroes[31] = Z_31;\\n  }\\n\\n  // keccak256 zero hashes\\n  bytes32 internal constant Z_0 = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\";\\n  bytes32 internal constant Z_1 = hex\\\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\\\";\\n  bytes32 internal constant Z_2 = hex\\\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\\\";\\n  bytes32 internal constant Z_3 = hex\\\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\\\";\\n  bytes32 internal constant Z_4 = hex\\\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\\\";\\n  bytes32 internal constant Z_5 = hex\\\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\\\";\\n  bytes32 internal constant Z_6 = hex\\\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\\\";\\n  bytes32 internal constant Z_7 = hex\\\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\\\";\\n  bytes32 internal constant Z_8 = hex\\\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\\\";\\n  bytes32 internal constant Z_9 = hex\\\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\\\";\\n  bytes32 internal constant Z_10 = hex\\\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\\\";\\n  bytes32 internal constant Z_11 = hex\\\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\\\";\\n  bytes32 internal constant Z_12 = hex\\\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\\\";\\n  bytes32 internal constant Z_13 = hex\\\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\\\";\\n  bytes32 internal constant Z_14 = hex\\\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\\\";\\n  bytes32 internal constant Z_15 = hex\\\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\\\";\\n  bytes32 internal constant Z_16 = hex\\\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\\\";\\n  bytes32 internal constant Z_17 = hex\\\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\\\";\\n  bytes32 internal constant Z_18 = hex\\\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\\\";\\n  bytes32 internal constant Z_19 = hex\\\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\\\";\\n  bytes32 internal constant Z_20 = hex\\\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\\\";\\n  bytes32 internal constant Z_21 = hex\\\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\\\";\\n  bytes32 internal constant Z_22 = hex\\\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\\\";\\n  bytes32 internal constant Z_23 = hex\\\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\\\";\\n  bytes32 internal constant Z_24 = hex\\\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\\\";\\n  bytes32 internal constant Z_25 = hex\\\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\\\";\\n  bytes32 internal constant Z_26 = hex\\\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\\\";\\n  bytes32 internal constant Z_27 = hex\\\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\\\";\\n  bytes32 internal constant Z_28 = hex\\\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\\\";\\n  bytes32 internal constant Z_29 = hex\\\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\\\";\\n  bytes32 internal constant Z_30 = hex\\\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\\\";\\n  bytes32 internal constant Z_31 = hex\\\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\\\";\\n}\\n\",\"keccak256\":\"0xbdb82e7bd59dbd445063a4b19c24294fa9629d9a9b758e6320b0284c360d8e36\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/Message.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport \\\"../../shared/libraries/TypedMemView.sol\\\";\\n\\nimport {TypeCasts} from \\\"../../shared/libraries/TypeCasts.sol\\\";\\n\\n/**\\n * @title Message Library\\n * @author Illusory Systems Inc.\\n * @notice Library for formatted messages used by Home and Replica.\\n **/\\nlibrary Message {\\n  using TypedMemView for bytes;\\n  using TypedMemView for bytes29;\\n\\n  // Number of bytes in formatted message before `body` field\\n  uint256 internal constant PREFIX_LENGTH = 76;\\n\\n  /**\\n   * @notice Returns formatted (packed) message with provided fields\\n   * @param _originDomain Domain of home chain\\n   * @param _sender Address of sender as bytes32\\n   * @param _nonce Destination-specific nonce\\n   * @param _destinationDomain Domain of destination chain\\n   * @param _recipient Address of recipient on destination chain as bytes32\\n   * @param _messageBody Raw bytes of message body\\n   * @return Formatted message\\n   **/\\n  function formatMessage(\\n    uint32 _originDomain,\\n    bytes32 _sender,\\n    uint32 _nonce,\\n    uint32 _destinationDomain,\\n    bytes32 _recipient,\\n    bytes memory _messageBody\\n  ) internal pure returns (bytes memory) {\\n    return abi.encodePacked(_originDomain, _sender, _nonce, _destinationDomain, _recipient, _messageBody);\\n  }\\n\\n  /**\\n   * @notice Returns leaf of formatted message with provided fields.\\n   * @param _origin Domain of home chain\\n   * @param _sender Address of sender as bytes32\\n   * @param _nonce Destination-specific nonce number\\n   * @param _destination Domain of destination chain\\n   * @param _recipient Address of recipient on destination chain as bytes32\\n   * @param _body Raw bytes of message body\\n   * @return Leaf (hash) of formatted message\\n   **/\\n  function messageHash(\\n    uint32 _origin,\\n    bytes32 _sender,\\n    uint32 _nonce,\\n    uint32 _destination,\\n    bytes32 _recipient,\\n    bytes memory _body\\n  ) internal pure returns (bytes32) {\\n    return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _body));\\n  }\\n\\n  /// @notice Returns message's origin field\\n  function origin(bytes29 _message) internal pure returns (uint32) {\\n    return uint32(_message.indexUint(0, 4));\\n  }\\n\\n  /// @notice Returns message's sender field\\n  function sender(bytes29 _message) internal pure returns (bytes32) {\\n    return _message.index(4, 32);\\n  }\\n\\n  /// @notice Returns message's nonce field\\n  function nonce(bytes29 _message) internal pure returns (uint32) {\\n    return uint32(_message.indexUint(36, 4));\\n  }\\n\\n  /// @notice Returns message's destination field\\n  function destination(bytes29 _message) internal pure returns (uint32) {\\n    return uint32(_message.indexUint(40, 4));\\n  }\\n\\n  /// @notice Returns message's recipient field as bytes32\\n  function recipient(bytes29 _message) internal pure returns (bytes32) {\\n    return _message.index(44, 32);\\n  }\\n\\n  /// @notice Returns message's recipient field as an address\\n  function recipientAddress(bytes29 _message) internal pure returns (address) {\\n    return TypeCasts.bytes32ToAddress(recipient(_message));\\n  }\\n\\n  /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\\n  function body(bytes29 _message) internal pure returns (bytes29) {\\n    return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\\n  }\\n\\n  function leaf(bytes29 _message) internal view returns (bytes32) {\\n    return\\n      messageHash(\\n        origin(_message),\\n        sender(_message),\\n        nonce(_message),\\n        destination(_message),\\n        recipient(_message),\\n        TypedMemView.clone(body(_message))\\n      );\\n  }\\n}\\n\",\"keccak256\":\"0xa14f2f26f943a08b8666c2077ae7a04a7a26a27f1eb4badec42fb3a373c6a489\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/Queue.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\n/**\\n * @title QueueLib\\n * @notice Library containing queue struct and operations for queue used by RootManager and SpokeConnector\\n * for handling the verification period. Tracks both message data itself and the block that the message was\\n * committed to the queue.\\n **/\\nlibrary QueueLib {\\n  /**\\n   * @notice Queue struct\\n   * @dev Internally keeps track of the `first` and `last` elements through\\n   * indices and a mapping of indices to enqueued elements.\\n   **/\\n  struct Queue {\\n    uint128 first;\\n    uint128 last;\\n    // Message data (roots) that have been received.\\n    mapping(uint256 => bytes32) data;\\n    // The block that the message data was committed.\\n    mapping(uint256 => uint256) commitBlock;\\n  }\\n\\n  /**\\n   * @notice Initializes the queue\\n   * @dev Empty state denoted by queue.first > queue.last. Queue initialized with\\n   * queue.first = 1 and queue.last = 0.\\n   **/\\n  function initialize(Queue storage queue) internal {\\n    queue.first = 1;\\n    queue.last = 0;\\n  }\\n\\n  /**\\n   * @notice Enqueues a single new element and records block number that the item was enqueued\\n   * (i.e. current block).\\n   * @param item New element to be enqueued.\\n   * @return last Index of newly enqueued element.\\n   **/\\n  function enqueue(Queue storage queue, bytes32 item) internal returns (uint128 last) {\\n    // Commit block is the block we are committing this item to the queue.\\n    uint256 commitBlock = block.number;\\n    // Increment `last` position.\\n    last = ++queue.last;\\n    // Add the item and record block number.\\n    queue.data[last] = item;\\n    queue.commitBlock[last] = commitBlock;\\n  }\\n\\n  /**\\n   * @notice Dequeues element at front of queue if it exists AND it's surpassed the given\\n   * verification period (i.e. has been sitting in the queue for enough blocks).\\n   * @param queue QueueStorage struct from contract.\\n   * @param delay The required delay that must have been surpassed in order to merit dequeuing\\n   * the element.\\n   * @return item Dequeued element IFF delay period has been surpassed; otherwise, empty bytes32.\\n   **/\\n  function dequeueVerified(Queue storage queue, uint256 delay) internal returns (bytes32[] memory) {\\n    uint128 first = queue.first;\\n    uint128 last = queue.last;\\n    require(last >= first, \\\"queue empty\\\");\\n\\n    // To determine the last item index in the queue we want to return, iterate backwards until we\\n    // find a `commitBlock` that has surpassed the delay period.\\n    // NOTE: We iterate backwards as an optimization; as soon as we find an item whose verified,\\n    // we know that all items before it in the queue are already verified.\\n    // TODO: The most efficient way to determine the split index here should be using a binary search!\\n    bool containsVerified;\\n    for (last; last >= first; ) {\\n      uint256 commitBlock = queue.commitBlock[last];\\n      if (block.number - commitBlock >= delay) {\\n        containsVerified = true;\\n        break;\\n      }\\n      unchecked {\\n        --last;\\n      }\\n    }\\n    // IFF no verified items were found (i.e. first == last and first item is NOT yet verified), then\\n    // we can return an empty array.\\n    if (!containsVerified) {\\n      return new bytes32[](0);\\n    }\\n\\n    bytes32[] memory items = new bytes32[](last + 1 - first);\\n    uint256 index; // Cursor for index in the batch of `items`.\\n    for (first; first <= last; ) {\\n      items[index] = queue.data[first];\\n      // Delete the item and the commitBlock.\\n      delete queue.data[first];\\n      delete queue.commitBlock[first];\\n\\n      unchecked {\\n        ++index;\\n        ++first;\\n      }\\n    }\\n    // Update the value for `first` in our queue object since we've dequeued a number of elements.\\n    queue.first = first;\\n    return items;\\n  }\\n\\n  /**\\n   * @notice Check whether the queue is empty.\\n   * @param queue QueueStorage struct from contract.\\n   * @return bool True if queue is empty and false if otherwise.\\n   */\\n  function isEmpty(Queue storage queue) internal view returns (bool) {\\n    return queue.last < queue.first;\\n  }\\n\\n  /**\\n   * @notice Returns number of elements in queue.\\n   * @param queue QueueStorage struct from contract.\\n   */\\n  function length(Queue storage queue) internal view returns (uint256) {\\n    uint128 last = queue.last;\\n    uint128 first = queue.first;\\n    // Cannot underflow unless state is corrupted.\\n    return _length(last, first);\\n  }\\n\\n  /**\\n   * @notice Returns number of elements between `last` and `first` (used internally).\\n   * @param last The last element index.\\n   * @param first The first element index.\\n   */\\n  function _length(uint128 last, uint128 first) internal pure returns (uint256) {\\n    return uint256(last + 1 - first);\\n  }\\n}\\n\",\"keccak256\":\"0x486952a436924cb3117a6dda96483df0fb1943bf619527fea91a6503a53f3c12\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/shared/ProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport {IProposedOwnable} from \\\"./interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @title ProposedOwnable\\n * @notice Contract module which provides a basic access control mechanism,\\n * where there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed via a two step process:\\n * 1. Call `proposeOwner`\\n * 2. Wait out the delay period\\n * 3. Call `acceptOwner`\\n *\\n * @dev This module is used through inheritance. It will make available the\\n * modifier `onlyOwner`, which can be applied to your functions to restrict\\n * their use to the owner.\\n *\\n * @dev The majority of this code was taken from the openzeppelin Ownable\\n * contract\\n *\\n */\\nabstract contract ProposedOwnable is IProposedOwnable {\\n  // ========== Custom Errors ===========\\n\\n  error ProposedOwnable__onlyOwner_notOwner();\\n  error ProposedOwnable__onlyProposed_notProposedOwner();\\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n  error ProposedOwnable__renounceOwnership_noProposal();\\n  error ProposedOwnable__renounceOwnership_delayNotElapsed();\\n  error ProposedOwnable__renounceOwnership_invalidProposal();\\n  error ProposedOwnable__acceptProposedOwner_delayNotElapsed();\\n\\n  // ============ Properties ============\\n\\n  address private _owner;\\n\\n  address private _proposed;\\n  uint256 private _proposedOwnershipTimestamp;\\n\\n  uint256 private constant _delay = 7 days;\\n\\n  // ======== Getters =========\\n\\n  /**\\n   * @notice Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposed() public view virtual returns (address) {\\n    return _proposed;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposedTimestamp() public view virtual returns (uint256) {\\n    return _proposedOwnershipTimestamp;\\n  }\\n\\n  /**\\n   * @notice Returns the delay period before a new owner can be accepted.\\n   */\\n  function delay() public view virtual returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the proposed owner.\\n   */\\n  modifier onlyProposed() {\\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Indicates if the ownership has been renounced() by\\n   * checking if current owner is address(0)\\n   */\\n  function renounced() public view returns (bool) {\\n    return _owner == address(0);\\n  }\\n\\n  // ======== External =========\\n\\n  /**\\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\\n   * newly proposed owner as step 1 in a 2-step process\\n   */\\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\\n    // Contract as source of truth\\n    if (_proposed == newlyProposed && newlyProposed != address(0))\\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\\n\\n    // Sanity check: reasonable proposal\\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n\\n    _setProposed(newlyProposed);\\n  }\\n\\n  /**\\n   * @notice Renounces ownership of the contract after a delay\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    // Ensure there has been a proposal cycle started\\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\\n\\n    // Ensure delay has elapsed\\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\\n      revert ProposedOwnable__renounceOwnership_delayNotElapsed();\\n\\n    // Require proposed is set to 0\\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(_proposed);\\n  }\\n\\n  /**\\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function acceptProposedOwner() public virtual onlyProposed {\\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\\n    // is 0-d out and this check is implicitly enforced by modifier\\n\\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\\n    // the only time this would happen is if the _proposed was never\\n    // set (will fail from modifier) or if the owner == _proposed (checked\\n    // above)\\n\\n    // Ensure delay has elapsed\\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\\n      revert ProposedOwnable__acceptProposedOwner_delayNotElapsed();\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(_proposed);\\n  }\\n\\n  // ======== Internal =========\\n\\n  function _setOwner(address newOwner) internal {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    _proposedOwnershipTimestamp = 0;\\n    _proposed = address(0);\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n\\n  function _setProposed(address newlyProposed) private {\\n    _proposedOwnershipTimestamp = block.timestamp;\\n    _proposed = newlyProposed;\\n    emit OwnershipProposed(newlyProposed);\\n  }\\n}\\n\\nabstract contract ProposedOwnableUpgradeable is Initializable, ProposedOwnable {\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial\\n   */\\n  function __ProposedOwnable_init() internal onlyInitializing {\\n    __ProposedOwnable_init_unchained();\\n  }\\n\\n  function __ProposedOwnable_init_unchained() internal onlyInitializing {\\n    _setOwner(msg.sender);\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[49] private __GAP;\\n}\\n\",\"keccak256\":\"0xf4c67a5db702cb9775ad3a0ed49bbe137e5a55b4000c507dd6fef3397f3607e3\",\"license\":\"UNLICENSED\"},\"contracts/shared/interfaces/IProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/**\\n * @title IProposedOwnable\\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\\n * process\\n */\\ninterface IProposedOwnable {\\n  /**\\n   * @dev This emits when change in ownership of a contract is proposed.\\n   */\\n  event OwnershipProposed(address indexed proposedOwner);\\n\\n  /**\\n   * @dev This emits when ownership of a contract changes.\\n   */\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @notice Get the address of the owner\\n   * @return owner_ The address of the owner.\\n   */\\n  function owner() external view returns (address owner_);\\n\\n  /**\\n   * @notice Get the address of the proposed owner\\n   * @return proposed_ The address of the proposed.\\n   */\\n  function proposed() external view returns (address proposed_);\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   * @param newlyProposed The proposed new owner of the contract\\n   */\\n  function proposeNewOwner(address newlyProposed) external;\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   */\\n  function acceptProposedOwner() external;\\n}\\n\",\"keccak256\":\"0xfb763d8c311e5972fd6e7d7334ce10cc3f5dbe8a922308b3c160bfb722109f63\",\"license\":\"MIT\"},\"contracts/shared/libraries/TypeCasts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport \\\"./TypedMemView.sol\\\";\\n\\nlibrary TypeCasts {\\n  using TypedMemView for bytes;\\n  using TypedMemView for bytes29;\\n\\n  function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\\n    _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\\n  }\\n\\n  // treat it as a null-terminated string of max 32 bytes\\n  function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\\n    uint8 _slen = 0;\\n    while (_slen < 32 && _buf[_slen] != 0) {\\n      _slen++;\\n    }\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      _newStr := mload(0x40)\\n      mstore(0x40, add(_newStr, 0x40)) // may end up with extra\\n      mstore(_newStr, _slen)\\n      mstore(add(_newStr, 0x20), _buf)\\n    }\\n  }\\n\\n  // alignment preserving cast\\n  function addressToBytes32(address _addr) internal pure returns (bytes32) {\\n    return bytes32(uint256(uint160(_addr)));\\n  }\\n\\n  // alignment preserving cast\\n  function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\\n    return address(uint160(uint256(_buf)));\\n  }\\n}\\n\",\"keccak256\":\"0x818736bf6004223f78f8949c534c74f144b741f5b1ece635670f0fd9b2217344\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/shared/libraries/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nlibrary TypedMemView {\\n  // Why does this exist?\\n  // the solidity `bytes memory` type has a few weaknesses.\\n  // 1. You can't index ranges effectively\\n  // 2. You can't slice without copying\\n  // 3. The underlying data may represent any type\\n  // 4. Solidity never deallocates memory, and memory costs grow\\n  //    superlinearly\\n\\n  // By using a memory view instead of a `bytes memory` we get the following\\n  // advantages:\\n  // 1. Slices are done on the stack, by manipulating the pointer\\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\\n  // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\\n  // algorithms.\\n\\n  // Why bytes29?\\n  // We want to avoid confusion between views, digests, and other common\\n  // types so we chose a large and uncommonly used odd number of bytes\\n  //\\n  // Note that while bytes are left-aligned in a word, integers and addresses\\n  // are right-aligned. This means when working in assembly we have to\\n  // account for the 3 unused bytes on the righthand side\\n  //\\n  // First 5 bytes are a type flag.\\n  // - ff_ffff_fffe is reserved for unknown type.\\n  // - ff_ffff_ffff is reserved for invalid types/errors.\\n  // next 12 are memory address\\n  // next 12 are len\\n  // bottom 3 bytes are empty\\n\\n  // Assumptions:\\n  // - non-modification of memory.\\n  // - No Solidity updates\\n  // - - wrt free mem point\\n  // - - wrt bytes representation in memory\\n  // - - wrt memory addressing in general\\n\\n  // Usage:\\n  // - create type constants\\n  // - use `assertType` for runtime type assertions\\n  // - - unfortunately we can't do this at compile time yet :(\\n  // - recommended: implement modifiers that perform type checking\\n  // - - e.g.\\n  // - - `uint40 constant MY_TYPE = 3;`\\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n  // - instantiate a typed view from a bytearray using `ref`\\n  // - use `index` to inspect the contents of the view\\n  // - use `slice` to create smaller views into the same memory\\n  // - - `slice` can increase the offset\\n  // - - `slice can decrease the length`\\n  // - - must specify the output type of `slice`\\n  // - - `slice` will return a null view if you try to overrun\\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\\n  // - use `equal` for typed comparisons.\\n\\n  // The null view\\n  bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n  uint8 constant TWELVE_BYTES = 96;\\n\\n  /**\\n   * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n   * @param _b    The byte\\n   * @return      char - The encoded hex character\\n   */\\n  function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\n    // This can probably be done more efficiently, but it's only in error\\n    // paths, so we don't really care :)\\n    uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n    if (_nibble == 0xf0) {\\n      return 0x30;\\n    } // 0\\n    if (_nibble == 0xf1) {\\n      return 0x31;\\n    } // 1\\n    if (_nibble == 0xf2) {\\n      return 0x32;\\n    } // 2\\n    if (_nibble == 0xf3) {\\n      return 0x33;\\n    } // 3\\n    if (_nibble == 0xf4) {\\n      return 0x34;\\n    } // 4\\n    if (_nibble == 0xf5) {\\n      return 0x35;\\n    } // 5\\n    if (_nibble == 0xf6) {\\n      return 0x36;\\n    } // 6\\n    if (_nibble == 0xf7) {\\n      return 0x37;\\n    } // 7\\n    if (_nibble == 0xf8) {\\n      return 0x38;\\n    } // 8\\n    if (_nibble == 0xf9) {\\n      return 0x39;\\n    } // 9\\n    if (_nibble == 0xfa) {\\n      return 0x61;\\n    } // a\\n    if (_nibble == 0xfb) {\\n      return 0x62;\\n    } // b\\n    if (_nibble == 0xfc) {\\n      return 0x63;\\n    } // c\\n    if (_nibble == 0xfd) {\\n      return 0x64;\\n    } // d\\n    if (_nibble == 0xfe) {\\n      return 0x65;\\n    } // e\\n    if (_nibble == 0xff) {\\n      return 0x66;\\n    } // f\\n  }\\n\\n  /**\\n   * @notice      Returns a uint16 containing the hex-encoded byte.\\n   * @param _b    The byte\\n   * @return      encoded - The hex-encoded byte\\n   */\\n  function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n    encoded |= nibbleHex(_b >> 4); // top 4 bits\\n    encoded <<= 8;\\n    encoded |= nibbleHex(_b); // lower 4 bits\\n  }\\n\\n  /**\\n   * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n   *              `second` contains the encoded lower 16 bytes.\\n   *\\n   * @param _b    The 32 bytes as uint256\\n   * @return      first - The top 16 bytes\\n   * @return      second - The bottom 16 bytes\\n   */\\n  function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n    for (uint8 i = 31; i > 15; ) {\\n      uint8 _byte = uint8(_b >> (i * 8));\\n      first |= byteHex(_byte);\\n      if (i != 16) {\\n        first <<= 16;\\n      }\\n      unchecked {\\n        i -= 1;\\n      }\\n    }\\n\\n    // abusing underflow here =_=\\n    for (uint8 i = 15; i < 255; ) {\\n      uint8 _byte = uint8(_b >> (i * 8));\\n      second |= byteHex(_byte);\\n      if (i != 0) {\\n        second <<= 16;\\n      }\\n      unchecked {\\n        i -= 1;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice          Changes the endianness of a uint256.\\n   * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n   * @param _b        The unsigned integer to reverse\\n   * @return          v - The reversed value\\n   */\\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n    v = _b;\\n\\n    // swap bytes\\n    v =\\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n    // swap 2-byte long pairs\\n    v =\\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n    // swap 4-byte long pairs\\n    v =\\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n    // swap 8-byte long pairs\\n    v =\\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n    // swap 16-byte long pairs\\n    v = (v >> 128) | (v << 128);\\n  }\\n\\n  /**\\n   * @notice      Create a mask with the highest `_len` bits set.\\n   * @param _len  The length\\n   * @return      mask - The mask\\n   */\\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n    // ugly. redo without assembly?\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\\n    }\\n  }\\n\\n  /**\\n   * @notice      Return the null view.\\n   * @return      bytes29 - The null view\\n   */\\n  function nullView() internal pure returns (bytes29) {\\n    return NULL;\\n  }\\n\\n  /**\\n   * @notice      Check if the view is null.\\n   * @return      bool - True if the view is null\\n   */\\n  function isNull(bytes29 memView) internal pure returns (bool) {\\n    return memView == NULL;\\n  }\\n\\n  /**\\n   * @notice      Check if the view is not null.\\n   * @return      bool - True if the view is not null\\n   */\\n  function notNull(bytes29 memView) internal pure returns (bool) {\\n    return !isNull(memView);\\n  }\\n\\n  /**\\n   * @notice          Check if the view is of a valid type and points to a valid location\\n   *                  in memory.\\n   * @dev             We perform this check by examining solidity's unallocated memory\\n   *                  pointer and ensuring that the view's upper bound is less than that.\\n   * @param memView   The view\\n   * @return          ret - True if the view is valid\\n   */\\n  function isValid(bytes29 memView) internal pure returns (bool ret) {\\n    if (typeOf(memView) == 0xffffffffff) {\\n      return false;\\n    }\\n    uint256 _end = end(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ret := not(gt(_end, mload(0x40)))\\n    }\\n  }\\n\\n  /**\\n   * @notice          Require that a typed memory view be valid.\\n   * @dev             Returns the view for easy chaining.\\n   * @param memView   The view\\n   * @return          bytes29 - The validated view\\n   */\\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n    require(isValid(memView), \\\"Validity assertion failed\\\");\\n    return memView;\\n  }\\n\\n  /**\\n   * @notice          Return true if the memview is of the expected type. Otherwise false.\\n   * @param memView   The view\\n   * @param _expected The expected type\\n   * @return          bool - True if the memview is of the expected type\\n   */\\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n    return typeOf(memView) == _expected;\\n  }\\n\\n  /**\\n   * @notice          Require that a typed memory view has a specific type.\\n   * @dev             Returns the view for easy chaining.\\n   * @param memView   The view\\n   * @param _expected The expected type\\n   * @return          bytes29 - The view with validated type\\n   */\\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n    if (!isType(memView, _expected)) {\\n      (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n      (, uint256 e) = encodeHex(uint256(_expected));\\n      string memory err = string(\\n        abi.encodePacked(\\\"Type assertion failed. Got 0x\\\", uint80(g), \\\". Expected 0x\\\", uint80(e))\\n      );\\n      revert(err);\\n    }\\n    return memView;\\n  }\\n\\n  /**\\n   * @notice          Return an identical view with a different type.\\n   * @param memView   The view\\n   * @param _newType  The new type\\n   * @return          newView - The new view with the specified type\\n   */\\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n    // then | in the new type\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // shift off the top 5 bytes\\n      newView := or(newView, shr(40, shl(40, memView)))\\n      newView := or(newView, shl(216, _newType))\\n    }\\n  }\\n\\n  /**\\n   * @notice          Unsafe raw pointer construction. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @dev             Unsafe raw pointer construction. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @param _type     The type\\n   * @param _loc      The memory address\\n   * @param _len      The length\\n   * @return          newView - The new view with the specified type, location and length\\n   */\\n  function unsafeBuildUnchecked(\\n    uint256 _type,\\n    uint256 _loc,\\n    uint256 _len\\n  ) private pure returns (bytes29 newView) {\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      newView := shl(96, or(newView, _type)) // insert type\\n      newView := shl(96, or(newView, _loc)) // insert loc\\n      newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\\n    }\\n  }\\n\\n  /**\\n   * @notice          Instantiate a new memory view. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @dev             Instantiate a new memory view. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @param _type     The type\\n   * @param _loc      The memory address\\n   * @param _len      The length\\n   * @return          newView - The new view with the specified type, location and length\\n   */\\n  function build(\\n    uint256 _type,\\n    uint256 _loc,\\n    uint256 _len\\n  ) internal pure returns (bytes29 newView) {\\n    uint256 _end = _loc + _len;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      if gt(_end, mload(0x40)) {\\n        _end := 0\\n      }\\n    }\\n    if (_end == 0) {\\n      return NULL;\\n    }\\n    newView = unsafeBuildUnchecked(_type, _loc, _len);\\n  }\\n\\n  /**\\n   * @notice          Instantiate a memory view from a byte array.\\n   * @dev             Note that due to Solidity memory representation, it is not possible to\\n   *                  implement a deref, as the `bytes` type stores its len in memory.\\n   * @param arr       The byte array\\n   * @param newType   The type\\n   * @return          bytes29 - The memory view\\n   */\\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n    uint256 _len = arr.length;\\n\\n    uint256 _loc;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\\n    }\\n\\n    return build(newType, _loc, _len);\\n  }\\n\\n  /**\\n   * @notice          Return the associated type information.\\n   * @param memView   The memory view\\n   * @return          _type - The type associated with the view\\n   */\\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // 216 == 256 - 40\\n      _type := shr(216, memView) // shift out lower 24 bytes\\n    }\\n  }\\n\\n  /**\\n   * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the 5-byte type flag is equal\\n   */\\n  function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n  }\\n\\n  /**\\n   * @notice          Return the memory address of the underlying bytes.\\n   * @param memView   The view\\n   * @return          _loc - The memory address\\n   */\\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n      _loc := and(shr(120, memView), _mask)\\n    }\\n  }\\n\\n  /**\\n   * @notice          The number of memory words this memory view occupies, rounded up.\\n   * @param memView   The view\\n   * @return          uint256 - The number of memory words\\n   */\\n  function words(bytes29 memView) internal pure returns (uint256) {\\n    return (uint256(len(memView)) + 31) / 32;\\n  }\\n\\n  /**\\n   * @notice          The in-memory footprint of a fresh copy of the view.\\n   * @param memView   The view\\n   * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n   */\\n  function footprint(bytes29 memView) internal pure returns (uint256) {\\n    return words(memView) * 32;\\n  }\\n\\n  /**\\n   * @notice          The number of bytes of the view.\\n   * @param memView   The view\\n   * @return          _len - The length of the view\\n   */\\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      _len := and(shr(24, memView), _mask)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Returns the endpoint of `memView`.\\n   * @param memView   The view\\n   * @return          uint256 - The endpoint of `memView`\\n   */\\n  function end(bytes29 memView) internal pure returns (uint256) {\\n    unchecked {\\n      return loc(memView) + len(memView);\\n    }\\n  }\\n\\n  /**\\n   * @notice          Safe slicing without memory modification.\\n   * @param memView   The view\\n   * @param _index    The start index\\n   * @param _len      The length\\n   * @param newType   The new type\\n   * @return          bytes29 - The new view\\n   */\\n  function slice(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    uint256 _loc = loc(memView);\\n\\n    // Ensure it doesn't overrun the view\\n    if (_loc + _index + _len > end(memView)) {\\n      return NULL;\\n    }\\n\\n    _loc = _loc + _index;\\n    return build(newType, _loc, _len);\\n  }\\n\\n  /**\\n   * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n   * @param memView   The view\\n   * @param _len      The length\\n   * @param newType   The new type\\n   * @return          bytes29 - The new view\\n   */\\n  function prefix(\\n    bytes29 memView,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    return slice(memView, 0, _len, newType);\\n  }\\n\\n  /**\\n   * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\n   * @param memView   The view\\n   * @param _len      The length\\n   * @param newType   The new type\\n   * @return          bytes29 - The new view\\n   */\\n  function postfix(\\n    bytes29 memView,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    return slice(memView, uint256(len(memView)) - _len, _len, newType);\\n  }\\n\\n  /**\\n   * @notice          Construct an error message for an indexing overrun.\\n   * @param _loc      The memory address\\n   * @param _len      The length\\n   * @param _index    The index\\n   * @param _slice    The slice where the overrun occurred\\n   * @return          err - The err\\n   */\\n  function indexErrOverrun(\\n    uint256 _loc,\\n    uint256 _len,\\n    uint256 _index,\\n    uint256 _slice\\n  ) internal pure returns (string memory err) {\\n    (, uint256 a) = encodeHex(_loc);\\n    (, uint256 b) = encodeHex(_len);\\n    (, uint256 c) = encodeHex(_index);\\n    (, uint256 d) = encodeHex(_slice);\\n    err = string(\\n      abi.encodePacked(\\n        \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n        uint48(a),\\n        \\\" with length 0x\\\",\\n        uint48(b),\\n        \\\". Attempted to index at offset 0x\\\",\\n        uint48(c),\\n        \\\" with length 0x\\\",\\n        uint48(d),\\n        \\\".\\\"\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @notice          Load up to 32 bytes from the view onto the stack.\\n   * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n   *                  This can be immediately cast to a smaller fixed-length byte array.\\n   *                  To automatically cast to an integer, use `indexUint`.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @param _bytes    The bytes\\n   * @return          result - The 32 byte result\\n   */\\n  function index(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (bytes32 result) {\\n    if (_bytes == 0) {\\n      return bytes32(0);\\n    }\\n    if (_index + _bytes > len(memView)) {\\n      revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n    }\\n    require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n    uint8 bitLength;\\n    unchecked {\\n      bitLength = _bytes * 8;\\n    }\\n    uint256 _loc = loc(memView);\\n    uint256 _mask = leftMask(bitLength);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      result := and(mload(add(_loc, _index)), _mask)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Parse an unsigned integer from the view at `_index`.\\n   * @dev             Requires that the view have >= `_bytes` bytes following that index.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @param _bytes    The bytes\\n   * @return          result - The unsigned integer\\n   */\\n  function indexUint(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (uint256 result) {\\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n  }\\n\\n  /**\\n   * @notice          Parse an unsigned integer from LE bytes.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @param _bytes    The bytes\\n   * @return          result - The unsigned integer\\n   */\\n  function indexLEUint(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (uint256 result) {\\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\\n  }\\n\\n  /**\\n   * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n   *                  following that index.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @return          address - The address\\n   */\\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n    return address(uint160(indexUint(memView, _index, 20)));\\n  }\\n\\n  /**\\n   * @notice          Return the keccak256 hash of the underlying memory\\n   * @param memView   The view\\n   * @return          digest - The keccak256 hash of the underlying memory\\n   */\\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      digest := keccak256(_loc, _len)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Return the sha2 digest of the underlying memory.\\n   * @dev             We explicitly deallocate memory afterwards.\\n   * @param memView   The view\\n   * @return          digest - The sha2 hash of the underlying memory\\n   */\\n  function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n      digest := mload(ptr)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n   * @param memView   The pre-image\\n   * @return          digest - the Digest\\n   */\\n  function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n      pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n      digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n    }\\n  }\\n\\n  /**\\n   * @notice          Implements bitcoin's hash256 (double sha2)\\n   * @param memView   A view of the preimage\\n   * @return          digest - the Digest\\n   */\\n  function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n      pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n      digest := mload(ptr)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Return true if the underlying memory is equal. Else false.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the underlying memory is equal\\n   */\\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n  }\\n\\n  /**\\n   * @notice          Return false if the underlying memory is equal. Else true.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - False if the underlying memory is equal\\n   */\\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return !untypedEqual(left, right);\\n  }\\n\\n  /**\\n   * @notice          Compares type equality.\\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the types are the same\\n   */\\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n  }\\n\\n  /**\\n   * @notice          Compares type inequality.\\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the types are not the same\\n   */\\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return !equal(left, right);\\n  }\\n\\n  /**\\n   * @notice          Copy the view to a location, return an unsafe memory reference\\n   * @dev             Super Dangerous direct memory access.\\n   *\\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\\n   *                  As such it MUST be consumed IMMEDIATELY.\\n   *                  This function is private to prevent unsafe usage by callers.\\n   * @param memView   The view\\n   * @param _newLoc   The new location\\n   * @return          written - the unsafe memory reference\\n   */\\n  function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n    require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n    require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n    uint256 _len = len(memView);\\n    uint256 _oldLoc = loc(memView);\\n\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40)\\n      // revert if we're writing in occupied memory\\n      if gt(ptr, _newLoc) {\\n        revert(0x60, 0x20) // empty revert message\\n      }\\n\\n      // use the identity precompile to copy\\n      // guaranteed not to fail, so pop the success\\n      pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n    }\\n\\n    written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n  }\\n\\n  /**\\n   * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n   *                  the new memory\\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n   * @param memView   The view\\n   * @return          ret - The view pointing to the new memory\\n   */\\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n    uint256 ptr;\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n      ret := ptr\\n    }\\n    unchecked {\\n      unsafeCopyTo(memView, ptr + 0x20);\\n    }\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n      mstore(ptr, _len) // write len of new array (in bytes)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Join the views in memory, return an unsafe reference to the memory.\\n   * @dev             Super Dangerous direct memory access.\\n   *\\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\\n   *                  As such it MUST be consumed IMMEDIATELY.\\n   *                  This function is private to prevent unsafe usage by callers.\\n   * @param memViews  The views\\n   * @return          unsafeView - The conjoined view pointing to the new memory\\n   */\\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      // revert if we're writing in occupied memory\\n      if gt(ptr, _location) {\\n        revert(0x60, 0x20) // empty revert message\\n      }\\n    }\\n\\n    uint256 _offset = 0;\\n    for (uint256 i = 0; i < memViews.length; i++) {\\n      bytes29 memView = memViews[i];\\n      unchecked {\\n        unsafeCopyTo(memView, _location + _offset);\\n        _offset += len(memView);\\n      }\\n    }\\n    unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n  }\\n\\n  /**\\n   * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n   * @param memViews  The views\\n   * @return          bytes32 - The keccak256 digest\\n   */\\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n    return keccak(unsafeJoin(memViews, ptr));\\n  }\\n\\n  /**\\n   * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n   * @param memViews  The views\\n   * @return          bytes32 - The sha256 digest\\n   */\\n  function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n    return sha2(unsafeJoin(memViews, ptr));\\n  }\\n\\n  /**\\n   * @notice          copies all views, joins them into a new bytearray.\\n   * @param memViews  The views\\n   * @return          ret - The new byte array\\n   */\\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n\\n    bytes29 _newView;\\n    unchecked {\\n      _newView = unsafeJoin(memViews, ptr + 0x20);\\n    }\\n    uint256 _written = len(_newView);\\n    uint256 _footprint = footprint(_newView);\\n\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // store the legnth\\n      mstore(ptr, _written)\\n      // new pointer is old + 0x20 + the footprint of the body\\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\\n      ret := ptr\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xe3b9e398dff8870d5a597de93a9cb0aa139f27ed27c12bbe78c8ff60d85b0aaf\",\"license\":\"MIT OR Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b506040516200210f3803806200210f83398101604081905262000034916200015d565b600380546001600160a81b0319166101006001600160a01b038416021790556200005e33620000db565b6001600160a01b038216620000a85760405162461bcd60e51b815260206004820152600c60248201526b217a65726f206d65726b6c6560a01b604482015260640160405180910390fd5b6001600160a01b0382166080526009839055620000d2600a6200013a602090811b62000eba17901c565b5050506200019e565b600080546001600160a01b038381166001600160a01b0319808416821785556002859055600180549091169055604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60019055565b80516001600160a01b03811681146200015857600080fd5b919050565b6000806000606084860312156200017357600080fd5b83519250620001856020850162000140565b9150620001956040850162000140565b90509250925092565b608051611f4e620001c16000396000818161037501526106610152611f4e6000f3fe608060405234801561001057600080fd5b50600436106101cf5760003560e01c80637d53430811610104578063b1f8100d116100a2578063d232c22011610071578063d232c220146103df578063d2a3cc71146103f1578063db0f016914610404578063e6f1208d1461041757600080fd5b8063b1f8100d146103a0578063b904670f146103b3578063c5b350df146103c6578063d1851c92146103ce57600080fd5b80638e7d93fa116100de5780638e7d93fa14610355578063909907cb14610368578063a01892a514610370578063ad9c0c2e1461039757600080fd5b80637d534308146102fe5780638456cb591461033c5780638da5cb5b1461034457600080fd5b8063498c2c2e116101715780636a42b8f81161014b5780636a42b8f8146102d1578063715018a6146102da5780637bc24d99146102e25780637d434e91146102eb57600080fd5b8063498c2c2e146102955780635c975abb1461029e57806366cf8fab146102a957600080fd5b80633c4baaf8116101ad5780633c4baaf8146102515780633cf52ffb146102725780633f4ba83a1461027a57806344833ca31461028257600080fd5b806313ede1a1146101d45780631eeaabea1461020457806324ec5d0514610219575b600080fd5b6101e76101e23660046117e8565b61042a565b6040516001600160a01b0390911681526020015b60405180910390f35b6102176102123660046117e8565b610454565b005b61024161022736600461181a565b63ffffffff16600090815260086020526040902054151590565b60405190151581526020016101fb565b61026461025f36600461181a565b610506565b6040519081526020016101fb565b600254610264565b61021761056a565b610217610290366004611881565b6105a7565b61026460075481565b60035460ff16610241565b6102bc6102b73660046117e8565b610802565b60405163ffffffff90911681526020016101fb565b62093a80610264565b61021761083c565b61026460055481565b6101e76102f936600461181a565b6108f9565b600a5461031c906001600160801b0380821691600160801b90041682565b604080516001600160801b039384168152929091166020830152016101fb565b610217610931565b6000546001600160a01b03166101e7565b6102176103633660046118ed565b6109e8565b610264610aa3565b6101e77f000000000000000000000000000000000000000000000000000000000000000081565b61026460095481565b6102176103ae36600461192e565b610ab4565b6102176103c1366004611949565b610b5c565b610217610bd4565b6001546001600160a01b03166101e7565b6000546001600160a01b031615610241565b6102176103ff36600461192e565b610c2f565b610217610412366004611881565b610cfc565b61021761042536600461181a565b610dcd565b6006818154811061043a57600080fd5b6000918252602090912001546001600160a01b0316905081565b6000546001600160a01b0316331461047f576040516311a8a1bb60e31b815260040160405180910390fd5b60095481036104c45760405162461bcd60e51b815260206004820152600c60248201526b2164656c6179426c6f636b7360a01b60448201526064015b60405180910390fd5b6009546040805183815260208101929092527fef322fd61cb3d8514326f0b28140a92a29cd10996ad80d0671e43d2483464c1d910160405180910390a1600955565b63ffffffff81166000908152600860205260408120548082036105585760405162461bcd60e51b815260206004820152600a602482015269085cdd5c1c1bdc9d195960b21b60448201526064016104bb565b610563600182611992565b9392505050565b6000546001600160a01b03163314610595576040516311a8a1bb60e31b815260040160405180910390fd5b61059d610ec0565b6105a5610f09565b565b6105af610f5b565b828181146105f15760405162461bcd60e51b815260206004820152600f60248201526e696e76616c6964206c656e6774687360881b60448201526064016104bb565b6105fd85858585610cfc565b6000610615600954600a610fa190919063ffffffff16565b9050805160000361065c5760405162461bcd60e51b81526020600482015260116024820152706e6f20766572696669656420726f6f747360781b60448201526064016104bb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166334a55ee6846040518263ffffffff1660e01b81526004016106ab91906119e4565b60408051808303816000875af11580156106c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ed91906119f7565b9150915060005b848163ffffffff1610156107b85786868263ffffffff1681811061071a5761071a611a1b565b905060200201602081019061072f919061192e565b6001600160a01b03166382646a588460405160200161075091815260200190565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161077b9190611a31565b600060405180830381600087803b15801561079557600080fd5b505af11580156107a9573d6000803e3d6000fd5b505050508060010190506106f4565b507fb0b3d44baf84014c485fc70c5f229e509a6e6c0f3e5e84916115545b61c820bf82828a8a876040516107f0959493929190611abf565b60405180910390a15050505050505050565b6004818154811061081257600080fd5b9060005260206000209060089182820401919006600402915054906101000a900463ffffffff1681565b6000546001600160a01b03163314610867576040516311a8a1bb60e31b815260040160405180910390fd5b60025460000361088a57604051630e4b303f60e21b815260040160405180910390fd5b62093a806002544261089c9190611992565b116108ba576040516386d4b3f160e01b815260040160405180910390fd5b6001546001600160a01b0316156108e4576040516323295ef960e01b815260040160405180910390fd5b6001546105a5906001600160a01b031661119b565b6000600661090683610506565b8154811061091657610916611a1b565b6000918252602090912001546001600160a01b031692915050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa15801561097d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a19190611afd565b6109d85760405162461bcd60e51b815260206004820152600860248201526710bbb0ba31b432b960c11b60448201526064016104bb565b6109e0610f5b565b6105a56111fa565b6109f0610f5b565b81336109fb826108f9565b6001600160a01b031614610a3e5760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b60448201526064016104bb565b6000610a4b600a84611237565b6040805163ffffffff87168152602081018690526001600160801b0383168183015290519192507ff5832b5d15f2d906d01b871e48b0d1f27d8f282a7e0771c428b55bfeb409fa05919081900360600190a150505050565b6000610aaf600a6112a9565b905090565b6000546001600160a01b03163314610adf576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b038281169116148015610b0457506001600160a01b03811615155b15610b22576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b03808316911603610b5057604051634a2fb73f60e11b815260040160405180910390fd5b610b59816112d3565b50565b6000546001600160a01b03163314610b87576040516311a8a1bb60e31b815260040160405180910390fd5b610b918282611321565b7f95ef69787290b89c35a092c89db1b283b43724d01263e683cfb560c758cdbe70828260046006604051610bc89493929190611ce5565b60405180910390a15050565b6001546001600160a01b03163314610bff576040516311a7f27160e11b815260040160405180910390fd5b62093a8060025442610c119190611992565b116108e45760405163d39c12bb60e01b815260040160405180910390fd5b6000546001600160a01b03163314610c5a576040516311a8a1bb60e31b815260040160405180910390fd5b6003546001600160a01b03610100909104811690821603610cbd5760405162461bcd60e51b815260206004820152601760248201527f616c72656164792077617463686572206d616e6167657200000000000000000060448201526064016104bb565b6040516001600160a01b03821681527fc16d059e43d7f8e29ccb4e001a2f249d3c59e274925d6a6bc3912943441d9f6c9060200160405180910390a150565b6005548484604051602001610d12929190611d32565b6040516020818303038152906040528051906020012014610d605760405162461bcd60e51b815260206004820152600860248201526721646f6d61696e7360c01b60448201526064016104bb565b6007548282604051602001610d76929190611d46565b6040516020818303038152906040528051906020012014610dc75760405162461bcd60e51b815260206004820152600b60248201526a21636f6e6e6563746f727360a81b60448201526064016104bb565b50505050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa158015610e19573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e3d9190611afd565b610e745760405162461bcd60e51b815260206004820152600860248201526710bbb0ba31b432b960c11b60448201526064016104bb565b6000610e7f8261146c565b90507f6a1097f391a37dc63e0860e64ec34442971eeed2fda4d1a90141fa9ce25eb7eb82826004600633604051610bc8959493929190611d92565b60019055565b60035460ff166105a55760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016104bb565b610f11610ec0565b6003805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b60035460ff16156105a55760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016104bb565b81546060906001600160801b0380821691600160801b90041681811015610ff85760405162461bcd60e51b815260206004820152600b60248201526a717565756520656d70747960a81b60448201526064016104bb565b60005b826001600160801b0316826001600160801b031610611056576001600160801b03821660009081526002870160205260409020548561103a8243611992565b10611049576001915050611056565b5060001990910190610ffb565b8061107557505060408051600081526020810190915291506111959050565b600083611083846001611dfe565b61108d9190611e29565b6001600160801b031667ffffffffffffffff8111156110ae576110ae611de8565b6040519080825280602002602001820160405280156110d7578160200160208202803683370190505b50905060005b836001600160801b0316856001600160801b031611611167576001600160801b0385166000908152600189016020526040902054825183908390811061112557611125611a1b565b6020908102919091018101919091526001600160801b03861660009081526001808b018352604080832083905560028c019093529181205594850194016110dd565b5086546fffffffffffffffffffffffffffffffff19166001600160801b039490941693909317865550909150505b92915050565b600080546001600160a01b038381166001600160a01b0319808416821785556002859055600180549091169055604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b611202610f5b565b6003805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258610f3e3390565b81546000904390849060109061125c90600160801b90046001600160801b0316611e51565b82546001600160801b038083166101009490940a84810291021990911617909255600090815260018601602090815260408083209690965560029096019095529290932092909255919050565b80546000906001600160801b03600160801b8204811691166112cb8282611688565b949350505050565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b63ffffffff82166000908152600860205260409020541561136d5760405162461bcd60e51b815260206004820152600660248201526565786973747360d01b60448201526064016104bb565b6001600160a01b0381166113b05760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b60448201526064016104bb565b600480546001818101835560088083047f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01805463ffffffff808916600790961687026101000a8681029102199091161790556006805492830190557ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f90910180546001600160a01b0386166001600160a01b031990911617905591546000918252602092909252604090208190556114676116b0565b505050565b60008061147883610506565b905060006006828154811061148f5761148f611a1b565b6000918252602090912001546001600160a01b03169050806114e75760405162461bcd60e51b8152602060048201526011602482015270636f6e6e6563746f72202165786973747360781b60448201526064016104bb565b6004546000906114f990600190611992565b9050808310156115f0576004818154811061151657611516611a1b565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff166004848154811061154f5761154f611a1b565b90600052602060002090600891828204019190066004026101000a81548163ffffffff021916908363ffffffff1602179055506006818154811061159557611595611a1b565b600091825260209091200154600680546001600160a01b0390921691859081106115c1576115c1611a1b565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055505b600480548061160157611601611e77565b600082815260209020600860001990920191820401805463ffffffff600460078516026101000a02191690559055600680548061164057611640611e77565b60008281526020808220830160001990810180546001600160a01b031916905590920190925563ffffffff871682526008905260408120556116806116b0565b509392505050565b600081611696846001611dfe565b6116a09190611e29565b6001600160801b03169392505050565b6000600480548060200260200160405190810160405280929190818152602001828054801561172a57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116116ed5790505b505050505090506000600680548060200260200160405190810160405280929190818152602001828054801561178957602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161176b575b50505050509050816040516020016117a19190611e8d565b60408051601f198184030181529082905280516020918201206005556117c991839101611ed7565b60408051601f1981840301815291905280516020909101206007555050565b6000602082840312156117fa57600080fd5b5035919050565b803563ffffffff8116811461181557600080fd5b919050565b60006020828403121561182c57600080fd5b61056382611801565b60008083601f84011261184757600080fd5b50813567ffffffffffffffff81111561185f57600080fd5b6020830191508360208260051b850101111561187a57600080fd5b9250929050565b6000806000806040858703121561189757600080fd5b843567ffffffffffffffff808211156118af57600080fd5b6118bb88838901611835565b909650945060208701359150808211156118d457600080fd5b506118e187828801611835565b95989497509550505050565b6000806040838503121561190057600080fd5b61190983611801565b946020939093013593505050565b80356001600160a01b038116811461181557600080fd5b60006020828403121561194057600080fd5b61056382611917565b6000806040838503121561195c57600080fd5b61196583611801565b915061197360208401611917565b90509250929050565b634e487b7160e01b600052601160045260246000fd5b6000828210156119a4576119a461197c565b500390565b600081518084526020808501945080840160005b838110156119d9578151875295820195908201906001016119bd565b509495945050505050565b60208152600061056360208301846119a9565b60008060408385031215611a0a57600080fd5b505080516020909101519092909150565b634e487b7160e01b600052603260045260246000fd5b600060208083528351808285015260005b81811015611a5e57858101830151858201604001528201611a42565b81811115611a70576000604083870101525b50601f01601f1916929092016040019392505050565b8183526000602080850194508260005b858110156119d95763ffffffff611aac83611801565b1687529582019590820190600101611a96565b858152846020820152608060408201526000611adf608083018587611a86565b8281036060840152611af181856119a9565b98975050505050505050565b600060208284031215611b0f57600080fd5b8151801515811461056357600080fd5b805480835260008281526020808220940193909190825b82600782011015611bae57815463ffffffff8082168852602082811c821690890152604082811c821690890152606082811c821690890152608082811c82169089015260a082811c82169089015260c082811c9091169088015260e090811c9087015261010090950194600190910190600801611b36565b90549082811015611bcc5763ffffffff821686526020909501946001015b82811015611bec57602082901c63ffffffff168652602095909501946001015b82811015611c0b5763ffffffff604083901c1686526020909501946001015b82811015611c2a5763ffffffff606083901c1686526020909501946001015b82811015611c495763ffffffff608083901c1686526020909501946001015b82811015611c685763ffffffff60a083901c1686526020909501946001015b82811015611c875763ffffffff60c083901c1686526020909501946001015b82811015611c9d5760e082901c86526020860195505b5093949350505050565b6000815480845260208085019450836000528060002060005b838110156119d95781546001600160a01b031687529582019560019182019101611cc0565b63ffffffff851681526001600160a01b0384166020820152608060408201819052600090611d1590830185611b1f565b8281036060840152611d278185611ca7565b979650505050505050565b6020815260006112cb602083018486611a86565b60208082528181018390526000908460408401835b86811015611d87576001600160a01b03611d7484611917565b1682529183019190830190600101611d5b565b509695505050505050565b63ffffffff86168152600060018060a01b03808716602084015260a06040840152611dc060a0840187611b1f565b8381036060850152611dd28187611ca7565b9250508084166080840152509695505050505050565b634e487b7160e01b600052604160045260246000fd5b60006001600160801b03808316818516808303821115611e2057611e2061197c565b01949350505050565b60006001600160801b0383811690831681811015611e4957611e4961197c565b039392505050565b60006001600160801b03808316818103611e6d57611e6d61197c565b6001019392505050565b634e487b7160e01b600052603160045260246000fd5b6020808252825182820181905260009190848201906040850190845b81811015611ecb57835163ffffffff1683529284019291840191600101611ea9565b50909695505050505050565b6020808252825182820181905260009190848201906040850190845b81811015611ecb5783516001600160a01b031683529284019291840191600101611ef356fea2646970667358221220e9e083edc35970d444f1762ee23db8a611d5a7b9942458b0d278721071feff8064736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101cf5760003560e01c80637d53430811610104578063b1f8100d116100a2578063d232c22011610071578063d232c220146103df578063d2a3cc71146103f1578063db0f016914610404578063e6f1208d1461041757600080fd5b8063b1f8100d146103a0578063b904670f146103b3578063c5b350df146103c6578063d1851c92146103ce57600080fd5b80638e7d93fa116100de5780638e7d93fa14610355578063909907cb14610368578063a01892a514610370578063ad9c0c2e1461039757600080fd5b80637d534308146102fe5780638456cb591461033c5780638da5cb5b1461034457600080fd5b8063498c2c2e116101715780636a42b8f81161014b5780636a42b8f8146102d1578063715018a6146102da5780637bc24d99146102e25780637d434e91146102eb57600080fd5b8063498c2c2e146102955780635c975abb1461029e57806366cf8fab146102a957600080fd5b80633c4baaf8116101ad5780633c4baaf8146102515780633cf52ffb146102725780633f4ba83a1461027a57806344833ca31461028257600080fd5b806313ede1a1146101d45780631eeaabea1461020457806324ec5d0514610219575b600080fd5b6101e76101e23660046117e8565b61042a565b6040516001600160a01b0390911681526020015b60405180910390f35b6102176102123660046117e8565b610454565b005b61024161022736600461181a565b63ffffffff16600090815260086020526040902054151590565b60405190151581526020016101fb565b61026461025f36600461181a565b610506565b6040519081526020016101fb565b600254610264565b61021761056a565b610217610290366004611881565b6105a7565b61026460075481565b60035460ff16610241565b6102bc6102b73660046117e8565b610802565b60405163ffffffff90911681526020016101fb565b62093a80610264565b61021761083c565b61026460055481565b6101e76102f936600461181a565b6108f9565b600a5461031c906001600160801b0380821691600160801b90041682565b604080516001600160801b039384168152929091166020830152016101fb565b610217610931565b6000546001600160a01b03166101e7565b6102176103633660046118ed565b6109e8565b610264610aa3565b6101e77f000000000000000000000000000000000000000000000000000000000000000081565b61026460095481565b6102176103ae36600461192e565b610ab4565b6102176103c1366004611949565b610b5c565b610217610bd4565b6001546001600160a01b03166101e7565b6000546001600160a01b031615610241565b6102176103ff36600461192e565b610c2f565b610217610412366004611881565b610cfc565b61021761042536600461181a565b610dcd565b6006818154811061043a57600080fd5b6000918252602090912001546001600160a01b0316905081565b6000546001600160a01b0316331461047f576040516311a8a1bb60e31b815260040160405180910390fd5b60095481036104c45760405162461bcd60e51b815260206004820152600c60248201526b2164656c6179426c6f636b7360a01b60448201526064015b60405180910390fd5b6009546040805183815260208101929092527fef322fd61cb3d8514326f0b28140a92a29cd10996ad80d0671e43d2483464c1d910160405180910390a1600955565b63ffffffff81166000908152600860205260408120548082036105585760405162461bcd60e51b815260206004820152600a602482015269085cdd5c1c1bdc9d195960b21b60448201526064016104bb565b610563600182611992565b9392505050565b6000546001600160a01b03163314610595576040516311a8a1bb60e31b815260040160405180910390fd5b61059d610ec0565b6105a5610f09565b565b6105af610f5b565b828181146105f15760405162461bcd60e51b815260206004820152600f60248201526e696e76616c6964206c656e6774687360881b60448201526064016104bb565b6105fd85858585610cfc565b6000610615600954600a610fa190919063ffffffff16565b9050805160000361065c5760405162461bcd60e51b81526020600482015260116024820152706e6f20766572696669656420726f6f747360781b60448201526064016104bb565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166334a55ee6846040518263ffffffff1660e01b81526004016106ab91906119e4565b60408051808303816000875af11580156106c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ed91906119f7565b9150915060005b848163ffffffff1610156107b85786868263ffffffff1681811061071a5761071a611a1b565b905060200201602081019061072f919061192e565b6001600160a01b03166382646a588460405160200161075091815260200190565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161077b9190611a31565b600060405180830381600087803b15801561079557600080fd5b505af11580156107a9573d6000803e3d6000fd5b505050508060010190506106f4565b507fb0b3d44baf84014c485fc70c5f229e509a6e6c0f3e5e84916115545b61c820bf82828a8a876040516107f0959493929190611abf565b60405180910390a15050505050505050565b6004818154811061081257600080fd5b9060005260206000209060089182820401919006600402915054906101000a900463ffffffff1681565b6000546001600160a01b03163314610867576040516311a8a1bb60e31b815260040160405180910390fd5b60025460000361088a57604051630e4b303f60e21b815260040160405180910390fd5b62093a806002544261089c9190611992565b116108ba576040516386d4b3f160e01b815260040160405180910390fd5b6001546001600160a01b0316156108e4576040516323295ef960e01b815260040160405180910390fd5b6001546105a5906001600160a01b031661119b565b6000600661090683610506565b8154811061091657610916611a1b565b6000918252602090912001546001600160a01b031692915050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa15801561097d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109a19190611afd565b6109d85760405162461bcd60e51b815260206004820152600860248201526710bbb0ba31b432b960c11b60448201526064016104bb565b6109e0610f5b565b6105a56111fa565b6109f0610f5b565b81336109fb826108f9565b6001600160a01b031614610a3e5760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b60448201526064016104bb565b6000610a4b600a84611237565b6040805163ffffffff87168152602081018690526001600160801b0383168183015290519192507ff5832b5d15f2d906d01b871e48b0d1f27d8f282a7e0771c428b55bfeb409fa05919081900360600190a150505050565b6000610aaf600a6112a9565b905090565b6000546001600160a01b03163314610adf576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b038281169116148015610b0457506001600160a01b03811615155b15610b22576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b03808316911603610b5057604051634a2fb73f60e11b815260040160405180910390fd5b610b59816112d3565b50565b6000546001600160a01b03163314610b87576040516311a8a1bb60e31b815260040160405180910390fd5b610b918282611321565b7f95ef69787290b89c35a092c89db1b283b43724d01263e683cfb560c758cdbe70828260046006604051610bc89493929190611ce5565b60405180910390a15050565b6001546001600160a01b03163314610bff576040516311a7f27160e11b815260040160405180910390fd5b62093a8060025442610c119190611992565b116108e45760405163d39c12bb60e01b815260040160405180910390fd5b6000546001600160a01b03163314610c5a576040516311a8a1bb60e31b815260040160405180910390fd5b6003546001600160a01b03610100909104811690821603610cbd5760405162461bcd60e51b815260206004820152601760248201527f616c72656164792077617463686572206d616e6167657200000000000000000060448201526064016104bb565b6040516001600160a01b03821681527fc16d059e43d7f8e29ccb4e001a2f249d3c59e274925d6a6bc3912943441d9f6c9060200160405180910390a150565b6005548484604051602001610d12929190611d32565b6040516020818303038152906040528051906020012014610d605760405162461bcd60e51b815260206004820152600860248201526721646f6d61696e7360c01b60448201526064016104bb565b6007548282604051602001610d76929190611d46565b6040516020818303038152906040528051906020012014610dc75760405162461bcd60e51b815260206004820152600b60248201526a21636f6e6e6563746f727360a81b60448201526064016104bb565b50505050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa158015610e19573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e3d9190611afd565b610e745760405162461bcd60e51b815260206004820152600860248201526710bbb0ba31b432b960c11b60448201526064016104bb565b6000610e7f8261146c565b90507f6a1097f391a37dc63e0860e64ec34442971eeed2fda4d1a90141fa9ce25eb7eb82826004600633604051610bc8959493929190611d92565b60019055565b60035460ff166105a55760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016104bb565b610f11610ec0565b6003805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b60035460ff16156105a55760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016104bb565b81546060906001600160801b0380821691600160801b90041681811015610ff85760405162461bcd60e51b815260206004820152600b60248201526a717565756520656d70747960a81b60448201526064016104bb565b60005b826001600160801b0316826001600160801b031610611056576001600160801b03821660009081526002870160205260409020548561103a8243611992565b10611049576001915050611056565b5060001990910190610ffb565b8061107557505060408051600081526020810190915291506111959050565b600083611083846001611dfe565b61108d9190611e29565b6001600160801b031667ffffffffffffffff8111156110ae576110ae611de8565b6040519080825280602002602001820160405280156110d7578160200160208202803683370190505b50905060005b836001600160801b0316856001600160801b031611611167576001600160801b0385166000908152600189016020526040902054825183908390811061112557611125611a1b565b6020908102919091018101919091526001600160801b03861660009081526001808b018352604080832083905560028c019093529181205594850194016110dd565b5086546fffffffffffffffffffffffffffffffff19166001600160801b039490941693909317865550909150505b92915050565b600080546001600160a01b038381166001600160a01b0319808416821785556002859055600180549091169055604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b611202610f5b565b6003805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258610f3e3390565b81546000904390849060109061125c90600160801b90046001600160801b0316611e51565b82546001600160801b038083166101009490940a84810291021990911617909255600090815260018601602090815260408083209690965560029096019095529290932092909255919050565b80546000906001600160801b03600160801b8204811691166112cb8282611688565b949350505050565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b63ffffffff82166000908152600860205260409020541561136d5760405162461bcd60e51b815260206004820152600660248201526565786973747360d01b60448201526064016104bb565b6001600160a01b0381166113b05760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b60448201526064016104bb565b600480546001818101835560088083047f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01805463ffffffff808916600790961687026101000a8681029102199091161790556006805492830190557ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f90910180546001600160a01b0386166001600160a01b031990911617905591546000918252602092909252604090208190556114676116b0565b505050565b60008061147883610506565b905060006006828154811061148f5761148f611a1b565b6000918252602090912001546001600160a01b03169050806114e75760405162461bcd60e51b8152602060048201526011602482015270636f6e6e6563746f72202165786973747360781b60448201526064016104bb565b6004546000906114f990600190611992565b9050808310156115f0576004818154811061151657611516611a1b565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff166004848154811061154f5761154f611a1b565b90600052602060002090600891828204019190066004026101000a81548163ffffffff021916908363ffffffff1602179055506006818154811061159557611595611a1b565b600091825260209091200154600680546001600160a01b0390921691859081106115c1576115c1611a1b565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b031602179055505b600480548061160157611601611e77565b600082815260209020600860001990920191820401805463ffffffff600460078516026101000a02191690559055600680548061164057611640611e77565b60008281526020808220830160001990810180546001600160a01b031916905590920190925563ffffffff871682526008905260408120556116806116b0565b509392505050565b600081611696846001611dfe565b6116a09190611e29565b6001600160801b03169392505050565b6000600480548060200260200160405190810160405280929190818152602001828054801561172a57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff16815260200190600401906020826003010492830192600103820291508084116116ed5790505b505050505090506000600680548060200260200160405190810160405280929190818152602001828054801561178957602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161176b575b50505050509050816040516020016117a19190611e8d565b60408051601f198184030181529082905280516020918201206005556117c991839101611ed7565b60408051601f1981840301815291905280516020909101206007555050565b6000602082840312156117fa57600080fd5b5035919050565b803563ffffffff8116811461181557600080fd5b919050565b60006020828403121561182c57600080fd5b61056382611801565b60008083601f84011261184757600080fd5b50813567ffffffffffffffff81111561185f57600080fd5b6020830191508360208260051b850101111561187a57600080fd5b9250929050565b6000806000806040858703121561189757600080fd5b843567ffffffffffffffff808211156118af57600080fd5b6118bb88838901611835565b909650945060208701359150808211156118d457600080fd5b506118e187828801611835565b95989497509550505050565b6000806040838503121561190057600080fd5b61190983611801565b946020939093013593505050565b80356001600160a01b038116811461181557600080fd5b60006020828403121561194057600080fd5b61056382611917565b6000806040838503121561195c57600080fd5b61196583611801565b915061197360208401611917565b90509250929050565b634e487b7160e01b600052601160045260246000fd5b6000828210156119a4576119a461197c565b500390565b600081518084526020808501945080840160005b838110156119d9578151875295820195908201906001016119bd565b509495945050505050565b60208152600061056360208301846119a9565b60008060408385031215611a0a57600080fd5b505080516020909101519092909150565b634e487b7160e01b600052603260045260246000fd5b600060208083528351808285015260005b81811015611a5e57858101830151858201604001528201611a42565b81811115611a70576000604083870101525b50601f01601f1916929092016040019392505050565b8183526000602080850194508260005b858110156119d95763ffffffff611aac83611801565b1687529582019590820190600101611a96565b858152846020820152608060408201526000611adf608083018587611a86565b8281036060840152611af181856119a9565b98975050505050505050565b600060208284031215611b0f57600080fd5b8151801515811461056357600080fd5b805480835260008281526020808220940193909190825b82600782011015611bae57815463ffffffff8082168852602082811c821690890152604082811c821690890152606082811c821690890152608082811c82169089015260a082811c82169089015260c082811c9091169088015260e090811c9087015261010090950194600190910190600801611b36565b90549082811015611bcc5763ffffffff821686526020909501946001015b82811015611bec57602082901c63ffffffff168652602095909501946001015b82811015611c0b5763ffffffff604083901c1686526020909501946001015b82811015611c2a5763ffffffff606083901c1686526020909501946001015b82811015611c495763ffffffff608083901c1686526020909501946001015b82811015611c685763ffffffff60a083901c1686526020909501946001015b82811015611c875763ffffffff60c083901c1686526020909501946001015b82811015611c9d5760e082901c86526020860195505b5093949350505050565b6000815480845260208085019450836000528060002060005b838110156119d95781546001600160a01b031687529582019560019182019101611cc0565b63ffffffff851681526001600160a01b0384166020820152608060408201819052600090611d1590830185611b1f565b8281036060840152611d278185611ca7565b979650505050505050565b6020815260006112cb602083018486611a86565b60208082528181018390526000908460408401835b86811015611d87576001600160a01b03611d7484611917565b1682529183019190830190600101611d5b565b509695505050505050565b63ffffffff86168152600060018060a01b03808716602084015260a06040840152611dc060a0840187611b1f565b8381036060850152611dd28187611ca7565b9250508084166080840152509695505050505050565b634e487b7160e01b600052604160045260246000fd5b60006001600160801b03808316818516808303821115611e2057611e2061197c565b01949350505050565b60006001600160801b0383811690831681811015611e4957611e4961197c565b039392505050565b60006001600160801b03808316818103611e6d57611e6d61197c565b6001019392505050565b634e487b7160e01b600052603160045260246000fd5b6020808252825182820181905260009190848201906040850190845b81811015611ecb57835163ffffffff1683529284019291840191600101611ea9565b50909695505050505050565b6020808252825182820181905260009190848201906040850190845b81811015611ecb5783516001600160a01b031683529284019291840191600101611ef356fea2646970667358221220e9e083edc35970d444f1762ee23db8a611d5a7b9942458b0d278721071feff8064736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addConnector(uint32,address)": {
        "details": "Only owner can add a new connector. Address should be the connector on L1.Cannot add address(0) to avoid duplicated domain in array and reduce gas fee while propagating.",
        "params": {
          "_connector": "Address of the hub connector.",
          "_domain": "The target spoke domain of the given connector."
        }
      },
      "aggregate(uint32,bytes32)": {
        "details": "The aggregate tree's root, which will include this inbound root, will be propagated to all spoke domains (via `propagate`) on a regular basis assuming the verification period is surpassed without dispute.",
        "params": {
          "_domain": "The source domain of the given root.",
          "_inbound": "The inbound root coming from the given domain."
        }
      },
      "constructor": {
        "params": {
          "_delayBlocks": "The delay for the validation period for incoming messages in blocks.",
          "_merkle": "The address of the MerkleTreeManager on this domain.",
          "_watcherManager": "The address of the WatcherManager on this domain."
        }
      },
      "getConnectorForDomain(uint32)": {
        "details": "Inefficient, should only be used by caller if they have no index reference.",
        "params": {
          "_domain": "The domain for which to get the hub connector address."
        }
      },
      "getDomainIndex(uint32)": {
        "details": "Reverts if domain is not supported.",
        "params": {
          "_domain": "The domain for which to get the index value."
        }
      },
      "isDomainSupported(uint32)": {
        "params": {
          "_domain": "Domain to check."
        }
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "propagate(uint32[],address[])": {
        "details": "Should be called by relayers at a regular interval.",
        "params": {
          "_connectors": "Array of connectors: should match exactly the array of `connectors` in storage (see `_domains` param's info on reducing gas costs).",
          "_domains": "Array of domains: should match exactly the array of `domains` in storage; used here to reduce gas costs, and keep them static regardless of number of supported domains."
        }
      },
      "removeConnector(uint32)": {
        "details": "Only watcher can remove a connector. TODO: Could add a metatx-able `removeConnectorWithSig` if we want to use relayers?",
        "params": {
          "_domain": "The spoke domain of the target connector we want to remove."
        }
      },
      "setWatcherManager(address)": {
        "details": "Owner can enroll a watcher (abilities are defined by inheriting contracts)"
      },
      "validateDomains(uint32[],address[])": {
        "details": "Reverts if domains or connectors do not match, including ordering."
      }
    },
    "stateVariables": {
      "pendingInboundRoots": {
        "details": "Watchers should be able to watch this queue for fraudulent messages and pause this contract if fraud is detected."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "MERKLE()": {
        "notice": "MerkleTreeManager contract instance. Will hold the active tree of aggregated inbound roots. The root of this tree will be distributed crosschain to all spoke domains."
      },
      "acceptProposedOwner()": {
        "notice": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "addConnector(uint32,address)": {
        "notice": "Add a new supported domain and corresponding hub connector to the system. This new domain will receive the propagated aggregate root."
      },
      "aggregate(uint32,bytes32)": {
        "notice": "Accept an inbound root coming from a given domain's hub connector, enqueuing this incoming root into the current queue as it awaits the verification period."
      },
      "connectors(uint256)": {
        "notice": "Tracks the addresses of the hub connector contracts corresponding to subscribed spoke domains. The index of any given connector in this array should match the index of that connector's target spoke domain in the `domains` array above."
      },
      "connectorsHash()": {
        "notice": "A \"quick reference\" hash used in the `propagate` method below to validate that the provided array of connectors matches the one we have in storage."
      },
      "constructor": {
        "notice": "Creates a new RootManager instance."
      },
      "delay()": {
        "notice": "Returns the delay period before a new owner can be accepted."
      },
      "delayBlocks()": {
        "notice": "Number of blocks to delay the processing of a message to allow for watchers to verify the validity and pause if necessary."
      },
      "domains(uint256)": {
        "notice": "Domains array tracks currently subscribed domains to this hub aggregator. We should distribute the aggregate root to all of these domains in the `propagate` method."
      },
      "domainsHash()": {
        "notice": "A \"quick reference\" hash used in the `propagate` method below to validate that the provided array of domains matches the one we have in storage."
      },
      "getConnectorForDomain(uint32)": {
        "notice": "Gets the corresponding hub connector address for a given spoke domain."
      },
      "getDomainIndex(uint32)": {
        "notice": "Gets the index of a given domain in the domains and connectors arrays."
      },
      "isDomainSupported(uint32)": {
        "notice": "Convenience shortcut for supported domains. Used to sanity check adding new domains."
      },
      "owner()": {
        "notice": "Returns the address of the current owner."
      },
      "pendingInboundRoots()": {
        "notice": "Queue used for management of verification for inbound roots from spoke chains. Once the verification period elapses, the inbound messages can be aggregated into the merkle tree for propagation to spoke chains."
      },
      "propagate(uint32[],address[])": {
        "notice": "This is called by relayers to take the current aggregate tree root and propagate it to all spoke domains (via their respective hub connectors)."
      },
      "proposeNewOwner(address)": {
        "notice": "Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process"
      },
      "proposed()": {
        "notice": "Returns the address of the proposed owner."
      },
      "proposedTimestamp()": {
        "notice": "Returns the address of the proposed owner."
      },
      "removeConnector(uint32)": {
        "notice": "Remove support for a connector and respective domain. That connector/domain will no longer receive updates for the latest aggregate root."
      },
      "renounceOwnership()": {
        "notice": "Renounces ownership of the contract after a delay"
      },
      "renounced()": {
        "notice": "Indicates if the ownership has been renounced() by checking if current owner is address(0)"
      },
      "setDelayBlocks(uint256)": {
        "notice": "Set the `delayBlocks`, the period in blocks over which an incoming message is verified."
      },
      "validateDomains(uint32[],address[])": {
        "notice": "Validate given domains and connectors arrays are correct (i.e. they mirror what is currently saved in storage)."
      }
    },
    "notice": "This contract exists at cluster hubs, and aggregates all transfer roots from messaging spokes into a single merkle root",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 47175,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 47177,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_proposed",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 47179,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_proposedOwnershipTimestamp",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 10746,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_paused",
        "offset": 0,
        "slot": "3",
        "type": "t_bool"
      },
      {
        "astId": 36911,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "watcherManager",
        "offset": 1,
        "slot": "3",
        "type": "t_contract(WatcherManager)37078"
      },
      {
        "astId": 45812,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "domains",
        "offset": 0,
        "slot": "4",
        "type": "t_array(t_uint32)dyn_storage"
      },
      {
        "astId": 45815,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "domainsHash",
        "offset": 0,
        "slot": "5",
        "type": "t_bytes32"
      },
      {
        "astId": 45819,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "connectors",
        "offset": 0,
        "slot": "6",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 45822,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "connectorsHash",
        "offset": 0,
        "slot": "7",
        "type": "t_bytes32"
      },
      {
        "astId": 45827,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "domainToIndexPlusOne",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint32,t_uint256)"
      },
      {
        "astId": 36622,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "delayBlocks",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 36626,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "pendingInboundRoots",
        "offset": 0,
        "slot": "10",
        "type": "t_struct(Queue)46892_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint32)dyn_storage": {
        "base": "t_uint32",
        "encoding": "dynamic_array",
        "label": "uint32[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(WatcherManager)37078": {
        "encoding": "inplace",
        "label": "contract WatcherManager",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Queue)46892_storage": {
        "encoding": "inplace",
        "label": "struct QueueLib.Queue",
        "members": [
          {
            "astId": 46881,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "first",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 46883,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "last",
            "offset": 16,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 46887,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "data",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_bytes32)"
          },
          {
            "astId": 46891,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "commitBlock",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_uint256)"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}