{
  "language": "Solidity",
  "sources": {
    "contracts/core/connext/facets/BaseConnextFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {TransferInfo, AppStorage, Role} from \"../libraries/LibConnextStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {TokenId} from \"../libraries/TokenId.sol\";\nimport {Constants} from \"../libraries/Constants.sol\";\n\ncontract BaseConnextFacet {\n  AppStorage internal s;\n\n  // ========== Custom Errors ===========\n\n  error BaseConnextFacet__onlyOwner_notOwner();\n  error BaseConnextFacet__onlyProposed_notProposedOwner();\n  error BaseConnextFacet__onlyOwnerOrRouter_notOwnerOrRouter();\n  error BaseConnextFacet__onlyOwnerOrWatcher_notOwnerOrWatcher();\n  error BaseConnextFacet__onlyOwnerOrAdmin_notOwnerOrAdmin();\n  error BaseConnextFacet__whenNotPaused_paused();\n  error BaseConnextFacet__nonReentrant_reentrantCall();\n  error BaseConnextFacet__nonXCallReentrant_reentrantCall();\n  error BaseConnextFacet__getAdoptedAsset_assetNotFound();\n  error BaseConnextFacet__getApprovedCanonicalId_notAllowlisted();\n\n  // ============ Modifiers ============\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    if (s._status == Constants.ENTERED) revert BaseConnextFacet__nonReentrant_reentrantCall();\n\n    // Any calls to nonReentrant after this point will fail\n    s._status = Constants.ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    s._status = Constants.NOT_ENTERED;\n  }\n\n  modifier nonXCallReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    if (s._xcallStatus == Constants.ENTERED) revert BaseConnextFacet__nonXCallReentrant_reentrantCall();\n\n    // Any calls to nonReentrant after this point will fail\n    s._xcallStatus = Constants.ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    s._xcallStatus = Constants.NOT_ENTERED;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    if (LibDiamond.contractOwner() != msg.sender) revert BaseConnextFacet__onlyOwner_notOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the proposed owner.\n   */\n  modifier onlyProposed() {\n    if (s._proposed != msg.sender) revert BaseConnextFacet__onlyProposed_notProposedOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner and router role.\n   */\n  modifier onlyOwnerOrRouter() {\n    if (LibDiamond.contractOwner() != msg.sender && s.roles[msg.sender] != Role.RouterAdmin)\n      revert BaseConnextFacet__onlyOwnerOrRouter_notOwnerOrRouter();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner and watcher role.\n   */\n  modifier onlyOwnerOrWatcher() {\n    if (LibDiamond.contractOwner() != msg.sender && s.roles[msg.sender] != Role.Watcher)\n      revert BaseConnextFacet__onlyOwnerOrWatcher_notOwnerOrWatcher();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner and admin role.\n   */\n  modifier onlyOwnerOrAdmin() {\n    if (LibDiamond.contractOwner() != msg.sender && s.roles[msg.sender] != Role.Admin)\n      revert BaseConnextFacet__onlyOwnerOrAdmin_notOwnerOrAdmin();\n    _;\n  }\n\n  /**\n   * @notice Throws if all functionality is paused\n   */\n  modifier whenNotPaused() {\n    if (s._paused) revert BaseConnextFacet__whenNotPaused_paused();\n    _;\n  }\n\n  // ============ Internal functions ============\n  /**\n   * @notice Indicates if the router allowlist has been removed\n   */\n  function _isRouterAllowlistRemoved() internal view returns (bool) {\n    return LibDiamond.contractOwner() == address(0) || s._routerAllowlistRemoved;\n  }\n\n  /**\n   * @notice Returns the adopted assets for given canonical information\n   */\n  function _getAdoptedAsset(bytes32 _key) internal view returns (address) {\n    address adopted = AssetLogic.getConfig(_key).adopted;\n    if (adopted == address(0)) {\n      revert BaseConnextFacet__getAdoptedAsset_assetNotFound();\n    }\n    return adopted;\n  }\n\n  /**\n   * @notice Returns the adopted assets for given canonical information\n   */\n  function _getRepresentationAsset(bytes32 _key) internal view returns (address) {\n    address representation = AssetLogic.getConfig(_key).representation;\n    // If this is address(0), then there is no mintable token for this asset on this\n    // domain\n    return representation;\n  }\n\n  /**\n   * @notice Calculates a transferId\n   */\n  function _calculateTransferId(TransferInfo memory _params) internal pure returns (bytes32) {\n    return keccak256(abi.encode(_params));\n  }\n\n  /**\n   * @notice Internal utility function that combines\n   *         `_origin` and `_nonce`.\n   * @dev Both origin and nonce should be less than 2^32 - 1\n   * @param _origin Domain of chain where the transfer originated\n   * @param _nonce The unique identifier for the message from origin to destination\n   * @return Returns (`_origin` << 32) & `_nonce`\n   */\n  function _originAndNonce(uint32 _origin, uint32 _nonce) internal pure returns (uint64) {\n    return (uint64(_origin) << 32) | _nonce;\n  }\n\n  function _getLocalAsset(\n    bytes32 _key,\n    bytes32 _id,\n    uint32 _domain\n  ) internal view returns (address) {\n    return AssetLogic.getLocalAsset(_key, _id, _domain, s);\n  }\n\n  function _getCanonicalTokenId(address _candidate) internal view returns (TokenId memory) {\n    return AssetLogic.getCanonicalTokenId(_candidate, s);\n  }\n\n  function _getLocalAndAdoptedToken(\n    bytes32 _key,\n    bytes32 _id,\n    uint32 _domain\n  ) internal view returns (address, address) {\n    address _local = AssetLogic.getLocalAsset(_key, _id, _domain, s);\n    address _adopted = _getAdoptedAsset(_key);\n    return (_local, _adopted);\n  }\n\n  function _isLocalOrigin(address _token) internal view returns (bool) {\n    return AssetLogic.isLocalOrigin(_token, s);\n  }\n\n  function _getApprovedCanonicalId(address _candidate) internal view returns (TokenId memory, bytes32) {\n    TokenId memory _canonical = _getCanonicalTokenId(_candidate);\n    bytes32 _key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n    if (!AssetLogic.getConfig(_key).approval) {\n      revert BaseConnextFacet__getApprovedCanonicalId_notAllowlisted();\n    }\n    return (_canonical, _key);\n  }\n}\n"
    },
    "contracts/core/connext/libraries/LibConnextStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {IConnectorManager} from \"../../../messaging/interfaces/IConnectorManager.sol\";\nimport {SwapUtils} from \"./SwapUtils.sol\";\nimport {TokenId} from \"./TokenId.sol\";\n\n/**\n * @notice THIS FILE DEFINES OUR STORAGE LAYOUT AND ID GENERATION SCHEMA. IT CAN ONLY BE MODIFIED FREELY FOR FRESH\n * DEPLOYS. If you are modifiying this file for an upgrade, you must **CAREFULLY** ensure\n * the contract storage layout is not impacted.\n *\n * BE VERY CAREFUL MODIFYING THE VALUES IN THIS FILE!\n */\n\n// ============= Enum =============\n\n/// @notice Enum representing address role\n// Returns uint\n// None     - 0\n// Router   - 1\n// Watcher  - 2\n// Admin    - 3\nenum Role {\n  None,\n  RouterAdmin,\n  Watcher,\n  Admin\n}\n\n/**\n * @notice Enum representing status of destination transfer\n * @dev Status is only assigned on the destination domain, will always be \"none\" for the\n * origin domains\n * @return uint - Index of value in enum\n */\nenum DestinationTransferStatus {\n  None, // 0\n  Reconciled, // 1\n  Executed, // 2\n  Completed // 3 - executed + reconciled\n}\n\n/**\n * @notice These are the parameters that will remain constant between the\n * two chains. They are supplied on `xcall` and should be asserted on `execute`\n * @property to - The account that receives funds, in the event of a crosschain call,\n * will receive funds if the call fails.\n *\n * @param originDomain - The originating domain (i.e. where `xcall` is called)\n * @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called)\\\n * @param canonicalDomain - The canonical domain of the asset you are bridging\n * @param to - The address you are sending funds (and potentially data) to\n * @param delegate - An address who can execute txs on behalf of `to`, in addition to allowing relayers\n * @param receiveLocal - If true, will use the local asset on the destination instead of adopted.\n * @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\n * @param slippage - Slippage user is willing to accept from original amount in expressed in BPS (i.e. if\n * a user takes 1% slippage, this is expressed as 1_000)\n * @param originSender - The msg.sender of the xcall\n * @param bridgedAmt - The amount sent over the bridge (after potential AMM on xcall)\n * @param normalizedIn - The amount sent to `xcall`, normalized to 18 decimals\n * @param nonce - The nonce on the origin domain used to ensure the transferIds are unique\n * @param canonicalId - The unique identifier of the canonical token corresponding to bridge assets\n */\nstruct TransferInfo {\n  uint32 originDomain;\n  uint32 destinationDomain;\n  uint32 canonicalDomain;\n  address to;\n  address delegate;\n  bool receiveLocal;\n  bytes callData;\n  uint256 slippage;\n  address originSender;\n  uint256 bridgedAmt;\n  uint256 normalizedIn;\n  uint256 nonce;\n  bytes32 canonicalId;\n}\n\n/**\n * @notice\n * @param params - The TransferInfo. These are consistent across sending and receiving chains.\n * @param routers - The routers who you are sending the funds on behalf of.\n * @param routerSignatures - Signatures belonging to the routers indicating permission to use funds\n * for the signed transfer ID.\n * @param sequencer - The sequencer who assigned the router path to this transfer.\n * @param sequencerSignature - Signature produced by the sequencer for path assignment accountability\n * for the path that was signed.\n */\nstruct ExecuteArgs {\n  TransferInfo params;\n  address[] routers;\n  bytes[] routerSignatures;\n  address sequencer;\n  bytes sequencerSignature;\n}\n\n/**\n * @notice Contains configs for each router\n * @param approved Whether the router is allowlisted, settable by admin\n * @param portalApproved Whether the router is allowlisted for portals, settable by admin\n * @param routerOwners The address that can update the `recipient`\n * @param proposedRouterOwners Owner candidates\n * @param proposedRouterTimestamp When owner candidate was proposed (there is a delay to acceptance)\n */\nstruct RouterConfig {\n  bool approved;\n  bool portalApproved;\n  address owner;\n  address recipient;\n  address proposed;\n  uint256 proposedTimestamp;\n}\n\n/**\n * @notice Contains configurations for tokens\n * @dev Struct will be stored on the hash of the `canonicalId` and `canonicalDomain`. There are also\n * two separate reverse lookups, that deliver plaintext information based on the passed in address (can\n * either be representation or adopted address passed in).\n *\n * If the decimals are updated in a future token upgrade, the transfers should fail. If that happens, the\n * asset and swaps must be removed, and then they can be readded\n *\n * @param representation Address of minted asset on this domain. If the token is of local origin (meaning it was\n * originally deployed on this chain), this MUST map to address(0).\n * @param representationDecimals Decimals of minted asset on this domain\n * @param adopted Address of adopted asset on this domain\n * @param adoptedDecimals Decimals of adopted asset on this domain\n * @param adoptedToLocalExternalPools Holds the AMMs for swapping in and out of local assets\n * @param approval Allowed assets\n * @param cap Liquidity caps of whitelisted assets. If 0, no cap is enforced.\n * @param custodied Custodied balance by address\n */\nstruct TokenConfig {\n  address representation;\n  uint8 representationDecimals;\n  address adopted;\n  uint8 adoptedDecimals;\n  address adoptedToLocalExternalPools;\n  bool approval;\n  uint256 cap;\n  uint256 custodied;\n}\n\nstruct AppStorage {\n  //\n  // 0\n  bool initialized;\n  //\n  // Connext\n  //\n  // 1\n  uint256 LIQUIDITY_FEE_NUMERATOR;\n  /**\n   * @notice The local address that is custodying relayer fees\n   */\n  // 2\n  address relayerFeeVault;\n  /**\n   * @notice Nonce for the contract, used to keep unique transfer ids.\n   * @dev Assigned at first interaction (xcall on origin domain).\n   */\n  // 3\n  uint256 nonce;\n  /**\n   * @notice The domain this contract exists on.\n   * @dev Must match the domain identifier, which is distinct from the \"chainId\".\n   */\n  // 4\n  uint32 domain;\n  /**\n   * @notice Mapping of adopted to canonical asset information.\n   */\n  mapping(address => TokenId) adoptedToCanonical;\n  /**\n   * @notice Mapping of representation to canonical asset information.\n   */\n  mapping(address => TokenId) representationToCanonical;\n  /**\n   * @notice Mapping of hash(canonicalId, canonicalDomain) to token config on this domain.\n   */\n  mapping(bytes32 => TokenConfig) tokenConfigs;\n  /**\n   * @notice Mapping to track transfer status on destination domain\n   */\n  // 12\n  mapping(bytes32 => DestinationTransferStatus) transferStatus;\n  /**\n   * @notice Mapping holding router address that provided fast liquidity.\n   */\n  // 13\n  mapping(bytes32 => address[]) routedTransfers;\n  /**\n   * @notice Mapping of router to available balance of an asset.\n   * @dev Routers should always store liquidity that they can expect to receive via the bridge on\n   * this domain (the local asset).\n   */\n  // 14\n  mapping(address => mapping(address => uint256)) routerBalances;\n  /**\n   * @notice Mapping of approved relayers\n   * @dev Send relayer fee if msg.sender is approvedRelayer; otherwise revert.\n   */\n  // 15\n  mapping(address => bool) approvedRelayers;\n  /**\n   * @notice The max amount of routers a payment can be routed through.\n   */\n  // 18\n  uint256 maxRoutersPerTransfer;\n  /**\n   * @notice Stores a mapping of transfer id to slippage overrides.\n   */\n  // 20\n  mapping(bytes32 => uint256) slippage;\n  /**\n   * @notice Stores a mapping of transfer id to receive local overrides.\n   */\n  mapping(bytes32 => bool) receiveLocalOverride;\n  /**\n   * @notice Stores a mapping of remote routers keyed on domains.\n   * @dev Addresses are cast to bytes32.\n   * This mapping is required because the Connext now contains the BridgeRouter and must implement\n   * the remotes interface.\n   */\n  // 21\n  mapping(uint32 => bytes32) remotes;\n  //\n  // ProposedOwnable\n  //\n  // 22\n  address _proposed;\n  // 23\n  uint256 _proposedOwnershipTimestamp;\n  // 24\n  bool _routerAllowlistRemoved;\n  // 25\n  uint256 _routerAllowlistTimestamp;\n  /**\n   * @notice Stores a mapping of address to Roles\n   * @dev returns uint representing the enum Role value\n   */\n  // 28\n  mapping(address => Role) roles;\n  //\n  // RouterFacet\n  //\n  // 29\n  mapping(address => RouterConfig) routerConfigs;\n  //\n  // ReentrancyGuard\n  //\n  // 30\n  uint256 _status;\n  uint256 _xcallStatus;\n  //\n  // StableSwap\n  //\n  /**\n   * @notice Mapping holding the AMM storages for swapping in and out of local assets\n   * @dev Swaps for an adopted asset <> local asset (i.e. POS USDC <> nextUSDC on polygon)\n   * Struct storing data responsible for automatic market maker functionalities. In order to\n   * access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol.\n   */\n  // 31\n  mapping(bytes32 => SwapUtils.Swap) swapStorages;\n  /**\n   * @notice Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n   * @dev getTokenIndex function also relies on this mapping to retrieve token index.\n   */\n  // 32\n  mapping(bytes32 => mapping(address => uint8)) tokenIndexes;\n  /**\n   * The address of an existing LPToken contract to use as a target\n   * this target must be the address which connext deployed on this chain.\n   */\n  // 33\n  address lpTokenTargetAddress;\n  /**\n   * @notice Stores whether or not bribing, AMMs, have been paused.\n   */\n  // 34\n  bool _paused;\n  //\n  // AavePortals\n  //\n  /**\n   * @notice Address of Aave Pool contract.\n   */\n  // 35\n  address aavePool;\n  /**\n   * @notice Fee percentage numerator for using Portal liquidity.\n   * @dev Assumes the same basis points as the liquidity fee.\n   */\n  // 36\n  uint256 aavePortalFeeNumerator;\n  /**\n   * @notice Mapping to store the transfer liquidity amount provided by Aave Portals.\n   */\n  // 37\n  mapping(bytes32 => uint256) portalDebt;\n  /**\n   * @notice Mapping to store the transfer liquidity amount provided by Aave Portals.\n   */\n  // 38\n  mapping(bytes32 => uint256) portalFeeDebt;\n  /**\n   * @notice Mapping of approved sequencers\n   * @dev Sequencer address provided must belong to an approved sequencer in order to call `execute`\n   * for the fast liquidity route.\n   */\n  // 39\n  mapping(address => bool) approvedSequencers;\n  /**\n   * @notice Remote connection manager for xapp.\n   */\n  // 40\n  IConnectorManager xAppConnectionManager;\n}\n\nlibrary LibConnextStorage {\n  function connextStorage() internal pure returns (AppStorage storage ds) {\n    assembly {\n      ds.slot := 0\n    }\n  }\n}\n"
    },
    "contracts/core/connext/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n  bytes32 constant DIAMOND_STORAGE_POSITION = bytes32(uint256(keccak256(\"diamond.standard.diamond.storage\")) - 1);\n\n  struct FacetAddressAndPosition {\n    address facetAddress;\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n  }\n\n  struct FacetFunctionSelectors {\n    bytes4[] functionSelectors;\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n  }\n\n  struct DiamondStorage {\n    // maps function selector to the facet address and\n    // the position of the selector in the facetFunctionSelectors.selectors array\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n    // maps facet addresses to function selectors\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n    // facet addresses\n    address[] facetAddresses;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address contractOwner;\n    // hash of proposed facets => acceptance time\n    mapping(bytes32 => uint256) acceptanceTimes;\n    // acceptance delay for upgrading facets\n    uint256 acceptanceDelay;\n  }\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function setContractOwner(address _newOwner) internal {\n    DiamondStorage storage ds = diamondStorage();\n    emit OwnershipTransferred(ds.contractOwner, _newOwner);\n    ds.contractOwner = _newOwner;\n  }\n\n  function contractOwner() internal view returns (address contractOwner_) {\n    contractOwner_ = diamondStorage().contractOwner;\n  }\n\n  function acceptanceDelay() internal view returns (uint256) {\n    return diamondStorage().acceptanceDelay;\n  }\n\n  function acceptanceTime(bytes32 _key) internal view returns (uint256) {\n    return diamondStorage().acceptanceTimes[_key];\n  }\n\n  function enforceIsContractOwner() internal view {\n    require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: !contract owner\");\n  }\n\n  event DiamondCutProposed(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\n\n  function proposeDiamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    // NOTE: to save gas, verification that `proposeDiamondCut` and `diamondCut` are not\n    // included is performed in `diamondCut`, where there is already a loop over facets.\n    // In the case where these cuts are performed, admins must call `rescindDiamondCut`\n\n    DiamondStorage storage ds = diamondStorage();\n    uint256 acceptance = block.timestamp + ds.acceptanceDelay;\n    ds.acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))] = acceptance;\n    emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);\n  }\n\n  event DiamondCutRescinded(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  function rescindDiamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    // NOTE: you can always rescind a proposed facet cut as the owner, even if outside of the validity\n    // period or befor the delay elpases\n    delete diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))];\n    emit DiamondCutRescinded(_diamondCut, _init, _calldata);\n  }\n\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  // Internal function version of diamondCut\n  function diamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    DiamondStorage storage ds = diamondStorage();\n    bytes32 key = keccak256(abi.encode(_diamondCut, _init, _calldata));\n    if (ds.facetAddresses.length != 0) {\n      uint256 time = ds.acceptanceTimes[key];\n      require(time != 0 && time <= block.timestamp, \"LibDiamond: delay not elapsed\");\n      // Reset the acceptance time to ensure the same set of updates cannot be replayed\n      // without going through a proposal window\n\n      // NOTE: the only time this will not be set to 0 is when there are no\n      // existing facet addresses (on initialization, or when starting after a bad upgrade,\n      // for example).\n      // The only relevant case is the initial case, which has no acceptance time. otherwise,\n      // there is no way to update the facet selector mapping to call `diamondCut`.\n      // Avoiding setting the empty value will save gas on the initial deployment.\n      delete ds.acceptanceTimes[key];\n    } // Otherwise, this is the first instance of deployment and it can be set automatically\n    uint256 len = _diamondCut.length;\n    for (uint256 facetIndex; facetIndex < len; ) {\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n      if (action == IDiamondCut.FacetCutAction.Add) {\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n      } else {\n        revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n      }\n\n      unchecked {\n        ++facetIndex;\n      }\n    }\n    emit DiamondCut(_diamondCut, _init, _calldata);\n    initializeDiamondCut(_init, _calldata);\n  }\n\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n    // add new facet address if it does not exist\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    uint256 len = _functionSelectors.length;\n    for (uint256 selectorIndex; selectorIndex < len; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      selectorPosition++;\n\n      unchecked {\n        ++selectorIndex;\n      }\n    }\n  }\n\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    uint256 len = _functionSelectors.length;\n    require(len != 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n    // add new facet address if it does not exist\n    if (selectorPosition == 0) {\n      addFacet(ds, _facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < len; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n      removeFunction(ds, oldFacetAddress, selector);\n      addFunction(ds, selector, selectorPosition, _facetAddress);\n      selectorPosition++;\n\n      unchecked {\n        ++selectorIndex;\n      }\n    }\n  }\n\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    require(_functionSelectors.length != 0, \"LibDiamondCut: No selectors in facet to cut\");\n    DiamondStorage storage ds = diamondStorage();\n    // get the propose and cut selectors -- can never remove these\n    bytes4 proposeSelector = IDiamondCut.proposeDiamondCut.selector;\n    bytes4 cutSelector = IDiamondCut.diamondCut.selector;\n    // if function does not exist then do nothing and return\n    require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n    uint256 len = _functionSelectors.length;\n    for (uint256 selectorIndex; selectorIndex < len; ) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      require(selector != proposeSelector && selector != cutSelector, \"LibDiamondCut: Cannot remove cut selectors\");\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n      removeFunction(ds, oldFacetAddress, selector);\n\n      unchecked {\n        ++selectorIndex;\n      }\n    }\n  }\n\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n    enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n    ds.facetAddresses.push(_facetAddress);\n  }\n\n  function addFunction(\n    DiamondStorage storage ds,\n    bytes4 _selector,\n    uint96 _selectorPosition,\n    address _facetAddress\n  ) internal {\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n  }\n\n  function removeFunction(\n    DiamondStorage storage ds,\n    address _facetAddress,\n    bytes4 _selector\n  ) internal {\n    require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n    // an immutable function is a function defined directly in a diamond\n    require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n    // replace selector with last selector, then delete last selector\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n    // if not the same then replace _selector with lastSelector\n    if (selectorPosition != lastSelectorPosition) {\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n    }\n    // delete the last selector\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n    delete ds.selectorToFacetAndPosition[_selector];\n\n    // if no more selectors for facet address then delete the facet address\n    if (lastSelectorPosition == 0) {\n      // replace facet address with last facet address and delete last facet address\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n      if (facetAddressPosition != lastFacetAddressPosition) {\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n      }\n      ds.facetAddresses.pop();\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n    }\n  }\n\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n    if (_init == address(0)) {\n      require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n    } else {\n      require(_calldata.length != 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n      if (_init != address(this)) {\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n      }\n      (bool success, bytes memory error) = _init.delegatecall(_calldata);\n      if (!success) {\n        if (error.length != 0) {\n          // bubble up the error\n          revert(string(error));\n        } else {\n          revert(\"LibDiamondCut: _init function reverted\");\n        }\n      }\n    }\n  }\n\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n    require(_contract.code.length != 0, _errorMessage);\n  }\n}\n"
    },
    "contracts/core/connext/libraries/AssetLogic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {TypeCasts} from \"../../../shared/libraries/TypeCasts.sol\";\n\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\n\nimport {LibConnextStorage, AppStorage, TokenConfig} from \"./LibConnextStorage.sol\";\nimport {SwapUtils} from \"./SwapUtils.sol\";\nimport {Constants} from \"./Constants.sol\";\nimport {TokenId} from \"./TokenId.sol\";\n\nlibrary AssetLogic {\n  // ============ Libraries ============\n\n  using SwapUtils for SwapUtils.Swap;\n  using SafeERC20 for IERC20Metadata;\n\n  // ============ Errors ============\n\n  error AssetLogic__handleIncomingAsset_nativeAssetNotSupported();\n  error AssetLogic__handleIncomingAsset_feeOnTransferNotSupported();\n  error AssetLogic__handleOutgoingAsset_notNative();\n  error AssetLogic__getTokenIndexFromStableSwapPool_notExist();\n  error AssetLogic__getConfig_notRegistered();\n  error AssetLogic__swapAsset_externalStableSwapPoolDoesNotExist();\n\n  // ============ Internal: Handle Transfer ============\n\n  function getConfig(bytes32 _key) internal view returns (TokenConfig storage) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n    TokenConfig storage config = s.tokenConfigs[_key];\n\n    // Sanity check: not empty\n    // NOTE: adopted decimals will *always* be nonzero (or reflect what is onchain\n    // for the asset). The same is not true for the representation assets, which\n    // will always have 0 decimals on the canonical domain\n    if (config.adoptedDecimals < 1) {\n      revert AssetLogic__getConfig_notRegistered();\n    }\n\n    return config;\n  }\n\n  /**\n   * @notice Handles transferring funds from msg.sender to the Connext contract.\n   * @dev Does NOT work with fee-on-transfer tokens: will revert.\n   *\n   * @param _asset - The address of the ERC20 token to transfer.\n   * @param _amount - The specified amount to transfer.\n   */\n  function handleIncomingAsset(address _asset, uint256 _amount) internal {\n    // Sanity check: if amount is 0, do nothing.\n    if (_amount == 0) {\n      return;\n    }\n    // Sanity check: asset address is not zero.\n    if (_asset == address(0)) {\n      revert AssetLogic__handleIncomingAsset_nativeAssetNotSupported();\n    }\n\n    IERC20Metadata asset = IERC20Metadata(_asset);\n\n    // Record starting amount to validate correct amount is transferred.\n    uint256 starting = asset.balanceOf(address(this));\n\n    // Transfer asset to contract.\n    asset.safeTransferFrom(msg.sender, address(this), _amount);\n\n    // Ensure correct amount was transferred (i.e. this was not a fee-on-transfer token).\n    if (asset.balanceOf(address(this)) - starting != _amount) {\n      revert AssetLogic__handleIncomingAsset_feeOnTransferNotSupported();\n    }\n  }\n\n  /**\n   * @notice Handles transferring funds from the Connext contract to a specified address\n   * @param _asset - The address of the ERC20 token to transfer.\n   * @param _to - The recipient address that will receive the funds.\n   * @param _amount - The amount to withdraw from contract.\n   */\n  function handleOutgoingAsset(\n    address _asset,\n    address _to,\n    uint256 _amount\n  ) internal {\n    // Sanity check: if amount is 0, do nothing.\n    if (_amount == 0) {\n      return;\n    }\n    // Sanity check: asset address is not zero.\n    if (_asset == address(0)) revert AssetLogic__handleOutgoingAsset_notNative();\n\n    // Transfer ERC20 asset to target recipient.\n    SafeERC20.safeTransfer(IERC20Metadata(_asset), _to, _amount);\n  }\n\n  // ============ Internal: StableSwap Pools ============\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param key the hash of the canonical id and domain\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getTokenIndexFromStableSwapPool(bytes32 key, address tokenAddress) internal view returns (uint8) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n    uint8 index = s.tokenIndexes[key][tokenAddress];\n    if (address(s.swapStorages[key].pooledTokens[index]) != tokenAddress)\n      revert AssetLogic__getTokenIndexFromStableSwapPool_notExist();\n    return index;\n  }\n\n  // ============ Internal: Handle Swap ============\n\n  /**\n   * @notice Swaps an adopted asset to the local (representation or canonical) asset.\n   * @dev Will not swap if the asset passed in is the local asset.\n   * @param _key - The hash of canonical id and domain.\n   * @param _asset - The address of the adopted asset to swap into the local asset.\n   * @param _amount - The amount of the adopted asset to swap.\n   * @param _slippage - The maximum amount of slippage user will take on from _amount in BPS.\n   * @return uint256 The amount of local asset received from swap.\n   */\n  function swapToLocalAssetIfNeeded(\n    bytes32 _key,\n    address _asset,\n    address _local,\n    uint256 _amount,\n    uint256 _slippage\n  ) internal returns (uint256) {\n    // If there's no amount, no need to swap.\n    if (_amount == 0) {\n      return 0;\n    }\n\n    // Check the case where the adopted asset *is* the local asset. If so, no need to swap.\n    if (_local == _asset) {\n      return _amount;\n    }\n\n    // Get the configs.\n    TokenConfig storage config = getConfig(_key);\n\n    // Swap the asset to the proper local asset.\n    (uint256 out, ) = _swapAsset(\n      _key,\n      _asset,\n      _local,\n      _amount,\n      calculateSlippageBoundary(config.adoptedDecimals, config.representationDecimals, _amount, _slippage)\n    );\n    return out;\n  }\n\n  /**\n   * @notice Swaps a local bridge asset for the adopted asset using the stored stable swap\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _key the hash of the canonical id and domain\n   * @param _asset - The address of the local asset to swap into the adopted asset\n   * @param _amount - The amount of the local asset to swap\n   * @param _slippage - The minimum amount of slippage user will take on from _amount in BPS\n   * @param _normalizedIn - The amount sent in on xcall to take the slippage from, in 18 decimals\n   * by convention\n   * @return The amount of adopted asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function swapFromLocalAssetIfNeeded(\n    bytes32 _key,\n    address _asset,\n    uint256 _amount,\n    uint256 _slippage,\n    uint256 _normalizedIn\n  ) internal returns (uint256, address) {\n    // Get the token config.\n    TokenConfig storage config = getConfig(_key);\n    address adopted = config.adopted;\n\n    // If the adopted asset is the local asset, no need to swap.\n    if (adopted == _asset) {\n      return (_amount, adopted);\n    }\n\n    // If there's no amount, no need to swap.\n    if (_amount == 0) {\n      return (_amount, adopted);\n    }\n\n    // Swap the asset to the proper local asset\n    return\n      _swapAsset(\n        _key,\n        _asset,\n        adopted,\n        _amount,\n        // NOTE: To get the slippage boundary here, you must take the slippage % off of the\n        // normalized amount in (at 18 decimals by convention), then convert that amount\n        // to the proper decimals of adopted.\n        calculateSlippageBoundary(\n          Constants.DEFAULT_NORMALIZED_DECIMALS,\n          config.adoptedDecimals,\n          _normalizedIn,\n          _slippage\n        )\n      );\n  }\n\n  /**\n   * @notice Swaps a local bridge asset for the adopted asset using the stored stable swap\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _key the hash of the canonical id and domain\n   * @param _asset - The address of the local asset to swap into the adopted asset\n   * @param _amount - The exact amount to receive out of the swap\n   * @param _maxIn - The most you will supply to the swap\n   * @return The amount of local asset put into  swap\n   * @return The address of asset received post-swap\n   */\n  function swapFromLocalAssetIfNeededForExactOut(\n    bytes32 _key,\n    address _asset,\n    uint256 _amount,\n    uint256 _maxIn\n  ) internal returns (uint256, address) {\n    TokenConfig storage config = getConfig(_key);\n\n    // If the adopted asset is the local asset, no need to swap.\n    address adopted = config.adopted;\n    if (adopted == _asset) {\n      return (_amount, adopted);\n    }\n\n    return _swapAssetOut(_key, _asset, adopted, _amount, _maxIn);\n  }\n\n  /**\n   * @notice Swaps assetIn to assetOut using the stored stable swap or internal swap pool.\n   * @dev Will not swap if the asset passed in is the adopted asset\n   * @param _key - The hash of canonical id and domain.\n   * @param _assetIn - The address of the from asset\n   * @param _assetOut - The address of the to asset\n   * @param _amount - The amount of the local asset to swap\n   * @param _minOut - The minimum amount of `_assetOut` the user will accept\n   * @return The amount of asset received\n   * @return The address of asset received\n   */\n  function _swapAsset(\n    bytes32 _key,\n    address _assetIn,\n    address _assetOut,\n    uint256 _amount,\n    uint256 _minOut\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Retrieve internal swap pool reference.\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\n\n    if (ipool.exists()) {\n      // Swap via the internal pool.\n      return (\n        ipool.swapInternal(\n          getTokenIndexFromStableSwapPool(_key, _assetIn),\n          getTokenIndexFromStableSwapPool(_key, _assetOut),\n          _amount,\n          _minOut\n        ),\n        _assetOut\n      );\n    } else {\n      // Otherwise, swap via external stableswap pool.\n      IStableSwap pool = IStableSwap(getConfig(_key).adoptedToLocalExternalPools);\n\n      IERC20Metadata assetIn = IERC20Metadata(_assetIn);\n\n      assetIn.safeApprove(address(pool), 0);\n      assetIn.safeIncreaseAllowance(address(pool), _amount);\n\n      // NOTE: If pool is not registered here, then this call will revert.\n      return (\n        pool.swapExact(_amount, _assetIn, _assetOut, _minOut, block.timestamp + Constants.DEFAULT_DEADLINE_EXTENSION),\n        _assetOut\n      );\n    }\n  }\n\n  /**\n   * @notice Swaps assetIn to assetOut using the stored stable swap or internal swap pool.\n   * @param _key - The hash of the canonical id and domain.\n   * @param _assetIn - The address of the from asset.\n   * @param _assetOut - The address of the to asset.\n   * @param _amountOut - The amount of the _assetOut to swap.\n   * @param _maxIn - The most you will supply to the swap.\n   * @return amountIn The amount of assetIn. Will be 0 if the swap was unsuccessful (slippage\n   * too high).\n   * @return assetOut The address of asset received.\n   */\n  function _swapAssetOut(\n    bytes32 _key,\n    address _assetIn,\n    address _assetOut,\n    uint256 _amountOut,\n    uint256 _maxIn\n  ) internal returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // Retrieve internal swap pool reference. If it doesn't exist, we'll resort to using an\n    // external stableswap below.\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\n\n    // Swap the asset to the proper local asset.\n    // NOTE: IFF slippage was too high to perform swap in either case: success = false, amountIn = 0\n    if (ipool.exists()) {\n      // Swap via the internal pool.\n      return (\n        ipool.swapInternalOut(\n          getTokenIndexFromStableSwapPool(_key, _assetIn),\n          getTokenIndexFromStableSwapPool(_key, _assetOut),\n          _amountOut,\n          _maxIn\n        ),\n        _assetOut\n      );\n    } else {\n      // Otherwise, swap via external stableswap pool.\n      // NOTE: This call will revert if the external stableswap pool doesn't exist.\n      IStableSwap pool = IStableSwap(getConfig(_key).adoptedToLocalExternalPools);\n      address poolAddress = address(pool);\n\n      // Perform the swap.\n      // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call\n      // there could be a remaining allowance if not the whole amount is pulled by aave.\n      // Later, if we try to increase the allowance it will fail. USDT demands if allowance\n      // is not 0, it has to be set to 0 first.\n      // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\n      IERC20Metadata assetIn = IERC20Metadata(_assetIn);\n\n      assetIn.safeApprove(poolAddress, 0);\n      assetIn.safeIncreaseAllowance(poolAddress, _maxIn);\n\n      uint256 out = pool.swapExactOut(\n        _amountOut,\n        _assetIn,\n        _assetOut,\n        _maxIn,\n        block.timestamp + Constants.DEFAULT_DEADLINE_EXTENSION\n      );\n\n      // Reset allowance\n      assetIn.safeApprove(poolAddress, 0);\n      return (out, _assetOut);\n    }\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on a local bridge asset for the adopted asset\n   * using the stored stable swap\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\n   * @param _key - The hash of the canonical id and domain\n   * @param _asset - The address of the local asset to swap into the local asset\n   * @param _amount - The amount of the local asset to swap\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function calculateSwapFromLocalAssetIfNeeded(\n    bytes32 _key,\n    address _asset,\n    uint256 _amount\n  ) internal view returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // If the adopted asset is the local asset, no need to swap.\n    TokenConfig storage config = getConfig(_key);\n    address adopted = config.adopted;\n    if (adopted == _asset) {\n      return (_amount, adopted);\n    }\n\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\n\n    // Calculate the swap using the appropriate pool.\n    if (ipool.exists()) {\n      // Calculate with internal swap pool.\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_key, _asset);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_key, adopted);\n      return (ipool.calculateSwap(tokenIndexIn, tokenIndexOut, _amount), adopted);\n    } else {\n      // Otherwise, try to calculate with external pool.\n      IStableSwap pool = IStableSwap(config.adoptedToLocalExternalPools);\n      // NOTE: This call will revert if no external pool exists.\n      return (pool.calculateSwapFromAddress(_asset, adopted, _amount), adopted);\n    }\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive of a local bridge asset for the adopted asset\n   * using the stored stable swap\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\n   * @param _asset - The address of the asset to swap into the local asset\n   * @param _amount - The amount of the asset to swap\n   * @return The amount of local asset received from swap\n   * @return The address of asset received post-swap\n   */\n  function calculateSwapToLocalAssetIfNeeded(\n    bytes32 _key,\n    address _asset,\n    address _local,\n    uint256 _amount\n  ) internal view returns (uint256, address) {\n    AppStorage storage s = LibConnextStorage.connextStorage();\n\n    // If the asset is the local asset, no swap needed\n    if (_asset == _local) {\n      return (_amount, _local);\n    }\n\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\n\n    // Calculate the swap using the appropriate pool.\n    if (ipool.exists()) {\n      // if internal swap pool exists\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_key, _asset);\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_key, _local);\n      return (ipool.calculateSwap(tokenIndexIn, tokenIndexOut, _amount), _local);\n    } else {\n      IStableSwap pool = IStableSwap(getConfig(_key).adoptedToLocalExternalPools);\n\n      return (pool.calculateSwapFromAddress(_asset, _local, _amount), _local);\n    }\n  }\n\n  // ============ Internal: Token ID Helpers ============\n\n  /**\n   * @notice Gets the canonical information for a given candidate.\n   * @dev First checks the `address(0)` convention, then checks if the asset given is the\n   * adopted asset, then calculates the local address.\n   * @return TokenId The canonical token ID information for the given candidate.\n   */\n  function getCanonicalTokenId(address _candidate, AppStorage storage s) internal view returns (TokenId memory) {\n    TokenId memory _canonical;\n    // If candidate is address(0), return an empty `_canonical`.\n    if (_candidate == address(0)) {\n      return _canonical;\n    }\n\n    // Check to see if candidate is an adopted asset.\n    _canonical = s.adoptedToCanonical[_candidate];\n    if (_canonical.domain != 0) {\n      // Candidate is an adopted asset, return canonical info.\n      return _canonical;\n    }\n\n    // Candidate was not adopted; it could be the local address.\n    // IFF this domain is the canonical domain, then the local == canonical.\n    // Otherwise, it will be the representation asset.\n    if (isLocalOrigin(_candidate, s)) {\n      // The token originates on this domain, canonical information is the information\n      // of the candidate\n      _canonical.domain = s.domain;\n      _canonical.id = TypeCasts.addressToBytes32(_candidate);\n    } else {\n      // on a remote domain, return the representation\n      _canonical = s.representationToCanonical[_candidate];\n    }\n    return _canonical;\n  }\n\n  /**\n   * @notice Determine if token is of local origin (i.e. it is a locally originating contract,\n   * and NOT a token deployed by the bridge).\n   * @param s AppStorage instance.\n   * @return bool true if token is locally originating, false otherwise.\n   */\n  function isLocalOrigin(address _token, AppStorage storage s) internal view returns (bool) {\n    // If the token contract WAS deployed by the bridge, it will be stored in this mapping.\n    // If so, the token is NOT of local origin.\n    if (s.representationToCanonical[_token].domain != 0) {\n      return false;\n    }\n    // If the contract was NOT deployed by the bridge, but the contract does exist, then it\n    // IS of local origin. Returns true if code exists at `_addr`.\n    return _token.code.length != 0;\n  }\n\n  /**\n   * @notice Get the local asset address for a given canonical key, id, and domain.\n   * @param _key - The hash of canonical id and domain.\n   * @param _id Canonical ID.\n   * @param _domain Canonical domain.\n   * @param s AppStorage instance.\n   * @return address of the the local asset.\n   */\n  function getLocalAsset(\n    bytes32 _key,\n    bytes32 _id,\n    uint32 _domain,\n    AppStorage storage s\n  ) internal view returns (address) {\n    if (_domain == s.domain) {\n      // Token is of local origin\n      return TypeCasts.bytes32ToAddress(_id);\n    } else {\n      // Token is a representation of a token of remote origin\n      return getConfig(_key).representation;\n    }\n  }\n\n  /**\n   * @notice Calculates the hash of canonical ID and domain.\n   * @dev This hash is used as the key for many asset-related mappings.\n   * @param _id Canonical ID.\n   * @param _domain Canonical domain.\n   * @return bytes32 Canonical hash, used as key for accessing token info from mappings.\n   */\n  function calculateCanonicalHash(bytes32 _id, uint32 _domain) internal pure returns (bytes32) {\n    return keccak256(abi.encode(_id, _domain));\n  }\n\n  // ============ Internal: Math ============\n\n  /**\n   * @notice This function calculates slippage as a %age of the amount in, and normalizes\n   * That to the `_out` decimals.\n   *\n   * @dev This *ONLY* works for 1:1 assets\n   *\n   * @param _in The decimals of the asset in / amount in\n   * @param _out The decimals of the target asset\n   * @param _amountIn The starting amount for the swap\n   * @param _slippage The slippage allowed for the swap, in BPS\n   * @return uint256 The minimum amount out for the swap\n   */\n  function calculateSlippageBoundary(\n    uint8 _in,\n    uint8 _out,\n    uint256 _amountIn,\n    uint256 _slippage\n  ) internal pure returns (uint256) {\n    if (_amountIn == 0) {\n      return 0;\n    }\n    // Get the min recieved (in same decimals as _amountIn)\n    uint256 min = (_amountIn * (Constants.BPS_FEE_DENOMINATOR - _slippage)) / Constants.BPS_FEE_DENOMINATOR;\n    return normalizeDecimals(_in, _out, min);\n  }\n\n  /**\n   * @notice This function translates the _amount in _in decimals\n   * to _out decimals\n   *\n   * @param _in The decimals of the asset in / amount in\n   * @param _out The decimals of the target asset\n   * @param _amount The value to normalize to the `_out` decimals\n   * @return uint256 Normalized decimals.\n   */\n  function normalizeDecimals(\n    uint8 _in,\n    uint8 _out,\n    uint256 _amount\n  ) internal pure returns (uint256) {\n    if (_in == _out) {\n      return _amount;\n    }\n    // Convert this value to the same decimals as _out\n    uint256 normalized;\n    if (_in < _out) {\n      normalized = _amount * (10**(_out - _in));\n    } else {\n      normalized = _amount / (10**(_in - _out));\n    }\n    return normalized;\n  }\n}\n"
    },
    "contracts/core/connext/libraries/TokenId.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// ============= Structs =============\n\n// Tokens are identified by a TokenId:\n// domain - 4 byte chain ID of the chain from which the token originates\n// id - 32 byte identifier of the token address on the origin chain, in that chain's address format\nstruct TokenId {\n  uint32 domain;\n  bytes32 id;\n}\n"
    },
    "contracts/core/connext/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nlibrary Constants {\n  // ============= Initial Values =============\n\n  /**\n   * @notice Sets the initial lp fee at 5 bps\n   */\n  uint256 public constant INITIAL_LIQUIDITY_FEE_NUMERATOR = 9_995;\n\n  /**\n   * @notice Sets the initial max routers per transfer\n   */\n  uint256 public constant INITIAL_MAX_ROUTERS = 5;\n\n  /**\n   * @notice Sets the initial max routers per transfer\n   */\n  uint16 public constant INITIAL_AAVE_REFERRAL_CODE = 0;\n\n  // =============\n\n  // ============= Unchangeable Values =============\n  // ============= Facets\n\n  /**\n   * @notice Reentrancy modifier for diamond\n   */\n  uint256 internal constant NOT_ENTERED = 1;\n\n  /**\n   * @notice Reentrancy modifier for diamond\n   */\n  uint256 internal constant ENTERED = 2;\n\n  /**\n   * @notice Contains hash of empty bytes\n   */\n  bytes32 internal constant EMPTY_HASH = keccak256(\"\");\n\n  /**\n   * @notice Denominator for BPS values\n   */\n  uint256 public constant BPS_FEE_DENOMINATOR = 10_000;\n\n  /**\n   * @notice Value for delay used on governance\n   */\n  uint256 public constant GOVERNANCE_DELAY = 7 days;\n\n  /**\n   * @notice Required gas amount to be leftover after passing in `gasleft` when\n   * executing calldata (see `_executeCalldata` method).\n   */\n  uint256 public constant EXECUTE_CALLDATA_RESERVE_GAS = 10_000;\n\n  /**\n   * @notice Portal referral code\n   */\n  uint16 public constant AAVE_REFERRAL_CODE = 0;\n\n  // ============= ConnextPriceOracle\n  /**\n   * @notice Valid period for a price delivered by the price oracle\n   */\n  uint256 public constant ORACLE_VALID_PERIOD = 1 minutes;\n\n  /**\n   * @notice Valid wiggle room for future timestamps (3s) used by `setDirectPrice`\n   */\n  uint256 public constant FUTURE_TIME_BUFFER = 3;\n\n  /**\n   * @notice Defalt decimals values are normalized to\n   */\n  uint8 public constant DEFAULT_NORMALIZED_DECIMALS = uint8(18);\n\n  /**\n   * @notice Bytes of return data copied back when using `excessivelySafeCall`\n   */\n  uint16 public constant DEFAULT_COPY_BYTES = 256;\n\n  /**\n   * @notice Valid deadline extension used when swapping (1hr)\n   */\n  uint256 public constant DEFAULT_DEADLINE_EXTENSION = 3600;\n\n  // ============= Swaps\n  /**\n   * @notice the precision all pools tokens will be converted to\n   * @dev stored here to keep easily in sync between `SwapUtils` and `SwapUtilsExternal`\n   *\n   * The minimum in a pool is 2 (nextUSDC, USDC), and the maximum allowed is 16. While\n   * we do not have pools supporting this number of token, allowing a larger value leaves\n   * the possibility open to pool multiple stable local/adopted pairs, garnering greater\n   * capital efficiency. 16 specifically was chosen as a bit of a sweet spot between the\n   * default of 32 and what we will realistically host in pools.\n   */\n  uint256 public constant MINIMUM_POOLED_TOKENS = 2;\n  uint256 public constant MAXIMUM_POOLED_TOKENS = 16;\n\n  /**\n   * @notice the precision all pools tokens will be converted to\n   * @dev stored here to keep easily in sync between `SwapUtils` and `SwapUtilsExternal`\n   */\n  uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n  /**\n   * @notice the denominator used to calculate admin and LP fees. For example, an\n   * LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n   * @dev stored here to keep easily in sync between `SwapUtils` and `SwapUtilsExternal`\n   */\n  uint256 public constant FEE_DENOMINATOR = 1e10;\n\n  /**\n   * @notice Max swap fee is 1% or 100bps of each swap\n   * @dev stored here to keep easily in sync between `SwapUtils` and `SwapUtilsExternal`\n   */\n  uint256 public constant MAX_SWAP_FEE = 1e8;\n\n  /**\n   * @notice Max adminFee is 100% of the swapFee. adminFee does not add additional fee on top of swapFee.\n   * Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n   * users but only on the earnings of LPs\n   * @dev stored here to keep easily in sync between `SwapUtils` and `SwapUtilsExternal`\n   */\n  uint256 public constant MAX_ADMIN_FEE = 1e10;\n\n  /**\n   * @notice constant value used as max loop limit\n   * @dev stored here to keep easily in sync between `SwapUtils` and `SwapUtilsExternal`\n   */\n  uint256 public constant MAX_LOOP_LIMIT = 256;\n\n  // Constant value used as max delay time for removing swap after disabled\n  uint256 internal constant REMOVE_DELAY = 7 days;\n\n  /**\n   * @notice constant values used in ramping A calculations\n   * @dev stored here to keep easily in sync between `SwapUtils` and `SwapUtilsExternal`\n   */\n  uint256 public constant A_PRECISION = 100;\n  uint256 public constant MAX_A = 10**6;\n  uint256 public constant MAX_A_CHANGE = 2;\n  uint256 public constant MIN_RAMP_TIME = 14 days;\n  uint256 public constant MIN_RAMP_DELAY = 1 days;\n}\n"
    },
    "contracts/core/connext/interfaces/IStableSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStableSwap {\n  /*** EVENTS ***/\n\n  // events replicated from SwapUtils to make the ABI easier for dumb\n  // clients\n  event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n  event AddLiquidity(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(uint256 newAdminFee);\n  event NewSwapFee(uint256 newSwapFee);\n  event NewWithdrawFee(uint256 newWithdrawFee);\n  event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n  event StopRampA(uint256 currentA, uint256 time);\n\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function swapExact(\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function swapExactOut(\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function getA() external view returns (uint256);\n\n  function getToken(uint8 index) external view returns (IERC20);\n\n  function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n  function getTokenBalance(uint8 index) external view returns (uint256);\n\n  function getVirtualPrice() external view returns (uint256);\n\n  // min return calculation functions\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateSwapOut(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy\n  ) external view returns (uint256);\n\n  function calculateSwapFromAddress(\n    address assetIn,\n    address assetOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function calculateSwapOutFromAddress(\n    address assetIn,\n    address assetOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n\n  function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view returns (uint256);\n\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\n\n  function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    returns (uint256 availableTokenAmount);\n\n  // state modifying functions\n  function initialize(\n    IERC20[] memory pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 a,\n    uint256 fee,\n    uint256 adminFee,\n    address lpTokenTargetAddress\n  ) external;\n\n  function addLiquidity(\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityImbalance(\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n}\n"
    },
    "contracts/messaging/interfaces/IConnectorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IOutbox} from \"./IOutbox.sol\";\n\n/**\n * @notice Each router extends the `XAppConnectionClient` contract. This contract\n * allows an admin to call `setXAppConnectionManager` to update the underlying\n * pointers to the messaging inboxes (Replicas) and outboxes (Homes).\n *\n * @dev This interface only contains the functions needed for the `XAppConnectionClient`\n * will interface with.\n */\ninterface IConnectorManager {\n  /**\n   * @notice Get the local inbox contract from the xAppConnectionManager\n   * @return The local inbox contract\n   * @dev The local inbox contract is a SpokeConnector with AMBs, and a\n   * Home contract with nomad\n   */\n  function home() external view returns (IOutbox);\n\n  /**\n   * @notice Determine whether _potentialReplica is an enrolled Replica from the xAppConnectionManager\n   * @return True if _potentialReplica is an enrolled Replica\n   */\n  function isReplica(address _potentialReplica) external view returns (bool);\n\n  /**\n   * @notice Get the local domain from the xAppConnectionManager\n   * @return The local domain\n   */\n  function localDomain() external view returns (uint32);\n}\n"
    },
    "contracts/core/connext/libraries/SwapUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LPToken} from \"../helpers/LPToken.sol\";\n\nimport {AmplificationUtils} from \"./AmplificationUtils.sol\";\nimport {MathUtils} from \"./MathUtils.sol\";\nimport {AssetLogic} from \"./AssetLogic.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * @title SwapUtils library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtils {\n  using SafeERC20 for IERC20;\n  using MathUtils for uint256;\n\n  /*** EVENTS ***/\n\n  event TokenSwap(\n    bytes32 indexed key,\n    address indexed buyer,\n    uint256 tokensSold,\n    uint256 tokensBought,\n    uint128 soldId,\n    uint128 boughtId\n  );\n  event AddLiquidity(\n    bytes32 indexed key,\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(bytes32 indexed key, address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    bytes32 indexed key,\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    bytes32 indexed key,\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(bytes32 indexed key, uint256 newAdminFee);\n  event NewSwapFee(bytes32 indexed key, uint256 newSwapFee);\n\n  struct Swap {\n    // variables around the ramp management of A,\n    // the amplification coefficient * n ** (n - 1)\n    // see Curve stableswap paper for details\n    bytes32 key;\n    uint256 initialA;\n    uint256 futureA;\n    uint256 initialATime;\n    uint256 futureATime;\n    // fee calculation\n    uint256 swapFee;\n    uint256 adminFee;\n    LPToken lpToken;\n    // contract references for all tokens being pooled\n    IERC20[] pooledTokens;\n    // multipliers for each pooled token's precision to get to Constants.POOL_PRECISION_DECIMALS\n    // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n    // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n    uint256[] tokenPrecisionMultipliers;\n    // the pool balance of each token, in the token's precision\n    // the contract's actual token balance might differ\n    uint256[] balances;\n    // the admin fee balance of each token, in the token's precision\n    uint256[] adminFees;\n    // the flag if this pool disabled by admin. once disabled, only remove liquidity will work.\n    bool disabled;\n    // once pool disabled, admin can remove pool after passed removeTime. and reinitialize.\n    uint256 removeTime;\n  }\n\n  // Struct storing variables used in calculations in the\n  // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n  struct CalculateWithdrawOneTokenDYInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 newY;\n    uint256 feePerToken;\n    uint256 preciseA;\n  }\n\n  // Struct storing variables used in calculations in the\n  // {add,remove}Liquidity functions to avoid stack too deep errors\n  struct ManageLiquidityInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 d2;\n    uint256 preciseA;\n    LPToken lpToken;\n    uint256 totalSupply;\n    uint256[] balances;\n    uint256[] multipliers;\n  }\n\n  /*** VIEW & PURE FUNCTIONS ***/\n\n  function _getAPrecise(Swap storage self) private view returns (uint256) {\n    return AmplificationUtils._getAPrecise(self);\n  }\n\n  /**\n   * @notice Calculate the dy, the amount of selected token that user receives and\n   * the fee of withdrawing in one token\n   * @param tokenAmount the amount to withdraw in the pool's precision\n   * @param tokenIndex which token will be withdrawn\n   * @param self Swap struct to read from\n   * @return the amount of token user will receive\n   */\n  function calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) internal view returns (uint256) {\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n      self,\n      tokenAmount,\n      tokenIndex,\n      self.lpToken.totalSupply()\n    );\n    return availableTokenAmount;\n  }\n\n  function _calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 totalSupply\n  ) private view returns (uint256, uint256) {\n    uint256 dy;\n    uint256 newY;\n    uint256 currentY;\n\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\n\n    // dy_0 (without fees)\n    // dy, dy_0 - dy\n\n    uint256 dySwapFee = (currentY - newY) / self.tokenPrecisionMultipliers[tokenIndex] - dy;\n\n    return (dy, dySwapFee);\n  }\n\n  /**\n   * @notice Calculate the dy of withdrawing in one token\n   * @param self Swap struct to read from\n   * @param tokenIndex which token will be withdrawn\n   * @param tokenAmount the amount to withdraw in the pools precision\n   * @return the d and the new y after withdrawing one token\n   */\n  function calculateWithdrawOneTokenDY(\n    Swap storage self,\n    uint8 tokenIndex,\n    uint256 tokenAmount,\n    uint256 totalSupply\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    // Get the current D, then solve the stableswap invariant\n    // y_i for D - tokenAmount\n    uint256[] memory xp = _xp(self);\n\n    require(tokenIndex < xp.length, \"index out of range\");\n\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n    v.preciseA = _getAPrecise(self);\n    v.d0 = getD(xp, v.preciseA);\n    v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\n\n    require(tokenAmount <= xp[tokenIndex], \"exceeds available\");\n\n    v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n    uint256[] memory xpReduced = new uint256[](xp.length);\n\n    v.feePerToken = _feePerToken(self.swapFee, xp.length);\n    // TODO: Set a length variable (at top) instead of reading xp.length on each loop.\n    uint256 len = xp.length;\n    for (uint256 i; i < len; ) {\n      uint256 xpi = xp[i];\n      // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n      // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n      // xpReduced[i] -= dxExpected * fee / Constants.FEE_DENOMINATOR\n      xpReduced[i] =\n        xpi -\n        ((((i == tokenIndex) ? ((xpi * v.d1) / v.d0 - v.newY) : (xpi - (xpi * v.d1) / v.d0)) * v.feePerToken) /\n          Constants.FEE_DENOMINATOR);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    uint256 dy = xpReduced[tokenIndex] - getYD(v.preciseA, tokenIndex, xpReduced, v.d1);\n    dy = (dy - 1) / (self.tokenPrecisionMultipliers[tokenIndex]);\n\n    return (dy, v.newY, xp[tokenIndex]);\n  }\n\n  /**\n   * @notice Calculate the price of a token in the pool with given\n   * precision-adjusted balances and a particular D.\n   *\n   * @dev This is accomplished via solving the invariant iteratively.\n   * See the StableSwap paper and Curve.fi implementation for further details.\n   *\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n   * x_1**2 + b*x_1 = c\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\n   *\n   * @param a the amplification coefficient * n ** (n - 1). See the StableSwap paper for details.\n   * @param tokenIndex Index of token we are calculating for.\n   * @param xp a precision-adjusted set of pool balances. Array should be\n   * the same cardinality as the pool.\n   * @param d the stableswap invariant\n   * @return the price of the token, in the same precision as in xp\n   */\n  function getYD(\n    uint256 a,\n    uint8 tokenIndex,\n    uint256[] memory xp,\n    uint256 d\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndex < numTokens, \"Token not found\");\n\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = a * numTokens;\n\n    for (uint256 i; i < numTokens; ) {\n      if (i != tokenIndex) {\n        s += xp[i];\n        c = (c * d) / (xp[i] * numTokens);\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // c = c * D * D * D * ... overflow!\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    c = (c * d * Constants.A_PRECISION) / (nA * numTokens);\n\n    uint256 b = s + ((d * Constants.A_PRECISION) / nA);\n    uint256 yPrev;\n    // Select d as the starting point of the Newton method. Because y < D\n    // D is the best option as the starting point in case the pool is very imbalanced.\n    uint256 y = d;\n    for (uint256 i; i < Constants.MAX_LOOP_LIMIT; ) {\n      yPrev = y;\n      y = ((y * y) + c) / ((y * 2) + b - d);\n      if (y.within1(yPrev)) {\n        return y;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n   * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n   * as the pool.\n   * @param a the amplification coefficient * n ** (n - 1) in A_PRECISION.\n   * See the StableSwap paper for details\n   * @return the invariant, at the precision of the pool\n   */\n  function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    uint256 s;\n    for (uint256 i; i < numTokens; ) {\n      s += xp[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n    if (s == 0) {\n      return 0;\n    }\n\n    uint256 prevD;\n    uint256 d = s;\n    uint256 nA = a * numTokens;\n\n    for (uint256 i; i < Constants.MAX_LOOP_LIMIT; ) {\n      uint256 dP = d;\n      for (uint256 j; j < numTokens; ) {\n        dP = (dP * d) / (xp[j] * numTokens);\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // dP = dP * D * D * D * ... overflow!\n\n        unchecked {\n          ++j;\n        }\n      }\n      prevD = d;\n      d =\n        (((nA * s) / Constants.A_PRECISION + dP * numTokens) * d) /\n        ((((nA - Constants.A_PRECISION) * d) / Constants.A_PRECISION + (numTokens + 1) * dP));\n      if (d.within1(prevD)) {\n        return d;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    revert(\"D does not converge\");\n  }\n\n  /**\n   * @notice Given a set of balances and precision multipliers, return the\n   * precision-adjusted balances.\n   *\n   * @param balances an array of token balances, in their native precisions.\n   * These should generally correspond with pooled tokens.\n   *\n   * @param precisionMultipliers an array of multipliers, corresponding to\n   * the amounts in the balances array. When multiplied together they\n   * should yield amounts at the pool's precision.\n   *\n   * @return an array of amounts \"scaled\" to the pool's precision\n   */\n  function _xp(uint256[] memory balances, uint256[] memory precisionMultipliers)\n    internal\n    pure\n    returns (uint256[] memory)\n  {\n    uint256 numTokens = balances.length;\n    require(numTokens == precisionMultipliers.length, \"mismatch multipliers\");\n    uint256[] memory xp = new uint256[](numTokens);\n    for (uint256 i; i < numTokens; ) {\n      xp[i] = balances[i] * precisionMultipliers[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n    return xp;\n  }\n\n  /**\n   * @notice Return the precision-adjusted balances of all tokens in the pool\n   * @param self Swap struct to read from\n   * @return the pool balances \"scaled\" to the pool's precision, allowing\n   * them to be more easily compared.\n   */\n  function _xp(Swap storage self) internal view returns (uint256[] memory) {\n    return _xp(self.balances, self.tokenPrecisionMultipliers);\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param self Swap struct to read from\n   * @return the virtual price, scaled to precision of Constants.POOL_PRECISION_DECIMALS\n   */\n  function getVirtualPrice(Swap storage self) internal view returns (uint256) {\n    uint256 d = getD(_xp(self), _getAPrecise(self));\n    LPToken lpToken = self.lpToken;\n    uint256 supply = lpToken.totalSupply();\n    if (supply != 0) {\n      return (d * (10**uint256(Constants.POOL_PRECISION_DECIMALS))) / supply;\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Calculate the new balances of the tokens given the indexes of the token\n   * that is swapped from (FROM) and the token that is swapped to (TO).\n   * This function is used as a helper function to calculate how much TO token\n   * the user should receive on swap.\n   *\n   * @param preciseA precise form of amplification coefficient\n   * @param tokenIndexFrom index of FROM token\n   * @param tokenIndexTo index of TO token\n   * @param x the new total amount of FROM token\n   * @param xp balances of the tokens in the pool\n   * @return the amount of TO token that should remain in the pool\n   */\n  function getY(\n    uint256 preciseA,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 x,\n    uint256[] memory xp\n  ) internal pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndexFrom != tokenIndexTo, \"compare token to itself\");\n    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"token not found\");\n\n    uint256 d = getD(xp, preciseA);\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = numTokens * preciseA;\n\n    uint256 _x;\n    for (uint256 i; i < numTokens; ) {\n      if (i == tokenIndexFrom) {\n        _x = x;\n      } else if (i != tokenIndexTo) {\n        _x = xp[i];\n      } else {\n        unchecked {\n          ++i;\n        }\n        continue;\n      }\n      s += _x;\n      c = (c * d) / (_x * numTokens);\n      // If we were to protect the division loss we would have to keep the denominator separate\n      // and divide at the end. However this leads to overflow with large numTokens or/and D.\n      // c = c * D * D * D * ... overflow!\n\n      unchecked {\n        ++i;\n      }\n    }\n    c = (c * d * Constants.A_PRECISION) / (nA * numTokens);\n    uint256 b = s + ((d * Constants.A_PRECISION) / nA);\n    uint256 yPrev;\n    uint256 y = d;\n\n    // iterative approximation\n    for (uint256 i; i < Constants.MAX_LOOP_LIMIT; ) {\n      yPrev = y;\n      y = ((y * y) + c) / ((y * 2) + b - d);\n      if (y.within1(yPrev)) {\n        return y;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   */\n  function calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) internal view returns (uint256 dy) {\n    (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy.\n   * @return dx the number of tokens the user have to transfer + fee\n   */\n  function calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy\n  ) internal view returns (uint256 dx) {\n    (dx, ) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, self.balances);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get in the token's precision. ex WBTC -> 8\n   * @return dyFee the associated fee in multiplied precision (Constants.POOL_PRECISION_DECIMALS)\n   */\n  function _calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256[] memory balances\n  ) internal view returns (uint256 dy, uint256 dyFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"index out of range\");\n    uint256 x = dx * multipliers[tokenIndexFrom] + xp[tokenIndexFrom];\n    uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n    dy = xp[tokenIndexTo] - y - 1;\n    dyFee = (dy * self.swapFee) / Constants.FEE_DENOMINATOR;\n    dy = (dy - dyFee) / multipliers[tokenIndexTo];\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dx the number of tokens the user have to deposit in the token's precision. ex WBTC -> 8\n   * @return dxFee the associated fee in multiplied precision (Constants.POOL_PRECISION_DECIMALS)\n   */\n  function _calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256[] memory balances\n  ) internal view returns (uint256 dx, uint256 dxFee) {\n    require(tokenIndexFrom != tokenIndexTo, \"compare token to itself\");\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"index out of range\");\n\n    uint256 a = _getAPrecise(self);\n    uint256 d0 = getD(xp, a);\n\n    xp[tokenIndexTo] = xp[tokenIndexTo] - (dy * multipliers[tokenIndexTo]);\n    uint256 x = getYD(a, tokenIndexFrom, xp, d0);\n    dx = (x + 1) - xp[tokenIndexFrom];\n    dxFee = (dx * self.swapFee) / Constants.FEE_DENOMINATOR;\n    dx = (dx + dxFee) / multipliers[tokenIndexFrom];\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of\n   * LP tokens\n   *\n   * @param amount the amount of LP tokens that would to be burned on\n   * withdrawal\n   * @return array of amounts of tokens user will receive\n   */\n  function calculateRemoveLiquidity(Swap storage self, uint256 amount) internal view returns (uint256[] memory) {\n    return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\n  }\n\n  function _calculateRemoveLiquidity(\n    uint256[] memory balances,\n    uint256 amount,\n    uint256 totalSupply\n  ) internal pure returns (uint256[] memory) {\n    require(amount <= totalSupply, \"exceed total supply\");\n\n    uint256 numBalances = balances.length;\n    uint256[] memory amounts = new uint256[](numBalances);\n\n    for (uint256 i; i < numBalances; ) {\n      amounts[i] = (balances[i] * amount) / totalSupply;\n\n      unchecked {\n        ++i;\n      }\n    }\n    return amounts;\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param self Swap struct to read from\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return if deposit was true, total amount of lp token that will be minted and if\n   * deposit was false, total amount of lp token that will be burned\n   */\n  function calculateTokenAmount(\n    Swap storage self,\n    uint256[] calldata amounts,\n    bool deposit\n  ) internal view returns (uint256) {\n    uint256[] memory balances = self.balances;\n    uint256 numBalances = balances.length;\n    require(amounts.length == numBalances, \"invalid length of amounts\");\n\n    uint256 a = _getAPrecise(self);\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n    uint256 d0 = getD(_xp(balances, multipliers), a);\n    for (uint256 i; i < numBalances; ) {\n      if (deposit) {\n        balances[i] = balances[i] + amounts[i];\n      } else {\n        balances[i] = balances[i] - amounts[i];\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    uint256 d1 = getD(_xp(balances, multipliers), a);\n    uint256 totalSupply = self.lpToken.totalSupply();\n\n    if (deposit) {\n      return ((d1 - d0) * totalSupply) / d0;\n    } else {\n      return ((d0 - d1) * totalSupply) / d0;\n    }\n  }\n\n  /**\n   * @notice return accumulated amount of admin fees of the token with given index\n   * @param self Swap struct to read from\n   * @param index Index of the pooled token\n   * @return admin balance in the token's precision\n   */\n  function getAdminBalance(Swap storage self, uint256 index) internal view returns (uint256) {\n    require(index < self.pooledTokens.length, \"index out of range\");\n    return self.adminFees[index];\n  }\n\n  /**\n   * @notice internal helper function to calculate fee per token multiplier used in\n   * swap fee calculations\n   * @param swapFee swap fee for the tokens\n   * @param numTokens number of tokens pooled\n   */\n  function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\n    return (swapFee * numTokens) / ((numTokens - 1) * 4);\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    require(!self.disabled, \"disabled pool\");\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"swap more than you own\");\n      // Reverts for fee on transfer\n      AssetLogic.handleIncomingAsset(address(tokenFrom), dx);\n    }\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"dy < minDy\");\n\n    uint256 dyAdminFee = (dyFee * self.adminFee) /\n      Constants.FEE_DENOMINATOR /\n      self.tokenPrecisionMultipliers[tokenIndexTo];\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\n    if (dyAdminFee != 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo] + dyAdminFee;\n    }\n\n    AssetLogic.handleOutgoingAsset(address(self.pooledTokens[tokenIndexTo]), msg.sender, dy);\n\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dy the amount of tokens the user wants to buy\n   * @param maxDx the max amount the user would like to send.\n   * @return amount of token user have to transfer on swap\n   */\n  function swapOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(!self.disabled, \"disabled pool\");\n    require(dy <= self.balances[tokenIndexTo], \">pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"dx > maxDx\");\n\n    uint256 dxAdminFee = (dxFee * self.adminFee) /\n      Constants.FEE_DENOMINATOR /\n      self.tokenPrecisionMultipliers[tokenIndexFrom];\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx - dxAdminFee;\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy;\n    if (dxAdminFee != 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom] + dxAdminFee;\n    }\n\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"more than you own\");\n      // Reverts for fee on transfer\n      AssetLogic.handleIncomingAsset(address(tokenFrom), dx);\n    }\n\n    AssetLogic.handleOutgoingAsset(address(self.pooledTokens[tokenIndexTo]), msg.sender, dy);\n\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice swap two tokens in the pool internally\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swapInternal(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) internal returns (uint256) {\n    require(!self.disabled, \"disabled pool\");\n    require(dx <= self.balances[tokenIndexFrom], \"more than pool balance\");\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"dy < minDy\");\n\n    uint256 dyAdminFee = (dyFee * self.adminFee) /\n      Constants.FEE_DENOMINATOR /\n      self.tokenPrecisionMultipliers[tokenIndexTo];\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\n\n    if (dyAdminFee != 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo] + dyAdminFee;\n    }\n\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice Should get exact amount out of AMM for asset put in\n   */\n  function swapInternalOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) internal returns (uint256) {\n    require(!self.disabled, \"disabled pool\");\n    require(dy <= self.balances[tokenIndexTo], \"more than pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"dx > maxDx\");\n\n    uint256 dxAdminFee = (dxFee * self.adminFee) /\n      Constants.FEE_DENOMINATOR /\n      self.tokenPrecisionMultipliers[tokenIndexFrom];\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx - dxAdminFee;\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy;\n\n    if (dxAdminFee != 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom] + dxAdminFee;\n    }\n\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice Add liquidity to the pool\n   * @param self Swap struct to read from and write to\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n   * @return amount of LP token user received\n   */\n  function addLiquidity(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 minToMint\n  ) internal returns (uint256) {\n    require(!self.disabled, \"disabled pool\");\n\n    uint256 numTokens = self.pooledTokens.length;\n    require(amounts.length == numTokens, \"mismatch pooled tokens\");\n\n    // current state\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n    if (v.totalSupply != 0) {\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n    }\n\n    uint256[] memory newBalances = new uint256[](numTokens);\n\n    for (uint256 i; i < numTokens; ) {\n      require(v.totalSupply != 0 || amounts[i] != 0, \"!supply all tokens\");\n\n      // Transfer tokens first to see if a fee was charged on transfer\n      if (amounts[i] != 0) {\n        IERC20 token = self.pooledTokens[i];\n        // Reverts for fee on transfer\n        AssetLogic.handleIncomingAsset(address(token), amounts[i]);\n      }\n\n      newBalances[i] = v.balances[i] + amounts[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // invariant after change\n    v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    require(v.d1 > v.d0, \"D should increase\");\n\n    // updated to reflect fees and calculate the user's LP tokens\n    v.d2 = v.d1;\n    uint256[] memory fees = new uint256[](numTokens);\n\n    if (v.totalSupply != 0) {\n      uint256 feePerToken = _feePerToken(self.swapFee, numTokens);\n      for (uint256 i; i < numTokens; ) {\n        uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n        fees[i] = (feePerToken * (idealBalance.difference(newBalances[i]))) / Constants.FEE_DENOMINATOR;\n        uint256 adminFee = (fees[i] * self.adminFee) / Constants.FEE_DENOMINATOR;\n        self.balances[i] = newBalances[i] - adminFee;\n        self.adminFees[i] = self.adminFees[i] + adminFee;\n        newBalances[i] = newBalances[i] - fees[i];\n\n        unchecked {\n          ++i;\n        }\n      }\n      v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    } else {\n      // the initial depositor doesn't pay fees\n      self.balances = newBalances;\n    }\n\n    uint256 toMint;\n    if (v.totalSupply == 0) {\n      toMint = v.d1;\n    } else {\n      toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\n    }\n\n    require(toMint >= minToMint, \"mint < min\");\n\n    // mint the user's LP tokens\n    v.lpToken.mint(msg.sender, toMint);\n\n    emit AddLiquidity(self.key, msg.sender, amounts, fees, v.d1, v.totalSupply + toMint);\n\n    return toMint;\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param self Swap struct to read from and write to\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   * acceptable for this burn. Useful as a front-running mitigation\n   * @return amounts of tokens the user received\n   */\n  function removeLiquidity(\n    Swap storage self,\n    uint256 amount,\n    uint256[] calldata minAmounts\n  ) internal returns (uint256[] memory) {\n    LPToken lpToken = self.lpToken;\n    require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    uint256 numTokens = self.pooledTokens.length;\n    require(minAmounts.length == numTokens, \"mismatch poolTokens\");\n\n    uint256[] memory balances = self.balances;\n    uint256 totalSupply = lpToken.totalSupply();\n\n    uint256[] memory amounts = _calculateRemoveLiquidity(balances, amount, totalSupply);\n\n    uint256 numAmounts = amounts.length;\n    for (uint256 i; i < numAmounts; ) {\n      require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n      self.balances[i] = balances[i] - amounts[i];\n      AssetLogic.handleOutgoingAsset(address(self.pooledTokens[i]), msg.sender, amounts[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    lpToken.burnFrom(msg.sender, amount);\n\n    emit RemoveLiquidity(self.key, msg.sender, amounts, totalSupply - amount);\n\n    return amounts;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token.\n   * @param self Swap struct to read from and write to\n   * @param tokenAmount the amount of the lp tokens to burn\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @return amount chosen token that user received\n   */\n  function removeLiquidityOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount\n  ) internal returns (uint256) {\n    LPToken lpToken = self.lpToken;\n\n    require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    uint256 numTokens = self.pooledTokens.length;\n    require(tokenIndex < numTokens, \"not found\");\n\n    uint256 totalSupply = lpToken.totalSupply();\n\n    (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(self, tokenAmount, tokenIndex, totalSupply);\n\n    require(dy >= minAmount, \"dy < minAmount\");\n\n    uint256 adminFee = (dyFee * self.adminFee) / Constants.FEE_DENOMINATOR;\n    self.balances[tokenIndex] = self.balances[tokenIndex] - (dy + adminFee);\n    if (adminFee != 0) {\n      self.adminFees[tokenIndex] = self.adminFees[tokenIndex] + adminFee;\n    }\n    lpToken.burnFrom(msg.sender, tokenAmount);\n    AssetLogic.handleOutgoingAsset(address(self.pooledTokens[tokenIndex]), msg.sender, dy);\n\n    emit RemoveLiquidityOne(self.key, msg.sender, tokenAmount, totalSupply, tokenIndex, dy);\n\n    return dy;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances.\n   *\n   * @param self Swap struct to read from and write to\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @return actual amount of LP tokens burned in the withdrawal\n   */\n  function removeLiquidityImbalance(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 maxBurnAmount\n  ) internal returns (uint256) {\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    uint256 numTokens = self.pooledTokens.length;\n    uint256 numAmounts = amounts.length;\n    require(numAmounts == numTokens, \"mismatch pool tokens\");\n\n    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\");\n\n    uint256 feePerToken = _feePerToken(self.swapFee, numTokens);\n    uint256[] memory fees = new uint256[](numTokens);\n    {\n      uint256[] memory balances1 = new uint256[](numTokens);\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n      for (uint256 i; i < numTokens; ) {\n        require(v.balances[i] >= amounts[i], \"withdraw more than available\");\n\n        unchecked {\n          balances1[i] = v.balances[i] - amounts[i];\n          ++i;\n        }\n      }\n      v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n      for (uint256 i; i < numTokens; ) {\n        {\n          uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n          uint256 difference = idealBalance.difference(balances1[i]);\n          fees[i] = (feePerToken * difference) / Constants.FEE_DENOMINATOR;\n        }\n        uint256 adminFee = (fees[i] * self.adminFee) / Constants.FEE_DENOMINATOR;\n        self.balances[i] = balances1[i] - adminFee;\n        self.adminFees[i] = self.adminFees[i] + adminFee;\n        balances1[i] = balances1[i] - fees[i];\n\n        unchecked {\n          ++i;\n        }\n      }\n\n      v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n    }\n    uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\n    require(tokenAmount != 0, \"!zero amount\");\n    tokenAmount = tokenAmount + 1;\n\n    require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n    v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n    for (uint256 i; i < numTokens; ) {\n      AssetLogic.handleOutgoingAsset(address(self.pooledTokens[i]), msg.sender, amounts[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit RemoveLiquidityImbalance(self.key, msg.sender, amounts, fees, v.d1, v.totalSupply - tokenAmount);\n\n    return tokenAmount;\n  }\n\n  /**\n   * @notice withdraw all admin fees to a given address\n   * @param self Swap struct to withdraw fees from\n   * @param to Address to send the fees to\n   */\n  function withdrawAdminFees(Swap storage self, address to) internal {\n    uint256 numTokens = self.pooledTokens.length;\n    for (uint256 i; i < numTokens; ) {\n      IERC20 token = self.pooledTokens[i];\n      uint256 balance = self.adminFees[i];\n      if (balance != 0) {\n        delete self.adminFees[i];\n        AssetLogic.handleOutgoingAsset(address(token), to, balance);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Sets the admin fee\n   * @dev adminFee cannot be higher than 100% of the swap fee\n   * @param self Swap struct to update\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setAdminFee(Swap storage self, uint256 newAdminFee) internal {\n    require(newAdminFee < Constants.MAX_ADMIN_FEE + 1, \"too high\");\n    self.adminFee = newAdminFee;\n\n    emit NewAdminFee(self.key, newAdminFee);\n  }\n\n  /**\n   * @notice update the swap fee\n   * @dev fee cannot be higher than 1% of each swap\n   * @param self Swap struct to update\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(Swap storage self, uint256 newSwapFee) internal {\n    require(newSwapFee < Constants.MAX_SWAP_FEE + 1, \"too high\");\n    self.swapFee = newSwapFee;\n\n    emit NewSwapFee(self.key, newSwapFee);\n  }\n\n  /**\n   * @notice Check if this stableswap pool exists and is valid (i.e. has been\n   * initialized and tokens have been added).\n   * @return bool true if this stableswap pool is valid, false if not.\n   */\n  function exists(Swap storage self) internal view returns (bool) {\n    return !self.disabled && self.pooledTokens.length != 0;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/messaging/interfaces/IOutbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice Interface for all contracts sending messages originating on their\n * current domain.\n *\n * @dev These are the Home.sol interface methods used by the `Router`\n * and exposed via `home()` on the `XAppConnectionClient`\n */\ninterface IOutbox {\n  /**\n   * @notice Emitted when a new message is added to an outbound message merkle root\n   * @param leafIndex Index of message's leaf in merkle tree\n   * @param destinationAndNonce Destination and destination-specific\n   * nonce combined in single field ((destination << 32) & nonce)\n   * @param messageHash Hash of message; the leaf inserted to the Merkle tree for the message\n   * @param committedRoot the latest notarized root submitted in the last signed Update\n   * @param message Raw bytes of message\n   */\n  event Dispatch(\n    bytes32 indexed messageHash,\n    uint256 indexed leafIndex,\n    uint64 indexed destinationAndNonce,\n    bytes32 committedRoot,\n    bytes message\n  );\n\n  /**\n   * @notice Dispatch the message it to the destination domain & recipient\n   * @dev Format the message, insert its hash into Merkle tree,\n   * enqueue the new Merkle root, and emit `Dispatch` event with message information.\n   * @param _destinationDomain Domain of destination chain\n   * @param _recipientAddress Address of recipient on destination chain as bytes32\n   * @param _messageBody Raw bytes content of message\n   * @return bytes32 The leaf added to the tree\n   */\n  function dispatch(\n    uint32 _destinationDomain,\n    bytes32 _recipientAddress,\n    bytes memory _messageBody\n  ) external returns (bytes32);\n}\n"
    },
    "contracts/core/connext/helpers/LPToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title Liquidity Provider Token\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\n * It is used to represent user's shares when providing liquidity to swap contracts.\n * @dev Only Swap contracts should initialize and own LPToken contracts.\n */\ncontract LPToken is ERC20Upgradeable, OwnableUpgradeable {\n  // ============ Storage ============\n\n  // ============ Initializer ============\n\n  /**\n   * @notice Initializes this LPToken contract with the given name and symbol\n   * @dev The caller of this function will become the owner. A Swap contract should call this\n   * in its initializer function.\n   * @param name name of this token\n   * @param symbol symbol of this token\n   */\n  function initialize(string memory name, string memory symbol) external initializer returns (bool) {\n    __Context_init_unchained();\n    __ERC20_init_unchained(name, symbol);\n    __Ownable_init_unchained();\n    return true;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Mints the given amount of LPToken to the recipient.\n   * @dev only owner can call this mint function\n   * @param recipient address of account to receive the tokens\n   * @param amount amount of tokens to mint\n   */\n  function mint(address recipient, uint256 amount) external onlyOwner {\n    require(amount != 0, \"LPToken: cannot mint 0\");\n    _mint(recipient, amount);\n  }\n\n  /**\n   * @notice Burns the given amount of LPToken from provided account\n   * @dev only owner can call this burn function\n   * @param account address of account from which to burn token\n   * @param amount amount of tokens to mint\n   */\n  function burnFrom(address account, uint256 amount) external onlyOwner {\n    require(amount != 0, \"LPToken: cannot burn 0\");\n    _burn(account, amount);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\n   * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\n   * This assumes the owner is set to a Swap contract's address.\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override(ERC20Upgradeable) {\n    super._beforeTokenTransfer(from, to, amount);\n    require(to != address(this), \"LPToken: cannot send to itself\");\n  }\n\n  // ============ Upgrade Gap ============\n  uint256[50] private __GAP; // gap for upgrade safety\n}\n"
    },
    "contracts/core/connext/libraries/AmplificationUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {SwapUtils} from \"./SwapUtils.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * @title AmplificationUtils library\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\n * This library assumes the struct is fully validated.\n */\nlibrary AmplificationUtils {\n  event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n  event StopRampA(uint256 currentA, uint256 time);\n\n  /**\n   * @notice Return A, the amplification coefficient * n ** (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return A parameter\n   */\n  function getA(SwapUtils.Swap storage self) internal view returns (uint256) {\n    return _getAPrecise(self) / Constants.A_PRECISION;\n  }\n\n  /**\n   * @notice Return A in its raw precision\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return A parameter in its raw precision form\n   */\n  function getAPrecise(SwapUtils.Swap storage self) internal view returns (uint256) {\n    return _getAPrecise(self);\n  }\n\n  /**\n   * @notice Return A in its raw precision\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return currentA A parameter in its raw precision form\n   */\n  function _getAPrecise(SwapUtils.Swap storage self) internal view returns (uint256 currentA) {\n    uint256 t1 = self.futureATime; // time when ramp is finished\n    currentA = self.futureA; // final A value when ramp is finished\n    uint256 a0 = self.initialA; // initial A value when ramp is started\n\n    if (a0 != currentA && block.timestamp < t1) {\n      uint256 t0 = self.initialATime; // time when ramp is started\n      assembly {\n        currentA := div(add(mul(a0, sub(t1, timestamp())), mul(currentA, sub(timestamp(), t0))), sub(t1, t0))\n      }\n    }\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param self Swap struct to update\n   * @param futureA_ the new A to ramp towards\n   * @param futureTime_ timestamp when the new A should be reached\n   */\n  function rampA(\n    SwapUtils.Swap storage self,\n    uint256 futureA_,\n    uint256 futureTime_\n  ) internal {\n    require(block.timestamp >= self.initialATime + Constants.MIN_RAMP_DELAY, \"Wait 1 day before starting ramp\");\n    require(futureTime_ >= block.timestamp + Constants.MIN_RAMP_TIME, \"Insufficient ramp time\");\n    require(futureA_ != 0 && futureA_ < Constants.MAX_A, \"futureA_ must be > 0 and < MAX_A\");\n\n    uint256 initialAPrecise = _getAPrecise(self);\n    uint256 futureAPrecise = futureA_ * Constants.A_PRECISION;\n    require(initialAPrecise != futureAPrecise, \"!valid ramp\");\n\n    if (futureAPrecise < initialAPrecise) {\n      require(futureAPrecise * Constants.MAX_A_CHANGE >= initialAPrecise, \"futureA_ is too small\");\n    } else {\n      require(futureAPrecise <= initialAPrecise * Constants.MAX_A_CHANGE, \"futureA_ is too large\");\n    }\n\n    self.initialA = initialAPrecise;\n    self.futureA = futureAPrecise;\n    self.initialATime = block.timestamp;\n    self.futureATime = futureTime_;\n\n    emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\n  }\n\n  /**\n   * @notice Stops ramping A immediately. Once this function is called, rampA()\n   * cannot be called for another 24 hours\n   * @param self Swap struct to update\n   */\n  function stopRampA(SwapUtils.Swap storage self) internal {\n    require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n\n    uint256 currentA = _getAPrecise(self);\n    self.initialA = currentA;\n    self.futureA = currentA;\n    self.initialATime = block.timestamp;\n    self.futureATime = block.timestamp;\n\n    emit StopRampA(currentA, block.timestamp);\n  }\n}\n"
    },
    "contracts/core/connext/libraries/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\n/**\n * @title MathUtils library\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\n * differences between two uint256.\n */\nlibrary MathUtils {\n  /**\n   * @notice Compares a and b and returns true if the difference between a and b\n   *         is less than 1 or equal to each other.\n   * @param a uint256 to compare with\n   * @param b uint256 to compare with\n   * @return True if the difference between a and b is less than 1 or equal,\n   *         otherwise return false\n   */\n  function within1(uint256 a, uint256 b) internal pure returns (bool) {\n    return (difference(a, b) < 1 + 1); // instead of <=1\n  }\n\n  /**\n   * @notice Calculates absolute difference between a and b\n   * @param a uint256 to compare with\n   * @param b uint256 to compare with\n   * @return Difference between a and b\n   */\n  function difference(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a > b) {\n      return a - b;\n    }\n    return b - a;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/shared/libraries/TypeCasts.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {TypedMemView} from \"./TypedMemView.sol\";\n\nlibrary TypeCasts {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // alignment preserving cast\n  function addressToBytes32(address _addr) internal pure returns (bytes32) {\n    return bytes32(uint256(uint160(_addr)));\n  }\n\n  // alignment preserving cast\n  function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n    return address(uint160(uint256(_buf)));\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/shared/libraries/TypedMemView.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nlibrary TypedMemView {\n  // Why does this exist?\n  // the solidity `bytes memory` type has a few weaknesses.\n  // 1. You can't index ranges effectively\n  // 2. You can't slice without copying\n  // 3. The underlying data may represent any type\n  // 4. Solidity never deallocates memory, and memory costs grow\n  //    superlinearly\n\n  // By using a memory view instead of a `bytes memory` we get the following\n  // advantages:\n  // 1. Slices are done on the stack, by manipulating the pointer\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\n  // 3. We can insert type info into the pointer, and typecheck at runtime\n\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\n  // algorithms.\n\n  // Why bytes29?\n  // We want to avoid confusion between views, digests, and other common\n  // types so we chose a large and uncommonly used odd number of bytes\n  //\n  // Note that while bytes are left-aligned in a word, integers and addresses\n  // are right-aligned. This means when working in assembly we have to\n  // account for the 3 unused bytes on the righthand side\n  //\n  // First 5 bytes are a type flag.\n  // - ff_ffff_fffe is reserved for unknown type.\n  // - ff_ffff_ffff is reserved for invalid types/errors.\n  // next 12 are memory address\n  // next 12 are len\n  // bottom 3 bytes are empty\n\n  // Assumptions:\n  // - non-modification of memory.\n  // - No Solidity updates\n  // - - wrt free mem point\n  // - - wrt bytes representation in memory\n  // - - wrt memory addressing in general\n\n  // Usage:\n  // - create type constants\n  // - use `assertType` for runtime type assertions\n  // - - unfortunately we can't do this at compile time yet :(\n  // - recommended: implement modifiers that perform type checking\n  // - - e.g.\n  // - - `uint40 constant MY_TYPE = 3;`\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n  // - instantiate a typed view from a bytearray using `ref`\n  // - use `index` to inspect the contents of the view\n  // - use `slice` to create smaller views into the same memory\n  // - - `slice` can increase the offset\n  // - - `slice can decrease the length`\n  // - - must specify the output type of `slice`\n  // - - `slice` will return a null view if you try to overrun\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\n  // - use `equal` for typed comparisons.\n\n  // The null view\n  bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n  uint256 constant TWENTY_SEVEN_BYTES = 8 * 27;\n  uint256 private constant _27_BYTES_IN_BITS = 8 * 27; // <--- also used this named constant where ever 216 is used.\n  uint256 private constant LOW_27_BYTES_MASK = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff; // (1 << _27_BYTES_IN_BITS) - 1;\n\n  // ========== Custom Errors ===========\n\n  error TypedMemView__assertType_typeAssertionFailed(uint256 actual, uint256 expected);\n  error TypedMemView__index_overrun(uint256 loc, uint256 len, uint256 index, uint256 slice);\n  error TypedMemView__index_indexMoreThan32Bytes();\n  error TypedMemView__unsafeCopyTo_nullPointer();\n  error TypedMemView__unsafeCopyTo_invalidPointer();\n  error TypedMemView__unsafeCopyTo_identityOOG();\n  error TypedMemView__assertValid_validityAssertionFailed();\n\n  /**\n   * @notice          Changes the endianness of a uint256.\n   * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n   * @param _b        The unsigned integer to reverse\n   * @return          v - The reversed value\n   */\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n    v = _b;\n\n    // swap bytes\n    v =\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n    // swap 2-byte long pairs\n    v =\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n    // swap 4-byte long pairs\n    v =\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n    // swap 8-byte long pairs\n    v =\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n  }\n\n  /**\n   * @notice      Create a mask with the highest `_len` bits set.\n   * @param _len  The length\n   * @return      mask - The mask\n   */\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\n    // ugly. redo without assembly?\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n    }\n  }\n\n  /**\n   * @notice      Return the null view.\n   * @return      bytes29 - The null view\n   */\n  function nullView() internal pure returns (bytes29) {\n    return NULL;\n  }\n\n  /**\n   * @notice      Check if the view is null.\n   * @return      bool - True if the view is null\n   */\n  function isNull(bytes29 memView) internal pure returns (bool) {\n    return memView == NULL;\n  }\n\n  /**\n   * @notice      Check if the view is not null.\n   * @return      bool - True if the view is not null\n   */\n  function notNull(bytes29 memView) internal pure returns (bool) {\n    return !isNull(memView);\n  }\n\n  /**\n   * @notice          Check if the view is of a invalid type and points to a valid location\n   *                  in memory.\n   * @dev             We perform this check by examining solidity's unallocated memory\n   *                  pointer and ensuring that the view's upper bound is less than that.\n   * @param memView   The view\n   * @return          ret - True if the view is invalid\n   */\n  function isNotValid(bytes29 memView) internal pure returns (bool ret) {\n    if (typeOf(memView) == 0xffffffffff) {\n      return true;\n    }\n    uint256 _end = end(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ret := gt(_end, mload(0x40))\n    }\n  }\n\n  /**\n   * @notice          Require that a typed memory view be valid.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @return          bytes29 - The validated view\n   */\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\n    if (isNotValid(memView)) revert TypedMemView__assertValid_validityAssertionFailed();\n    return memView;\n  }\n\n  /**\n   * @notice          Return true if the memview is of the expected type. Otherwise false.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bool - True if the memview is of the expected type\n   */\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n    return typeOf(memView) == _expected;\n  }\n\n  /**\n   * @notice          Require that a typed memory view has a specific type.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bytes29 - The view with validated type\n   */\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n    if (!isType(memView, _expected)) {\n      revert TypedMemView__assertType_typeAssertionFailed(uint256(typeOf(memView)), uint256(_expected));\n    }\n    return memView;\n  }\n\n  /**\n   * @notice          Return an identical view with a different type.\n   * @param memView   The view\n   * @param _newType  The new type\n   * @return          newView - The new view with the specified type\n   */\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n    // then | in the new type\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // shift off the top 5 bytes\n      newView := or(and(memView, LOW_27_BYTES_MASK), shl(_27_BYTES_IN_BITS, _newType))\n    }\n  }\n\n  /**\n   * @notice          Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function unsafeBuildUnchecked(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) private pure returns (bytes29 newView) {\n    uint256 _uint96Bits = 96;\n    uint256 _emptyBits = 24;\n\n    // Cast params to ensure input is of correct length\n    uint96 len_ = uint96(_len);\n    uint96 loc_ = uint96(_loc);\n    require(len_ == _len && loc_ == _loc, \"!truncated\");\n\n    assembly {\n      // solium-disable-previous-line security/no-inline-assembly\n      newView := shl(_uint96Bits, _type) // insert type\n      newView := shl(_uint96Bits, or(newView, loc_)) // insert loc\n      newView := shl(_emptyBits, or(newView, len_)) // empty bottom 3 bytes\n    }\n  }\n\n  /**\n   * @notice          Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function build(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) internal pure returns (bytes29 newView) {\n    uint256 _end = _loc + _len;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      if gt(_end, mload(0x40)) {\n        _end := 0\n      }\n    }\n    if (_end == 0) {\n      return NULL;\n    }\n    newView = unsafeBuildUnchecked(_type, _loc, _len);\n  }\n\n  /**\n   * @notice          Instantiate a memory view from a byte array.\n   * @dev             Note that due to Solidity memory representation, it is not possible to\n   *                  implement a deref, as the `bytes` type stores its len in memory.\n   * @param arr       The byte array\n   * @param newType   The type\n   * @return          bytes29 - The memory view\n   */\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n    uint256 _len = arr.length;\n\n    uint256 _loc;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\n    }\n\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Return the associated type information.\n   * @param memView   The memory view\n   * @return          _type - The type associated with the view\n   */\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 216 == 256 - 40\n      _type := shr(_27_BYTES_IN_BITS, memView) // shift out lower 24 bytes\n    }\n  }\n\n  /**\n   * @notice          Return the memory address of the underlying bytes.\n   * @param memView   The view\n   * @return          _loc - The memory address\n   */\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n      _loc := and(shr(120, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          The number of memory words this memory view occupies, rounded up.\n   * @param memView   The view\n   * @return          uint256 - The number of memory words\n   */\n  function words(bytes29 memView) internal pure returns (uint256) {\n    return (uint256(len(memView)) + 31) / 32;\n  }\n\n  /**\n   * @notice          The in-memory footprint of a fresh copy of the view.\n   * @param memView   The view\n   * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n   */\n  function footprint(bytes29 memView) internal pure returns (uint256) {\n    return words(memView) * 32;\n  }\n\n  /**\n   * @notice          The number of bytes of the view.\n   * @param memView   The view\n   * @return          _len - The length of the view\n   */\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _len := and(shr(24, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          Returns the endpoint of `memView`.\n   * @param memView   The view\n   * @return          uint256 - The endpoint of `memView`\n   */\n  function end(bytes29 memView) internal pure returns (uint256) {\n    unchecked {\n      return loc(memView) + len(memView);\n    }\n  }\n\n  /**\n   * @notice          Safe slicing without memory modification.\n   * @param memView   The view\n   * @param _index    The start index\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function slice(\n    bytes29 memView,\n    uint256 _index,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    uint256 _loc = loc(memView);\n\n    // Ensure it doesn't overrun the view\n    if (_loc + _index + _len > end(memView)) {\n      return NULL;\n    }\n\n    _loc = _loc + _index;\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function prefix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, 0, _len, newType);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function postfix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, uint256(len(memView)) - _len, _len, newType);\n  }\n\n  /**\n   * @notice          Load up to 32 bytes from the view onto the stack.\n   * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n   *                  This can be immediately cast to a smaller fixed-length byte array.\n   *                  To automatically cast to an integer, use `indexUint`.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The 32 byte result\n   */\n  function index(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (bytes32 result) {\n    if (_bytes == 0) {\n      return bytes32(0);\n    }\n    if (_index + _bytes > len(memView)) {\n      // \"TypedMemView/index - Overran the view. Slice is at {loc} with length {len}. Attempted to index at offset {index} with length {slice},\n      revert TypedMemView__index_overrun(loc(memView), len(memView), _index, uint256(_bytes));\n    }\n    if (_bytes > 32) revert TypedMemView__index_indexMoreThan32Bytes();\n\n    uint8 bitLength;\n    unchecked {\n      bitLength = _bytes * 8;\n    }\n    uint256 _loc = loc(memView);\n    uint256 _mask = leftMask(bitLength);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      result := and(mload(add(_loc, _index)), _mask)\n    }\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from the view at `_index`.\n   * @dev             Requires that the view have >= `_bytes` bytes following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from LE bytes.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexLEUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\n  }\n\n  /**\n   * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\n   *                  following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @return          address - The address\n   */\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n    return address(uint160(indexUint(memView, _index, 20)));\n  }\n\n  /**\n   * @notice          Return the keccak256 hash of the underlying memory\n   * @param memView   The view\n   * @return          digest - The keccak256 hash of the underlying memory\n   */\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      digest := keccak256(_loc, _len)\n    }\n  }\n\n  /**\n   * @notice          Return true if the underlying memory is equal. Else false.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the underlying memory is equal\n   */\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\n  }\n\n  /**\n   * @notice          Return false if the underlying memory is equal. Else true.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - False if the underlying memory is equal\n   */\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !untypedEqual(left, right);\n  }\n\n  /**\n   * @notice          Compares type equality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are the same\n   */\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\n  }\n\n  /**\n   * @notice          Compares type inequality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are not the same\n   */\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !equal(left, right);\n  }\n\n  /**\n   * @notice          Copy the view to a location, return an unsafe memory reference\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memView   The view\n   * @param _newLoc   The new location\n   * @return          written - the unsafe memory reference\n   */\n  function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n    if (isNull(memView)) revert TypedMemView__unsafeCopyTo_nullPointer();\n    if (isNotValid(memView)) revert TypedMemView__unsafeCopyTo_invalidPointer();\n\n    uint256 _len = len(memView);\n    uint256 _oldLoc = loc(memView);\n\n    uint256 ptr;\n    bool res;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _newLoc) {\n        revert(0x60, 0x20) // empty revert message\n      }\n\n      // use the identity precompile to copy\n      // guaranteed not to fail, so pop the success\n      res := staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len)\n    }\n    if (!res) revert TypedMemView__unsafeCopyTo_identityOOG();\n    written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n  }\n\n  /**\n   * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n   *                  the new memory\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param memView   The view\n   * @return          ret - The view pointing to the new memory\n   */\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n      ret := ptr\n    }\n    unchecked {\n      unsafeCopyTo(memView, ptr + 0x20);\n    }\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n      mstore(ptr, _len) // write len of new array (in bytes)\n    }\n  }\n\n  /**\n   * @notice          Join the views in memory, return an unsafe reference to the memory.\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memViews  The views\n   * @return          unsafeView - The conjoined view pointing to the new memory\n   */\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _location) {\n        revert(0x60, 0x20) // empty revert message\n      }\n    }\n\n    uint256 _offset = 0;\n    uint256 _len = memViews.length;\n    for (uint256 i = 0; i < _len; ) {\n      bytes29 memView = memViews[i];\n      unchecked {\n        unsafeCopyTo(memView, _location + _offset);\n        _offset += len(memView);\n        ++i;\n      }\n    }\n    unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n  }\n\n  /**\n   * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n   * @param memViews  The views\n   * @return          bytes32 - The keccak256 digest\n   */\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n    return keccak(unsafeJoin(memViews, ptr));\n  }\n\n  /**\n   * @notice          copies all views, joins them into a new bytearray.\n   * @param memViews  The views\n   * @return          ret - The new byte array\n   */\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n\n    bytes29 _newView;\n    unchecked {\n      _newView = unsafeJoin(memViews, ptr + 0x20);\n    }\n    uint256 _written = len(_newView);\n    uint256 _footprint = footprint(_newView);\n\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // store the legnth\n      mstore(ptr, _written)\n      // new pointer is old + 0x20 + the footprint of the body\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\n      ret := ptr\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/core/connext/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n  enum FacetCutAction {\n    Add,\n    Replace,\n    Remove\n  }\n  // Add=0, Replace=1, Remove=2\n\n  struct FacetCut {\n    address facetAddress;\n    FacetCutAction action;\n    bytes4[] functionSelectors;\n  }\n\n  /// @notice Propose to add/replace/remove any number of functions and optionally execute\n  ///         a function with delegatecall\n  /// @param _diamondCut Contains the facet addresses and function selectors\n  /// @param _init The address of the contract or facet to execute _calldata\n  /// @param _calldata A function call, including function selector and arguments\n  ///                  _calldata is executed with delegatecall on _init\n  function proposeDiamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external;\n\n  event DiamondCutProposed(FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\n\n  /// @notice Add/replace/remove any number of functions and optionally execute\n  ///         a function with delegatecall\n  /// @param _diamondCut Contains the facet addresses and function selectors\n  /// @param _init The address of the contract or facet to execute _calldata\n  /// @param _calldata A function call, including function selector and arguments\n  ///                  _calldata is executed with delegatecall on _init\n  function diamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external;\n\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  /// @notice Propose to add/replace/remove any number of functions and optionally execute\n  ///         a function with delegatecall\n  /// @param _diamondCut Contains the facet addresses and function selectors\n  /// @param _init The address of the contract or facet to execute _calldata\n  /// @param _calldata A function call, including function selector and arguments\n  ///                  _calldata is executed with delegatecall on _init\n  function rescindDiamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external;\n\n  /**\n   * @notice Returns the acceptance time for a given proposal\n   * @param _diamondCut Contains the facet addresses and function selectors\n   * @param _init The address of the contract or facet to execute _calldata\n   * @param _calldata A function call, including function selector and arguments _calldata is\n   * executed with delegatecall on _init\n   */\n  function getAcceptanceTime(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external returns (uint256);\n\n  event DiamondCutRescinded(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/core/connext/facets/upgrade-initializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {IDiamondLoupe} from \"../../interfaces/IDiamondLoupe.sol\";\nimport {IDiamondCut} from \"../../interfaces/IDiamondCut.sol\";\nimport {IERC165} from \"../../interfaces/IERC165.sol\";\n\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {Constants} from \"../../libraries/Constants.sol\";\n\nimport {BaseConnextFacet} from \"../BaseConnextFacet.sol\";\n\nimport {IProposedOwnable} from \"../../../../shared/interfaces/IProposedOwnable.sol\";\nimport {IConnectorManager} from \"../../../../messaging/interfaces/IConnectorManager.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error DiamondInit__init_alreadyInitialized();\n  error DiamondInit__init_domainsDontMatch();\n\n  // ============ External ============\n\n  // You can add parameters to this function in order to pass in\n  // data to set your own state variables\n  // NOTE: not requiring a longer delay related to constant as we want to be able to test\n  // with shorter governance delays\n  function init(\n    uint32 _domain,\n    address _xAppConnectionManager,\n    uint256 _acceptanceDelay,\n    address _lpTokenTargetAddress\n  ) external {\n    // should not init twice\n    if (s.initialized) {\n      revert DiamondInit__init_alreadyInitialized();\n    }\n\n    // ensure this is the owner\n    LibDiamond.enforceIsContractOwner();\n\n    // ensure domains are the same\n    IConnectorManager manager = IConnectorManager(_xAppConnectionManager);\n    if (manager.localDomain() != _domain) {\n      revert DiamondInit__init_domainsDontMatch();\n    }\n\n    // update the initialized flag\n    s.initialized = true;\n\n    // adding ERC165 data\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n    ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n    ds.supportedInterfaces[type(IProposedOwnable).interfaceId] = true;\n    ds.acceptanceDelay = _acceptanceDelay;\n\n    // add your own state variables\n    // EIP-2535 specifies that the `diamondCut` function takes two optional\n    // arguments: address _init and bytes calldata _calldata\n    // These arguments are used to execute an arbitrary function using delegatecall\n    // in order to set state variables in the diamond during deployment or an upgrade\n    // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface\n\n    // __ReentrancyGuard_init_unchained\n    s._status = Constants.NOT_ENTERED;\n    s._xcallStatus = Constants.NOT_ENTERED;\n\n    // Connext\n    s.domain = _domain;\n    s.LIQUIDITY_FEE_NUMERATOR = Constants.INITIAL_LIQUIDITY_FEE_NUMERATOR;\n    s.maxRoutersPerTransfer = Constants.INITIAL_MAX_ROUTERS;\n    s.xAppConnectionManager = manager;\n    s.lpTokenTargetAddress = _lpTokenTargetAddress;\n  }\n}\n"
    },
    "contracts/core/connext/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n  /// These functions are expected to be called frequently\n  /// by tools.\n\n  struct Facet {\n    address facetAddress;\n    bytes4[] functionSelectors;\n  }\n\n  /// @notice Gets all facet addresses and their four byte function selectors.\n  /// @return facets_ Facet\n  function facets() external view returns (Facet[] memory facets_);\n\n  /// @notice Gets all the function selectors supported by a specific facet.\n  /// @param _facet The facet address.\n  /// @return facetFunctionSelectors_\n  function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n  /// @notice Get all the facet addresses used by a diamond.\n  /// @return facetAddresses_\n  function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n  /// @notice Gets the facet that supports the given selector.\n  /// @dev If facet is not found return address(0).\n  /// @param _functionSelector The function selector.\n  /// @return facetAddress_ The facet address.\n  function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/core/connext/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceId The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IProposedOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title IProposedOwnable\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\n * process\n */\ninterface IProposedOwnable {\n  /**\n   * @dev This emits when change in ownership of a contract is proposed.\n   */\n  event OwnershipProposed(address indexed proposedOwner);\n\n  /**\n   * @dev This emits when ownership of a contract changes.\n   */\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @notice Get the address of the owner\n   * @return owner_ The address of the owner.\n   */\n  function owner() external view returns (address owner_);\n\n  /**\n   * @notice Get the address of the proposed owner\n   * @return proposed_ The address of the proposed.\n   */\n  function proposed() external view returns (address proposed_);\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   * @param newlyProposed The proposed new owner of the contract\n   */\n  function proposeNewOwner(address newlyProposed) external;\n\n  /**\n   * @notice Set the address of the proposed owner of the contract\n   */\n  function acceptProposedOwner() external;\n}\n"
    },
    "contracts/messaging/connectors/ConnectorManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IConnectorManager} from \"../interfaces/IConnectorManager.sol\";\nimport {IOutbox} from \"../interfaces/IOutbox.sol\";\n\n/**\n * @notice This is an interface to allow the `Messaging` contract to be used\n * as a `XappConnectionManager` on all router contracts.\n *\n * @dev Each nomad router contract has a `XappConnectionClient`, which references a\n * XappConnectionManager to get the `Home` (outbox) and approved `Replica` (inbox)\n * instances. At any point the client can replace the manager it's pointing to,\n * changing the underlying messaging connection.\n */\nabstract contract ConnectorManager is IConnectorManager {\n  constructor() {}\n\n  function home() public view returns (IOutbox) {\n    return IOutbox(address(this));\n  }\n\n  function isReplica(address _potentialReplica) public view returns (bool) {\n    return _potentialReplica == address(this);\n  }\n\n  function localDomain() external view virtual returns (uint32);\n}\n"
    },
    "contracts/messaging/connectors/SpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {TypedMemView} from \"../../shared/libraries/TypedMemView.sol\";\nimport {ExcessivelySafeCall} from \"../../shared/libraries/ExcessivelySafeCall.sol\";\nimport {TypeCasts} from \"../../shared/libraries/TypeCasts.sol\";\n\nimport {MerkleLib} from \"../libraries/MerkleLib.sol\";\nimport {Message} from \"../libraries/Message.sol\";\nimport {RateLimited} from \"../libraries/RateLimited.sol\";\n\nimport {MerkleTreeManager} from \"../MerkleTreeManager.sol\";\nimport {WatcherClient} from \"../WatcherClient.sol\";\n\nimport {Connector, ProposedOwnable} from \"./Connector.sol\";\nimport {ConnectorManager} from \"./ConnectorManager.sol\";\n\n/**\n * @title SpokeConnector\n * @author Connext Labs, Inc.\n * @notice This contract implements the messaging functions needed on the spoke-side of a given AMB.\n * The SpokeConnector extends the HubConnector functionality by being able to send, store, and prove\n * messages.\n *\n * @dev If you are deploying this contract to mainnet, then the mirror values stored in the HubConnector\n * will be unused\n */\nabstract contract SpokeConnector is Connector, ConnectorManager, WatcherClient, RateLimited, ReentrancyGuard {\n  // ============ Libraries ============\n\n  using MerkleLib for MerkleLib.Tree;\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using Message for bytes29;\n\n  // ============ Events ============\n\n  event SenderAdded(address sender);\n\n  event SenderRemoved(address sender);\n\n  event AggregateRootReceived(bytes32 root);\n\n  event AggregateRootRemoved(bytes32 root);\n\n  event AggregateRootVerified(bytes32 indexed root);\n\n  event Dispatch(bytes32 leaf, uint256 index, bytes32 root, bytes message);\n\n  event Process(bytes32 leaf, bool success, bytes returnData);\n\n  event DelayBlocksUpdated(uint256 indexed updated, address caller);\n\n  /**\n   * @notice Emitted when funds are withdrawn by the admin\n   * @dev See comments in `withdrawFunds`\n   * @param to The recipient of the funds\n   * @param amount The amount withdrawn\n   */\n  event FundsWithdrawn(address indexed to, uint256 amount);\n\n  event MessageProven(bytes32 indexed leaf, bytes32 indexed aggregateRoot, uint256 aggregateIndex);\n\n  // ============ Structs ============\n\n  // Status of Message:\n  //   0 - None - message has not been proven or processed\n  //   1 - Proven - message inclusion proof has been validated\n  //   2 - Processed - message has been dispatched to recipient\n  enum MessageStatus {\n    None,\n    Proven,\n    Processed\n  }\n\n  /**\n   * Struct for submitting a proof for a given message. Used in `proveAndProcess` below.\n   * @param message Bytes of message to be processed. The hash of this message is considered the leaf.\n   * @param proof Merkle proof of inclusion for given leaf.\n   * @param index Index of leaf in home's merkle tree.\n   */\n  struct Proof {\n    bytes message;\n    bytes32[32] path;\n    uint256 index;\n  }\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice Number of blocks to delay the processing of a message to allow for watchers to verify\n   * the validity and pause if necessary.\n   */\n  uint256 public delayBlocks;\n\n  /**\n   * @notice MerkleTreeManager contract instance. Will hold the active tree of message hashes, whose root\n   * will be sent crosschain to the hub for aggregation and redistribution.\n   */\n  MerkleTreeManager public immutable MERKLE;\n\n  /**\n   * @notice Minimum gas for processing a received message (reserved for handle)\n   */\n  uint256 public immutable PROCESS_GAS;\n\n  /**\n   * @notice Reserved gas (to ensure tx completes in case message processing runs out)\n   */\n  uint256 public immutable RESERVE_GAS;\n\n  /**\n   * @notice This will hold the commit block for incoming aggregateRoots from the hub chain. Once\n   * they are verified, (i.e. have surpassed the verification period in `delayBlocks`) they can\n   * be used for proving inclusion of crosschain messages.\n   *\n   * @dev NOTE: A commit block of 0 should be considered invalid (it is an empty entry in the\n   * mapping). We must ALWAYS ensure the value is not 0 before checking whether it has surpassed the\n   * verification period.\n   */\n  mapping(bytes32 => uint256) public pendingAggregateRoots;\n\n  /**\n   * @notice This tracks the roots of the aggregate tree containing outbound roots from all other\n   * supported domains. The current version is the one that is known to be past the delayBlocks\n   * time period.\n   * @dev This root is the root of the tree that is aggregated on mainnet (composed of all the roots\n   * of previous trees).\n   */\n  mapping(bytes32 => bool) public provenAggregateRoots;\n\n  /**\n   * @notice This tracks whether the root has been proven to exist within the given aggregate root.\n   * @dev Tracking this is an optimization so you dont have to prove inclusion of the same constituent\n   * root many times.\n   */\n  mapping(bytes32 => bool) public provenMessageRoots;\n\n  /**\n   * @notice This mapping records all message roots that have already been sent in order to prevent\n   * redundant message roots from being sent to hub.\n   */\n  mapping(bytes32 => bool) public sentMessageRoots;\n\n  /**\n   * @dev This is used for the `onlyAllowlistedSender` modifier, which gates who\n   * can send messages using `dispatch`.\n   */\n  mapping(address => bool) public allowlistedSenders;\n\n  /**\n   * @notice domain => next available nonce for the domain.\n   */\n  mapping(uint32 => uint32) public nonces;\n\n  /**\n   * @notice Mapping of message leaves to MessageStatus, keyed on leaf.\n   */\n  mapping(bytes32 => MessageStatus) public messages;\n\n  // ============ Modifiers ============\n\n  modifier onlyAllowlistedSender() {\n    require(allowlistedSenders[msg.sender], \"!allowlisted\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new SpokeConnector instance.\n   * @param _domain The domain this connector lives on.\n   * @param _mirrorDomain The hub domain.\n   * @param _amb The address of the AMB on the spoke domain this connector lives on.\n   * @param _rootManager The address of the RootManager on the hub.\n   * @param _mirrorConnector The address of the spoke connector.\n   * @param _processGas The gas costs used in `handle` to ensure meaningful state changes can occur (minimum gas needed\n   * to handle transaction).\n   * @param _reserveGas The gas costs reserved when `handle` is called to ensure failures are handled.\n   * @param _delayBlocks The delay for the validation period for incoming messages in blocks.\n   * @param _merkle The address of the MerkleTreeManager on this spoke domain.\n   * @param _watcherManager The address of the WatcherManager to whom this connector is a client.\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager\n  )\n    ConnectorManager()\n    Connector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector)\n    WatcherClient(_watcherManager)\n  {\n    // Sanity check: constants are reasonable.\n    require(_processGas > 850_000 - 1, \"!process gas\");\n    require(_reserveGas > 15_000 - 1, \"!reserve gas\");\n    PROCESS_GAS = _processGas;\n    RESERVE_GAS = _reserveGas;\n\n    require(_merkle != address(0), \"!zero merkle\");\n    MERKLE = MerkleTreeManager(_merkle);\n\n    delayBlocks = _delayBlocks;\n  }\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Adds a sender to the allowlist.\n   * @dev Only allowlisted routers (senders) can call `dispatch`.\n   */\n  function addSender(address _sender) public onlyOwner {\n    allowlistedSenders[_sender] = true;\n    emit SenderAdded(_sender);\n  }\n\n  /**\n   * @notice Removes a sender from the allowlist.\n   * @dev Only allowlisted routers (senders) can call `dispatch`.\n   */\n  function removeSender(address _sender) public onlyOwner {\n    delete allowlistedSenders[_sender];\n    emit SenderRemoved(_sender);\n  }\n\n  /**\n   * @notice Set the `delayBlocks`, the period in blocks over which an incoming message\n   * is verified.\n   */\n  function setDelayBlocks(uint256 _delayBlocks) public onlyOwner {\n    require(_delayBlocks != delayBlocks, \"!delayBlocks\");\n    emit DelayBlocksUpdated(_delayBlocks, msg.sender);\n    delayBlocks = _delayBlocks;\n  }\n\n  /**\n   * @notice Set the rate limit (number of blocks) at which we can send messages from\n   * this contract to the hub chain using the `send` method.\n   * @dev Rate limit is used to mitigate DoS vectors. (See `RateLimited` for more info.)\n   * @param _rateLimit The number of blocks require between sending messages. If set to\n   * 0, rate limiting for this spoke connector will be disabled.\n   */\n  function setRateLimitBlocks(uint256 _rateLimit) public onlyOwner {\n    _setRateLimitBlocks(_rateLimit);\n  }\n\n  /**\n   * @notice Manually remove a pending aggregateRoot by owner if the contract is paused.\n   * @dev This method is required for handling fraud cases in the current construction.\n   * @param _fraudulentRoot Target fraudulent root that should be erased from the\n   * `pendingAggregateRoots` mapping.\n   */\n  function removePendingAggregateRoot(bytes32 _fraudulentRoot) public onlyOwner whenPaused {\n    // Sanity check: pending aggregate root exists.\n    require(pendingAggregateRoots[_fraudulentRoot] != 0, \"aggregateRoot !exists\");\n    delete pendingAggregateRoots[_fraudulentRoot];\n    emit AggregateRootRemoved(_fraudulentRoot);\n  }\n\n  /**\n   * @notice This function should be callable by owner, and send funds trapped on\n   * a connector to the provided recipient.\n   * @dev Withdraws the entire balance of the contract.\n   *\n   * @param _to The recipient of the funds withdrawn\n   */\n  function withdrawFunds(address _to) public onlyOwner {\n    uint256 amount = address(this).balance;\n    Address.sendValue(payable(_to), amount);\n    emit FundsWithdrawn(_to, amount);\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as it is impossible in the\n   * WatcherClient, and as long as only the owner can remove pending roots in case of\n   * fraud.\n   */\n  function renounceOwnership() public virtual override(ProposedOwnable, WatcherClient) onlyOwner {}\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice This returns the root of all messages with the origin domain as this domain (i.e.\n   * all outbound messages)\n   */\n  function outboundRoot() external view returns (bytes32) {\n    return MERKLE.root();\n  }\n\n  /**\n   * @notice This provides the implementation for what is defined in the ConnectorManager\n   * to avoid storing the domain redundantly\n   */\n  function localDomain() external view override returns (uint32) {\n    return DOMAIN;\n  }\n\n  /**\n   * @notice This returns the root of all messages with the origin domain as this domain (i.e.\n   * all outbound messages)\n   */\n  function send(bytes memory _encodedData) external payable whenNotPaused rateLimited {\n    bytes32 root = MERKLE.root();\n    require(sentMessageRoots[root] == false, \"root already sent\");\n    bytes memory _data = abi.encodePacked(root);\n    _sendMessage(_data, _encodedData);\n    sentMessageRoots[root] = true;\n    emit MessageSent(_data, _encodedData, msg.sender);\n  }\n\n  /**\n   * @notice This function adds transfers to the outbound transfer merkle tree.\n   * @dev The root of this tree will eventually be dispatched to mainnet via `send`. On mainnet (the \"hub\"),\n   * it will be combined into a single aggregate root by RootManager (along with outbound roots from other\n   * chains). This aggregate root will be redistributed to all destination chains.\n   *\n   * NOTE: okay to leave dispatch operational when paused as pause is designed for crosschain interactions\n   */\n  function dispatch(\n    uint32 _destinationDomain,\n    bytes32 _recipientAddress,\n    bytes memory _messageBody\n  ) external onlyAllowlistedSender returns (bytes32) {\n    // Get the next nonce for the destination domain, then increment it.\n    uint32 _nonce = nonces[_destinationDomain]++;\n\n    // Format the message into packed bytes.\n    bytes memory _message = Message.formatMessage(\n      DOMAIN,\n      TypeCasts.addressToBytes32(msg.sender),\n      _nonce,\n      _destinationDomain,\n      _recipientAddress,\n      _messageBody\n    );\n\n    // Insert the hashed message into the Merkle tree.\n    bytes32 _messageHash = keccak256(_message);\n\n    // Returns the root calculated after insertion of message, needed for events for\n    // watchers\n    (bytes32 _root, uint256 _count) = MERKLE.insert(_messageHash);\n\n    // Emit Dispatch event with message information.\n    // NOTE: Current leaf index is count - 1 since new leaf has already been inserted.\n    emit Dispatch(_messageHash, _count - 1, _root, _message);\n    return _messageHash;\n  }\n\n  /**\n   * @notice Must be able to call the `handle` function on the BridgeRouter contract. This is called\n   * on the destination domain to handle incoming messages.\n   *\n   * Proving:\n   * Calculates the expected inbound root from an origin chain given a leaf (message hash),\n   * the index of the leaf, and the merkle proof of inclusion (path). Next, we check to ensure that this\n   * calculated inbound root is included in the current aggregateRoot, given its index in the aggregator\n   * tree and the proof of inclusion.\n   *\n   * Processing:\n   * After all messages have been proven, we dispatch each message to Connext (BridgeRouter) for\n   * execution.\n   *\n   * @dev Currently, ALL messages in a given batch must path to the same shared inboundRoot, meaning they\n   * must all share an origin. See open TODO below for a potential solution to enable multi-origin batches.\n   * @dev Intended to be called by the relayer at specific intervals during runtime.\n   * @dev Will record a calculated root as having been proven if we've already proven that it was included\n   * in the aggregateRoot.\n   *\n   * @param _proofs Batch of Proofs containing messages for proving/processing.\n   * @param _aggregateRoot The target aggregate root we want to prove inclusion for. This root must have\n   * already been delivered to this spoke connector contract and surpassed the validation period.\n   * @param _aggregatePath Merkle path of inclusion for the inbound root.\n   * @param _aggregateIndex Index of the inbound root in the aggregator's merkle tree in the hub.\n   */\n  function proveAndProcess(\n    Proof[] calldata _proofs,\n    bytes32 _aggregateRoot,\n    bytes32[32] calldata _aggregatePath,\n    uint256 _aggregateIndex\n  ) external whenNotPaused nonReentrant {\n    // Sanity check: proofs are included.\n    require(_proofs.length > 0, \"!proofs\");\n\n    // Optimization: calculate the inbound root for the first message in the batch and validate that\n    // it's included in the aggregator tree. We can use this as a reference for every calculation\n    // below to minimize storage access calls.\n    bytes32 _messageHash = keccak256(_proofs[0].message);\n    // TODO: Could use an array of sharedRoots so you can submit a message batch of messages with\n    // different origins.\n    bytes32 _messageRoot = calculateMessageRoot(_messageHash, _proofs[0].path, _proofs[0].index);\n\n    // Handle proving this message root is included in the target aggregate root.\n    proveMessageRoot(_messageRoot, _aggregateRoot, _aggregatePath, _aggregateIndex);\n    // Assuming the inbound message root was proven, the first message is now considered proven.\n    messages[_messageHash] = MessageStatus.Proven;\n\n    // Now we handle proving all remaining messages in the batch - they should all share the same\n    // inbound root!\n    uint256 len = _proofs.length;\n    for (uint32 i = 1; i < len; ) {\n      _messageHash = keccak256(_proofs[i].message);\n      bytes32 _calculatedRoot = calculateMessageRoot(_messageHash, _proofs[i].path, _proofs[i].index);\n      // Make sure this root matches the validated inbound root.\n      require(_calculatedRoot == _messageRoot, \"!sharedRoot\");\n      // Message is proven!\n      messages[_messageHash] = MessageStatus.Proven;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // All messages have been proven. We iterate separately here to process each message in the batch.\n    // NOTE: Going through the proving phase for all messages in the batch BEFORE processing ensures\n    // we hit reverts before we consume unbounded gas from `process` calls.\n    for (uint32 i = 0; i < len; ) {\n      process(_proofs[i].message);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice This is either called by the Connector (AKA `this`) on the spoke (L2) chain after retrieving\n   * latest `aggregateRoot` from the AMB (sourced from mainnet) OR called by the AMB directly.\n   * @dev Must check the msg.sender on the origin chain to ensure only the root manager is passing\n   * these roots.\n   */\n  function receiveAggregateRoot(bytes32 _newRoot) internal {\n    require(_newRoot != bytes32(\"\"), \"new root empty\");\n    require(pendingAggregateRoots[_newRoot] == 0, \"root already pending\");\n    require(!provenAggregateRoots[_newRoot], \"root already proven\");\n\n    pendingAggregateRoots[_newRoot] = block.number;\n    emit AggregateRootReceived(_newRoot);\n  }\n\n  /**\n   * @notice Checks whether the given aggregate root has surpassed the verification period.\n   * @dev Reverts if the given aggregate root is invalid (does not exist) OR has not surpassed\n   * verification period.\n   * @dev If the target aggregate root is pending and HAS surpassed the verification period, then we will\n   * move it over to the proven mapping.\n   * @param _aggregateRoot Target aggregate root to verify.\n   */\n  function verifyAggregateRoot(bytes32 _aggregateRoot) internal {\n    // 0. Sanity check: root is not 0.\n    require(_aggregateRoot != bytes32(\"\"), \"aggregateRoot empty\");\n\n    // 1. Check to see if the target *aggregate* root has already been proven.\n    if (provenAggregateRoots[_aggregateRoot]) {\n      return; // Short circuit if this root is proven.\n    }\n\n    // 2. The target aggregate root must be pending. Aggregate root commit block entry MUST exist.\n    uint256 _aggregateRootCommitBlock = pendingAggregateRoots[_aggregateRoot];\n    require(_aggregateRootCommitBlock != 0, \"aggregateRoot !exist\");\n\n    // 3. Pending aggregate root has surpassed the `delayBlocks` verification period.\n    require(block.number - _aggregateRootCommitBlock >= delayBlocks, \"aggregateRoot !verified\");\n\n    // 4. The target aggregate root has surpassed verification period, we can move it over to the\n    // proven mapping.\n    provenAggregateRoots[_aggregateRoot] = true;\n    emit AggregateRootVerified(_aggregateRoot);\n    // May as well delete the pending aggregate root entry for the gas refund: it should no longer\n    // be needed.\n    delete pendingAggregateRoots[_aggregateRoot];\n  }\n\n  /**\n   * @notice Checks whether a given message is valid. If so, calculates the expected inbound root from an\n   * origin chain given a leaf (message hash), the index of the leaf, and the merkle proof of inclusion.\n   * @dev Reverts if message's MessageStatus != None (i.e. if message was already proven or processed).\n   *\n   * @param _messageHash Leaf (message hash) that requires proving.\n   * @param _messagePath Merkle path of inclusion for the leaf.\n   * @param _messageIndex Index of leaf in the merkle tree on the origin chain of the message.\n   * @return bytes32 Calculated root.\n   **/\n  function calculateMessageRoot(\n    bytes32 _messageHash,\n    bytes32[32] calldata _messagePath,\n    uint256 _messageIndex\n  ) internal view returns (bytes32) {\n    // Ensure that the given message has not already been proven and processed.\n    require(messages[_messageHash] == MessageStatus.None, \"!MessageStatus.None\");\n    // Calculate the expected inbound root from the message origin based on the proof.\n    // NOTE: Assuming a valid message was submitted with correct path/index, this should be an inbound root\n    // that the hub has received. If the message were invalid, the root calculated here would not exist in the\n    // aggregate root.\n    return MerkleLib.branchRoot(_messageHash, _messagePath, _messageIndex);\n  }\n\n  /**\n   * @notice Prove an inbound message root from another chain is included in the target aggregateRoot.\n   * @param _messageRoot The message root we want to verify.\n   * @param _aggregateRoot The target aggregate root we want to prove inclusion for. This root must have\n   * already been delivered to this spoke connector contract and surpassed the validation period.\n   * @param _aggregatePath Merkle path of inclusion for the inbound root.\n   * @param _aggregateIndex Index of the inbound root in the aggregator's merkle tree in the hub.\n   */\n  function proveMessageRoot(\n    bytes32 _messageRoot,\n    bytes32 _aggregateRoot,\n    bytes32[32] calldata _aggregatePath,\n    uint256 _aggregateIndex\n  ) internal {\n    // 0. Check to see if the root for this batch has already been proven.\n    if (provenMessageRoots[_messageRoot]) {\n      // NOTE: It seems counter-intuitive, but we do NOT need to prove the given `_aggregateRoot` param\n      // is valid IFF the `_messageRoot` has already been proven; we know that the `_messageRoot` has to\n      // have been included in *some* proven aggregate root historically.\n      return;\n    }\n\n    // 1. Ensure aggregate root has been proven.\n    verifyAggregateRoot(_aggregateRoot);\n\n    // 2. Calculate an aggregate root, given this inbound root (as leaf), path (proof), and index.\n    bytes32 _calculatedAggregateRoot = MerkleLib.branchRoot(_messageRoot, _aggregatePath, _aggregateIndex);\n\n    // 3. Check to make sure it matches the current aggregate root we have stored.\n    require(_calculatedAggregateRoot == _aggregateRoot, \"invalid inboundRoot\");\n\n    // This inbound root has been proven. We should specify that to optimize future calls.\n    provenMessageRoots[_messageRoot] = true;\n    emit MessageProven(_messageRoot, _aggregateRoot, _aggregateIndex);\n  }\n\n  /**\n   * @notice Given formatted message, attempts to dispatch message payload to end recipient.\n   * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)\n   * Reverts if formatted message's destination domain is not the Replica's domain,\n   * if message has not been proven,\n   * or if not enough gas is provided for the dispatch transaction.\n   * @param _message Formatted message\n   * @return _success TRUE iff dispatch transaction succeeded\n   */\n  function process(bytes memory _message) internal returns (bool _success) {\n    bytes29 _m = _message.ref(0);\n    // ensure message was meant for this domain\n    require(_m.destination() == DOMAIN, \"!destination\");\n    // ensure message has been proven\n    bytes32 _messageHash = _m.keccak();\n    require(messages[_messageHash] == MessageStatus.Proven, \"!proven\");\n    // check re-entrancy guard\n    // require(entered == 1, \"!reentrant\");\n    // entered = 0;\n    // update message status as processed\n    messages[_messageHash] = MessageStatus.Processed;\n    // A call running out of gas TYPICALLY errors the whole tx. We want to\n    // a) ensure the call has a sufficient amount of gas to make a\n    //    meaningful state change.\n    // b) ensure that if the subcall runs out of gas, that the tx as a whole\n    //    does not revert (i.e. we still mark the message processed)\n    // To do this, we require that we have enough gas to process\n    // and still return. We then delegate only the minimum processing gas.\n    require(gasleft() > PROCESS_GAS + RESERVE_GAS - 1, \"!gas\");\n    // get the message recipient\n    address _recipient = _m.recipientAddress();\n    // set up for assembly call\n    uint256 _gas = PROCESS_GAS;\n    uint16 _maxCopy = 256;\n    // allocate memory for returndata\n    bytes memory _returnData = new bytes(_maxCopy);\n    bytes memory _calldata = abi.encodeWithSignature(\n      \"handle(uint32,uint32,bytes32,bytes)\",\n      _m.origin(),\n      _m.nonce(),\n      _m.sender(),\n      _m.body().clone()\n    );\n\n    (_success, _returnData) = ExcessivelySafeCall.excessivelySafeCall(_recipient, _gas, 0, _maxCopy, _calldata);\n\n    // emit process results\n    emit Process(_messageHash, _success, _returnData);\n  }\n}\n"
    },
    "contracts/shared/libraries/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// Taken from: https://github.com/nomad-xyz/ExcessivelySafeCall\n// NOTE: There is a difference between npm latest and github main versions\n// where the latest github version allows you to specify an ether value.\n\nlibrary ExcessivelySafeCall {\n  uint256 constant LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n  /// @notice Use when you _really_ really _really_ don't trust the called\n  /// contract. This prevents the called contract from causing reversion of\n  /// the caller in as many ways as we can.\n  /// @dev The main difference between this and a solidity low-level call is\n  /// that we limit the number of bytes that the callee can cause to be\n  /// copied to caller memory. This prevents stupid things like malicious\n  /// contracts returning 10,000,000 bytes causing a local OOG when copying\n  /// to memory.\n  /// @param _target The address to call\n  /// @param _gas The amount of gas to forward to the remote contract\n  /// @param _value The value in wei to send to the remote contract\n  /// @param _maxCopy The maximum number of bytes of returndata to copy\n  /// to memory.\n  /// @param _calldata The data to send to the remote contract\n  /// @return success and returndata, as `.call()`. Returndata is capped to\n  /// `_maxCopy` bytes.\n  function excessivelySafeCall(\n    address _target,\n    uint256 _gas,\n    uint256 _value,\n    uint16 _maxCopy,\n    bytes memory _calldata\n  ) internal returns (bool, bytes memory) {\n    // set up for assembly call\n    uint256 _toCopy;\n    bool _success;\n    bytes memory _returnData = new bytes(_maxCopy);\n    // dispatch message to recipient\n    // by assembly calling \"handle\" function\n    // we call via assembly to avoid memcopying a very large returndata\n    // returned by a malicious contract\n    assembly {\n      _success := call(\n        _gas, // gas\n        _target, // recipient\n        _value, // ether value\n        add(_calldata, 0x20), // inloc\n        mload(_calldata), // inlen\n        0, // outloc\n        0 // outlen\n      )\n      // limit our copy to 256 bytes\n      _toCopy := returndatasize()\n      if gt(_toCopy, _maxCopy) {\n        _toCopy := _maxCopy\n      }\n      // Store the length of the copied bytes\n      mstore(_returnData, _toCopy)\n      // copy the bytes from returndata[0:_toCopy]\n      returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n    }\n    return (_success, _returnData);\n  }\n\n  /// @notice Use when you _really_ really _really_ don't trust the called\n  /// contract. This prevents the called contract from causing reversion of\n  /// the caller in as many ways as we can.\n  /// @dev The main difference between this and a solidity low-level call is\n  /// that we limit the number of bytes that the callee can cause to be\n  /// copied to caller memory. This prevents stupid things like malicious\n  /// contracts returning 10,000,000 bytes causing a local OOG when copying\n  /// to memory.\n  /// @param _target The address to call\n  /// @param _gas The amount of gas to forward to the remote contract\n  /// @param _maxCopy The maximum number of bytes of returndata to copy\n  /// to memory.\n  /// @param _calldata The data to send to the remote contract\n  /// @return success and returndata, as `.call()`. Returndata is capped to\n  /// `_maxCopy` bytes.\n  function excessivelySafeStaticCall(\n    address _target,\n    uint256 _gas,\n    uint16 _maxCopy,\n    bytes memory _calldata\n  ) internal view returns (bool, bytes memory) {\n    // set up for assembly call\n    uint256 _toCopy;\n    bool _success;\n    bytes memory _returnData = new bytes(_maxCopy);\n    // dispatch message to recipient\n    // by assembly calling \"handle\" function\n    // we call via assembly to avoid memcopying a very large returndata\n    // returned by a malicious contract\n    assembly {\n      _success := staticcall(\n        _gas, // gas\n        _target, // recipient\n        add(_calldata, 0x20), // inloc\n        mload(_calldata), // inlen\n        0, // outloc\n        0 // outlen\n      )\n      // limit our copy to 256 bytes\n      _toCopy := returndatasize()\n      if gt(_toCopy, _maxCopy) {\n        _toCopy := _maxCopy\n      }\n      // Store the length of the copied bytes\n      mstore(_returnData, _toCopy)\n      // copy the bytes from returndata[0:_toCopy]\n      returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n    }\n    return (_success, _returnData);\n  }\n\n  /**\n   * @notice Swaps function selectors in encoded contract calls\n   * @dev Allows reuse of encoded calldata for functions with identical\n   * argument types but different names. It simply swaps out the first 4 bytes\n   * for the new selector. This function modifies memory in place, and should\n   * only be used with caution.\n   * @param _newSelector The new 4-byte selector\n   * @param _buf The encoded contract args\n   */\n  function swapSelector(bytes4 _newSelector, bytes memory _buf) internal pure {\n    require(_buf.length > 4 - 1);\n    uint256 _mask = LOW_28_MASK;\n    assembly {\n      // load the first word of\n      let _word := mload(add(_buf, 0x20))\n      // mask out the top 4 bytes\n      // /x\n      _word := and(_word, _mask)\n      _word := or(_newSelector, _word)\n      mstore(add(_buf, 0x20), _word)\n    }\n  }\n}\n"
    },
    "contracts/messaging/libraries/MerkleLib.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title MerkleLib\n * @author Illusory Systems Inc.\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\n **/\nlibrary MerkleLib {\n  // ========== Custom Errors ===========\n\n  error MerkleLib__insert_treeIsFull();\n\n  // ============ Constants =============\n\n  uint256 internal constant TREE_DEPTH = 32;\n  uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\n\n  /**\n   * @dev Z_i represent the hash values at different heights for a binary tree with leaf values equal to `0`.\n   * (e.g. Z_1 is the keccak256 hash of (0x0, 0x0), Z_2 is the keccak256 hash of (Z_1, Z_1), etc...)\n   * Z_0 is the bottom of the 33-layer tree, Z_32 is the top (i.e. root).\n   * Used to shortcut calculation in root calculation methods below.\n   */\n  bytes32 internal constant Z_0 = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n  bytes32 internal constant Z_1 = hex\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\";\n  bytes32 internal constant Z_2 = hex\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\";\n  bytes32 internal constant Z_3 = hex\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\";\n  bytes32 internal constant Z_4 = hex\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\";\n  bytes32 internal constant Z_5 = hex\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\";\n  bytes32 internal constant Z_6 = hex\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\";\n  bytes32 internal constant Z_7 = hex\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\";\n  bytes32 internal constant Z_8 = hex\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\";\n  bytes32 internal constant Z_9 = hex\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\";\n  bytes32 internal constant Z_10 = hex\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\";\n  bytes32 internal constant Z_11 = hex\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\";\n  bytes32 internal constant Z_12 = hex\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\";\n  bytes32 internal constant Z_13 = hex\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\";\n  bytes32 internal constant Z_14 = hex\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\";\n  bytes32 internal constant Z_15 = hex\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\";\n  bytes32 internal constant Z_16 = hex\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\";\n  bytes32 internal constant Z_17 = hex\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\";\n  bytes32 internal constant Z_18 = hex\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\";\n  bytes32 internal constant Z_19 = hex\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\";\n  bytes32 internal constant Z_20 = hex\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\";\n  bytes32 internal constant Z_21 = hex\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\";\n  bytes32 internal constant Z_22 = hex\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\";\n  bytes32 internal constant Z_23 = hex\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\";\n  bytes32 internal constant Z_24 = hex\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\";\n  bytes32 internal constant Z_25 = hex\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\";\n  bytes32 internal constant Z_26 = hex\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\";\n  bytes32 internal constant Z_27 = hex\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\";\n  bytes32 internal constant Z_28 = hex\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\";\n  bytes32 internal constant Z_29 = hex\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\";\n  bytes32 internal constant Z_30 = hex\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\";\n  bytes32 internal constant Z_31 = hex\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\";\n  bytes32 internal constant Z_32 = hex\"27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\";\n\n  // ============= Structs ==============\n\n  /**\n   * @notice Struct representing incremental merkle tree. Contains current\n   * branch and the number of inserted leaves in the tree.\n   **/\n  struct Tree {\n    bytes32[TREE_DEPTH] branch;\n    uint256 count;\n  }\n\n  // ========= Write Methods =========\n\n  /**\n   * @notice Inserts a given node (leaf) into merkle tree. Operates on an in-memory tree and\n   * returns an updated version of that tree.\n   * @dev Reverts if the tree is already full.\n   * @param node Element to insert into tree.\n   * @return Tree Updated tree.\n   **/\n  function insert(Tree memory tree, bytes32 node) internal pure returns (Tree memory) {\n    // Update tree.count to increase the current count by 1 since we'll be including a new node.\n    uint256 size = ++tree.count;\n    if (size > MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\n\n    // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\n    // the active branch. Each loop we cut size in half, hashing the inserted node up the active\n    // branch along the way.\n    for (uint256 i; i < TREE_DEPTH; ) {\n      // Check if the current size is odd; if so, we set this index in the branch to be the node.\n      if ((size & 1) == 1) {\n        // If i > 0, then this node will be a hash of the original node with every layer up\n        // until layer `i`.\n        tree.branch[i] = node;\n        return tree;\n      }\n      // If the size is not yet odd, we hash the current index in the tree branch with the node.\n      node = keccak256(abi.encodePacked(tree.branch[i], node));\n      size >>= 1; // Cut size in half (statement equivalent to: `size /= 2`).\n\n      unchecked {\n        ++i;\n      }\n    }\n    // As the loop should always end prematurely with the `return` statement, this code should\n    // be unreachable. We revert here just to be safe.\n    revert MerkleLib__insert_treeIsFull();\n  }\n\n  // ========= Read Methods =========\n\n  /**\n   * @notice Calculates and returns tree's current root.\n   * @return _current bytes32 root.\n   **/\n  function root(Tree storage tree) internal view returns (bytes32 _current) {\n    uint256 _index = tree.count;\n\n    if (_index == 0) {\n      return Z_32;\n    }\n\n    uint256 i;\n    assembly {\n      let TREE_SLOT := tree.slot\n\n      for {\n\n      } true {\n\n      } {\n        for {\n\n        } true {\n\n        } {\n          if and(_index, 1) {\n            mstore(0, sload(TREE_SLOT))\n            mstore(0x20, Z_0)\n            _current := keccak256(0, 0x40)\n            break\n          }\n\n          if and(_index, shl(1, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 1)))\n            mstore(0x20, Z_1)\n            _current := keccak256(0, 0x40)\n            i := 1\n            break\n          }\n\n          if and(_index, shl(2, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 2)))\n            mstore(0x20, Z_2)\n            _current := keccak256(0, 0x40)\n            i := 2\n            break\n          }\n\n          if and(_index, shl(3, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 3)))\n            mstore(0x20, Z_3)\n            _current := keccak256(0, 0x40)\n            i := 3\n            break\n          }\n\n          if and(_index, shl(4, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 4)))\n            mstore(0x20, Z_4)\n            _current := keccak256(0, 0x40)\n            i := 4\n            break\n          }\n\n          if and(_index, shl(5, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 5)))\n            mstore(0x20, Z_5)\n            _current := keccak256(0, 0x40)\n            i := 5\n            break\n          }\n\n          if and(_index, shl(6, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 6)))\n            mstore(0x20, Z_6)\n            _current := keccak256(0, 0x40)\n            i := 6\n            break\n          }\n\n          if and(_index, shl(7, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 7)))\n            mstore(0x20, Z_7)\n            _current := keccak256(0, 0x40)\n            i := 7\n            break\n          }\n\n          if and(_index, shl(8, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 8)))\n            mstore(0x20, Z_8)\n            _current := keccak256(0, 0x40)\n            i := 8\n            break\n          }\n\n          if and(_index, shl(9, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 9)))\n            mstore(0x20, Z_9)\n            _current := keccak256(0, 0x40)\n            i := 9\n            break\n          }\n\n          if and(_index, shl(10, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 10)))\n            mstore(0x20, Z_10)\n            _current := keccak256(0, 0x40)\n            i := 10\n            break\n          }\n\n          if and(_index, shl(11, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 11)))\n            mstore(0x20, Z_11)\n            _current := keccak256(0, 0x40)\n            i := 11\n            break\n          }\n\n          if and(_index, shl(12, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 12)))\n            mstore(0x20, Z_12)\n            _current := keccak256(0, 0x40)\n            i := 12\n            break\n          }\n\n          if and(_index, shl(13, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 13)))\n            mstore(0x20, Z_13)\n            _current := keccak256(0, 0x40)\n            i := 13\n            break\n          }\n\n          if and(_index, shl(14, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 14)))\n            mstore(0x20, Z_14)\n            _current := keccak256(0, 0x40)\n            i := 14\n            break\n          }\n\n          if and(_index, shl(15, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 15)))\n            mstore(0x20, Z_15)\n            _current := keccak256(0, 0x40)\n            i := 15\n            break\n          }\n\n          if and(_index, shl(16, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 16)))\n            mstore(0x20, Z_16)\n            _current := keccak256(0, 0x40)\n            i := 16\n            break\n          }\n\n          if and(_index, shl(17, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 17)))\n            mstore(0x20, Z_17)\n            _current := keccak256(0, 0x40)\n            i := 17\n            break\n          }\n\n          if and(_index, shl(18, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 18)))\n            mstore(0x20, Z_18)\n            _current := keccak256(0, 0x40)\n            i := 18\n            break\n          }\n\n          if and(_index, shl(19, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 19)))\n            mstore(0x20, Z_19)\n            _current := keccak256(0, 0x40)\n            i := 19\n            break\n          }\n\n          if and(_index, shl(20, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 20)))\n            mstore(0x20, Z_20)\n            _current := keccak256(0, 0x40)\n            i := 20\n            break\n          }\n\n          if and(_index, shl(21, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 21)))\n            mstore(0x20, Z_21)\n            _current := keccak256(0, 0x40)\n            i := 21\n            break\n          }\n\n          if and(_index, shl(22, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 22)))\n            mstore(0x20, Z_22)\n            _current := keccak256(0, 0x40)\n            i := 22\n            break\n          }\n\n          if and(_index, shl(23, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 23)))\n            mstore(0x20, Z_23)\n            _current := keccak256(0, 0x40)\n            i := 23\n            break\n          }\n\n          if and(_index, shl(24, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 24)))\n            mstore(0x20, Z_24)\n            _current := keccak256(0, 0x40)\n            i := 24\n            break\n          }\n\n          if and(_index, shl(25, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 25)))\n            mstore(0x20, Z_25)\n            _current := keccak256(0, 0x40)\n            i := 25\n            break\n          }\n\n          if and(_index, shl(26, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 26)))\n            mstore(0x20, Z_26)\n            _current := keccak256(0, 0x40)\n            i := 26\n            break\n          }\n\n          if and(_index, shl(27, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 27)))\n            mstore(0x20, Z_27)\n            _current := keccak256(0, 0x40)\n            i := 27\n            break\n          }\n\n          if and(_index, shl(28, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 28)))\n            mstore(0x20, Z_28)\n            _current := keccak256(0, 0x40)\n            i := 28\n            break\n          }\n\n          if and(_index, shl(29, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 29)))\n            mstore(0x20, Z_29)\n            _current := keccak256(0, 0x40)\n            i := 29\n            break\n          }\n\n          if and(_index, shl(30, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 30)))\n            mstore(0x20, Z_30)\n            _current := keccak256(0, 0x40)\n            i := 30\n            break\n          }\n\n          if and(_index, shl(31, 1)) {\n            mstore(0, sload(add(TREE_SLOT, 31)))\n            mstore(0x20, Z_31)\n            _current := keccak256(0, 0x40)\n            i := 31\n            break\n          }\n\n          _current := Z_32\n          i := 32\n          break\n        }\n\n        if gt(i, 30) {\n          break\n        }\n\n        {\n          if lt(i, 1) {\n            switch and(_index, shl(1, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_1)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 1)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 2) {\n            switch and(_index, shl(2, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_2)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 2)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 3) {\n            switch and(_index, shl(3, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_3)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 3)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 4) {\n            switch and(_index, shl(4, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_4)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 4)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 5) {\n            switch and(_index, shl(5, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_5)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 5)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 6) {\n            switch and(_index, shl(6, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_6)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 6)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 7) {\n            switch and(_index, shl(7, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_7)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 7)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 8) {\n            switch and(_index, shl(8, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_8)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 8)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 9) {\n            switch and(_index, shl(9, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_9)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 9)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 10) {\n            switch and(_index, shl(10, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_10)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 10)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 11) {\n            switch and(_index, shl(11, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_11)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 11)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 12) {\n            switch and(_index, shl(12, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_12)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 12)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 13) {\n            switch and(_index, shl(13, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_13)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 13)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 14) {\n            switch and(_index, shl(14, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_14)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 14)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 15) {\n            switch and(_index, shl(15, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_15)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 15)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 16) {\n            switch and(_index, shl(16, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_16)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 16)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 17) {\n            switch and(_index, shl(17, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_17)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 17)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 18) {\n            switch and(_index, shl(18, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_18)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 18)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 19) {\n            switch and(_index, shl(19, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_19)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 19)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 20) {\n            switch and(_index, shl(20, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_20)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 20)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 21) {\n            switch and(_index, shl(21, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_21)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 21)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 22) {\n            switch and(_index, shl(22, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_22)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 22)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 23) {\n            switch and(_index, shl(23, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_23)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 23)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 24) {\n            switch and(_index, shl(24, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_24)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 24)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 25) {\n            switch and(_index, shl(25, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_25)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 25)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 26) {\n            switch and(_index, shl(26, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_26)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 26)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 27) {\n            switch and(_index, shl(27, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_27)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 27)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 28) {\n            switch and(_index, shl(28, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_28)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 28)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 29) {\n            switch and(_index, shl(29, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_29)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 29)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 30) {\n            switch and(_index, shl(30, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_30)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 30)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n\n          if lt(i, 31) {\n            switch and(_index, shl(31, 1))\n            case 0 {\n              mstore(0, _current)\n              mstore(0x20, Z_31)\n            }\n            default {\n              mstore(0, sload(add(TREE_SLOT, 31)))\n              mstore(0x20, _current)\n            }\n\n            _current := keccak256(0, 0x40)\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  /**\n   * @notice Calculates and returns the merkle root for the given leaf `_item`,\n   * a merkle branch, and the index of `_item` in the tree.\n   * @param _item Merkle leaf\n   * @param _branch Merkle proof\n   * @param _index Index of `_item` in tree\n   * @return _current Calculated merkle root\n   **/\n  function branchRoot(\n    bytes32 _item,\n    bytes32[TREE_DEPTH] memory _branch,\n    uint256 _index\n  ) internal pure returns (bytes32 _current) {\n    assembly {\n      _current := _item\n      let BRANCH_DATA_OFFSET := _branch\n      let f\n\n      f := shl(5, and(_index, 1))\n      mstore(f, _current)\n      mstore(sub(0x20, f), mload(BRANCH_DATA_OFFSET))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(1, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 1))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(2, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 2))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(3, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 3))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(4, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 4))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(5, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 5))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(6, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 6))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(7, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 7))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(8, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 8))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(9, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 9))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(10, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 10))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(11, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 11))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(12, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 12))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(13, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 13))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(14, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 14))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(15, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 15))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(16, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 16))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(17, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 17))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(18, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 18))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(19, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 19))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(20, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 20))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(21, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 21))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(22, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 22))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(23, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 23))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(24, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 24))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(25, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 25))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(26, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 26))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(27, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 27))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(28, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 28))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(29, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 29))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(30, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 30))))\n      _current := keccak256(0, 0x40)\n\n      f := shl(5, iszero(and(_index, shl(31, 1))))\n      mstore(sub(0x20, f), _current)\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 31))))\n      _current := keccak256(0, 0x40)\n    }\n  }\n}\n"
    },
    "contracts/messaging/libraries/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {TypedMemView} from \"../../shared/libraries/TypedMemView.sol\";\nimport {TypeCasts} from \"../../shared/libraries/TypeCasts.sol\";\n\n/**\n * @title Message Library\n * @author Illusory Systems Inc.\n * @notice Library for formatted messages used by Home and Replica.\n **/\nlibrary Message {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // Number of bytes in formatted message before `body` field\n  uint256 internal constant PREFIX_LENGTH = 76;\n\n  /**\n   * @notice Returns formatted (packed) message with provided fields\n   * @param _originDomain Domain of home chain\n   * @param _sender Address of sender as bytes32\n   * @param _nonce Destination-specific nonce\n   * @param _destinationDomain Domain of destination chain\n   * @param _recipient Address of recipient on destination chain as bytes32\n   * @param _messageBody Raw bytes of message body\n   * @return Formatted message\n   **/\n  function formatMessage(\n    uint32 _originDomain,\n    bytes32 _sender,\n    uint32 _nonce,\n    uint32 _destinationDomain,\n    bytes32 _recipient,\n    bytes memory _messageBody\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(_originDomain, _sender, _nonce, _destinationDomain, _recipient, _messageBody);\n  }\n\n  /**\n   * @notice Returns leaf of formatted message with provided fields.\n   * @param _origin Domain of home chain\n   * @param _sender Address of sender as bytes32\n   * @param _nonce Destination-specific nonce number\n   * @param _destination Domain of destination chain\n   * @param _recipient Address of recipient on destination chain as bytes32\n   * @param _body Raw bytes of message body\n   * @return Leaf (hash) of formatted message\n   **/\n  function messageHash(\n    uint32 _origin,\n    bytes32 _sender,\n    uint32 _nonce,\n    uint32 _destination,\n    bytes32 _recipient,\n    bytes memory _body\n  ) internal pure returns (bytes32) {\n    return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _body));\n  }\n\n  /// @notice Returns message's origin field\n  function origin(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(0, 4));\n  }\n\n  /// @notice Returns message's sender field\n  function sender(bytes29 _message) internal pure returns (bytes32) {\n    return _message.index(4, 32);\n  }\n\n  /// @notice Returns message's nonce field\n  function nonce(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(36, 4));\n  }\n\n  /// @notice Returns message's destination field\n  function destination(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(40, 4));\n  }\n\n  /// @notice Returns message's recipient field as bytes32\n  function recipient(bytes29 _message) internal pure returns (bytes32) {\n    return _message.index(44, 32);\n  }\n\n  /// @notice Returns message's recipient field as an address\n  function recipientAddress(bytes29 _message) internal pure returns (address) {\n    return TypeCasts.bytes32ToAddress(recipient(_message));\n  }\n\n  /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n  function body(bytes29 _message) internal pure returns (bytes29) {\n    return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n  }\n\n  function leaf(bytes29 _message) internal pure returns (bytes32) {\n    uint256 loc = _message.loc();\n    uint256 len = _message.len();\n    /*\n    prev:\n    return\n      messageHash(\n        origin(_message),\n        sender(_message),\n        nonce(_message),\n        destination(_message),\n        recipient(_message),\n        TypedMemView.clone(body(_message))\n      );\n\n      below added for gas optimization\n     */\n    bytes32 hash;\n    assembly {\n      hash := keccak256(loc, len)\n    }\n    return hash;\n  }\n}\n"
    },
    "contracts/messaging/libraries/RateLimited.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice An abstract contract intended to manage the rate limiting aspect of spoke\n * connector messaging. Rate limiting the number of messages we can send over a span of\n * blocks is used to mitigate key DoSing vectors for transporting messages between chains.\n */\nabstract contract RateLimited {\n  // ========== Custom Errors ===========\n\n  error RateLimited__rateLimited_messageSendRateExceeded();\n\n  // ============ Events ============\n\n  event SendRateLimitUpdated(address updater, uint256 newRateLimit);\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice The number of blocks required between message sending events.\n   * @dev NOTE: This value is 0 by default, meaning that rate limiting functionality\n   * will naturally be disabled by default.\n   */\n  uint256 public rateLimitBlocks;\n\n  /**\n   * @notice Tracks the last block that we sent a message.\n   */\n  uint256 public lastSentBlock;\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Checks to see if we can send this block, given the current rate limit\n   * setting and the last block we sent a message. If rate limit has been surpassed,\n   * we update the `lastSentBlock` to be the current block.\n   */\n  modifier rateLimited() {\n    // Check to make sure we have surpassed the number of rate limit blocks.\n    if (lastSentBlock + rateLimitBlocks > block.number) {\n      revert RateLimited__rateLimited_messageSendRateExceeded();\n    }\n    // Update the last block we sent a message to be the current one.\n    lastSentBlock = block.number;\n    _;\n  }\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Update the current rate limit to a new value.\n   */\n  function _setRateLimitBlocks(uint256 _newRateLimit) internal {\n    require(_newRateLimit != rateLimitBlocks, \"!new rate limit\");\n    // NOTE: Setting the block rate limit interval to 0 will result in rate limiting\n    // being disabled.\n    rateLimitBlocks = _newRateLimit;\n    emit SendRateLimitUpdated(msg.sender, _newRateLimit);\n  }\n}\n"
    },
    "contracts/messaging/MerkleTreeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnableUpgradeable} from \"../shared/ProposedOwnableUpgradeable.sol\";\nimport {MerkleLib} from \"./libraries/MerkleLib.sol\";\n\n/**\n * @title MerkleTreeManager\n * @notice Contains a Merkle tree instance and exposes read/write functions for the tree.\n * @dev On the hub domain there are two MerkleTreeManager contracts, one for the hub and one for the MainnetSpokeConnector.\n */\ncontract MerkleTreeManager is ProposedOwnableUpgradeable {\n  // ========== Custom Errors ===========\n\n  error MerkleTreeManager__setArborist_zeroAddress();\n  error MerkleTreeManager__setArborist_alreadyArborist();\n\n  // ============ Events ============\n\n  event ArboristUpdated(address previous, address updated);\n\n  // ============ Libraries ============\n\n  using MerkleLib for MerkleLib.Tree;\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice Core data structure with which this contract is tasked with keeping custody.\n   * Writable only by the designated arborist.\n   */\n  MerkleLib.Tree public tree;\n\n  /**\n   * @notice The arborist contract that has permission to write to this tree.\n   * @dev This could be the root manager contract or a spoke connector contract, for example.\n   */\n  address public arborist;\n\n  // ============ Modifiers ============\n\n  modifier onlyArborist() {\n    require(arborist == msg.sender, \"!arborist\");\n    _;\n  }\n\n  // ============ Getters ============\n\n  /**\n   * @notice Returns the current branch.\n   */\n  function branch() public view returns (bytes32[32] memory) {\n    return tree.branch;\n  }\n\n  /**\n   * @notice Calculates and returns the current root.\n   */\n  function root() public view returns (bytes32) {\n    return tree.root();\n  }\n\n  /**\n   * @notice Returns the number of inserted leaves in the tree (current index).\n   */\n  function count() public view returns (uint256) {\n    return tree.count;\n  }\n\n  /**\n   * @notice Convenience getter: returns the root and count.\n   */\n  function rootAndCount() public view returns (bytes32, uint256) {\n    return (tree.root(), tree.count);\n  }\n\n  // ======== Initializer =========\n\n  function initialize(address _arborist) public initializer {\n    __MerkleTreeManager_init(_arborist);\n    __ProposedOwnable_init();\n  }\n\n  /**\n   * @dev Initializes MerkleTreeManager instance. Sets the msg.sender as the initial permissioned\n   */\n  function __MerkleTreeManager_init(address _arborist) internal onlyInitializing {\n    __MerkleTreeManager_init_unchained(_arborist);\n  }\n\n  function __MerkleTreeManager_init_unchained(address _arborist) internal onlyInitializing {\n    arborist = _arborist;\n  }\n\n  // ============ Admin Functions ==============\n\n  /**\n   * @notice Method for the current arborist to assign write permissions to a new arborist.\n   * @param newArborist The new address to set as the current arborist.\n   */\n  function setArborist(address newArborist) external onlyOwner {\n    if (newArborist == address(0)) revert MerkleTreeManager__setArborist_zeroAddress();\n    address current = arborist;\n    if (current == newArborist) revert MerkleTreeManager__setArborist_alreadyArborist();\n\n    // Emit updated event\n    emit ArboristUpdated(current, newArborist);\n\n    arborist = newArborist;\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as there is a possibility the\n   * arborist may change.\n   */\n  function renounceOwnership() public virtual override onlyOwner {}\n\n  // ========= Public Functions =========\n\n  /**\n   * @notice Inserts the given leaves into the tree.\n   * @param leaves The leaves to be inserted into the tree.\n   * @return _root Current root for convenience.\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\n   * provided for convenience.\n   */\n  function insert(bytes32[] memory leaves) public onlyArborist returns (bytes32 _root, uint256 _count) {\n    // For > 1 leaf, considerably more efficient to put this tree into memory, conduct operations,\n    // then re-assign it to storage - *especially* if we have multiple leaves to insert.\n    MerkleLib.Tree memory _tree = tree;\n\n    uint256 leafCount = leaves.length;\n    for (uint256 i; i < leafCount; ) {\n      // Insert the new node (using in-memory method).\n      _tree = _tree.insert(leaves[i]);\n      unchecked {\n        ++i;\n      }\n    }\n    // Write the newly updated tree to storage.\n    tree = _tree;\n\n    // Get return details for convenience.\n    _count = _tree.count;\n    // NOTE: Root calculation method currently reads from storage only.\n    _root = tree.root();\n  }\n\n  /**\n   * @notice Inserts the given leaf into the tree.\n   * @param leaf The leaf to be inserted into the tree.\n   * @return _root Current root for convenience.\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\n   * provided for convenience.\n   */\n  function insert(bytes32 leaf) public onlyArborist returns (bytes32 _root, uint256 _count) {\n    // Insert the new node.\n    tree = tree.insert(leaf);\n    _count = tree.count;\n    _root = tree.root();\n  }\n\n  // ============ Upgrade Gap ============\n  uint256[48] private __GAP; // gap for upgrade safety\n}\n"
    },
    "contracts/messaging/WatcherClient.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport {ProposedOwnable} from \"../shared/ProposedOwnable.sol\";\nimport {WatcherManager} from \"./WatcherManager.sol\";\n\n/**\n * @notice This contract abstracts the functionality of the watcher manager.\n * Contracts can inherit this contract to be able to use the watcher manager's shared watcher set.\n */\n\ncontract WatcherClient is ProposedOwnable, Pausable {\n  // ============ Events ============\n  /**\n   * @notice Emitted when the manager address changes\n   * @param watcherManager The updated manager\n   */\n  event WatcherManagerChanged(address watcherManager);\n\n  // ============ Properties ============\n  /**\n   * @notice The `WatcherManager` contract governs the watcher allowlist.\n   * @dev Multiple clients can share a watcher set using the same manager\n   */\n  WatcherManager public watcherManager;\n\n  // ============ Constructor ============\n  constructor(address _watcherManager) ProposedOwnable() {\n    watcherManager = WatcherManager(_watcherManager);\n  }\n\n  // ============ Modifiers ============\n  /**\n   * @notice Enforces the sender is the watcher\n   */\n  modifier onlyWatcher() {\n    require(watcherManager.isWatcher(msg.sender), \"!watcher\");\n    _;\n  }\n\n  // ============ Admin fns ============\n  /**\n   * @notice Owner can enroll a watcher (abilities are defined by inheriting contracts)\n   */\n  function setWatcherManager(address _watcherManager) external onlyOwner {\n    require(_watcherManager != address(watcherManager), \"already watcher manager\");\n    watcherManager = WatcherManager(_watcherManager);\n    emit WatcherManagerChanged(_watcherManager);\n  }\n\n  /**\n   * @notice Owner can unpause contracts if fraud is detected by watchers\n   */\n  function unpause() external onlyOwner whenPaused {\n    _unpause();\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as only the owner\n   * is able to unpause the contracts. You can still propose `address(0)`,\n   * but it will never be accepted.\n   */\n  function renounceOwnership() public virtual override onlyOwner {}\n\n  // ============ Watcher fns ============\n\n  /**\n   * @notice Watchers can pause contracts if fraud is detected\n   */\n  function pause() external onlyWatcher whenNotPaused {\n    _pause();\n  }\n}\n"
    },
    "contracts/messaging/connectors/Connector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../../shared/ProposedOwnable.sol\";\nimport {IConnector} from \"../interfaces/IConnector.sol\";\n\n/**\n * @title Connector\n * @author Connext Labs, Inc.\n * @notice This contract has the messaging interface functions used by all connectors.\n *\n * @dev This contract stores information about mirror connectors, but can be used as a\n * base for contracts that do not have a mirror (i.e. the connector handling messaging on\n * mainnet). In this case, the `mirrorConnector` and `MIRROR_DOMAIN`\n * will be empty\n *\n * @dev If ownership is renounced, this contract will be unable to update its `mirrorConnector`\n * or `mirrorGas`\n */\nabstract contract Connector is ProposedOwnable, IConnector {\n  // ========== Custom Errors ===========\n\n  error Connector__processMessage_notUsed();\n\n  // ============ Events ============\n\n  event NewConnector(\n    uint32 indexed domain,\n    uint32 indexed mirrorDomain,\n    address amb,\n    address rootManager,\n    address mirrorConnector\n  );\n\n  event MirrorConnectorUpdated(address previous, address current);\n\n  // ============ Public Storage ============\n\n  /**\n   * @notice The domain of this Messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable DOMAIN;\n\n  /**\n   * @notice Address of the AMB on this domain.\n   */\n  address public immutable AMB;\n\n  /**\n   * @notice RootManager contract address.\n   */\n  address public immutable ROOT_MANAGER;\n\n  /**\n   * @notice The domain of the corresponding messaging (i.e. Connector) contract.\n   */\n  uint32 public immutable MIRROR_DOMAIN;\n\n  /**\n   * @notice Connector on L2 for L1 connectors, and vice versa.\n   */\n  address public mirrorConnector;\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Errors if the msg.sender is not the registered AMB\n   */\n  modifier onlyAMB() {\n    require(msg.sender == AMB, \"!AMB\");\n    _;\n  }\n\n  /**\n   * @notice Errors if the msg.sender is not the registered ROOT_MANAGER\n   */\n  modifier onlyRootManager() {\n    // NOTE: RootManager will be zero address for spoke connectors.\n    // Only root manager can dispatch a message to spokes/L2s via the hub connector.\n    require(msg.sender == ROOT_MANAGER, \"!rootManager\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new HubConnector instance\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\n   * for optimism, there is one connector on optimism and one connector on mainnet)\n   * @param _domain The domain this connector lives on\n   * @param _mirrorDomain The spoke domain\n   * @param _amb The address of the amb on the domain this connector lives on\n   * @param _rootManager The address of the RootManager on mainnet\n   * @param _mirrorConnector The address of the spoke connector\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector\n  ) ProposedOwnable() {\n    // set the owner\n    _setOwner(msg.sender);\n\n    // sanity checks on values\n    require(_domain != 0, \"empty domain\");\n    require(_rootManager != address(0), \"empty rootManager\");\n    // see note at top of contract on why the mirror values are not sanity checked\n\n    // set immutables\n    DOMAIN = _domain;\n    AMB = _amb;\n    ROOT_MANAGER = _rootManager;\n    MIRROR_DOMAIN = _mirrorDomain;\n    // set mutables if defined\n    if (_mirrorConnector != address(0)) {\n      _setMirrorConnector(_mirrorConnector);\n    }\n\n    emit NewConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector);\n  }\n\n  // ============ Receivable ============\n  /**\n   * @notice Connectors may need to receive native asset to handle fees when sending a\n   * message\n   */\n  receive() external payable {}\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Sets the address of the l2Connector for this domain\n   */\n  function setMirrorConnector(address _mirrorConnector) public onlyOwner {\n    _setMirrorConnector(_mirrorConnector);\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Processes a message received by an AMB\n   * @dev This is called by AMBs to process messages originating from mirror connector\n   */\n  function processMessage(bytes memory _data) external onlyAMB {\n    _processMessage(_data);\n    emit MessageProcessed(_data, msg.sender);\n  }\n\n  /**\n   * @notice Checks the cross domain sender for a given address\n   */\n  function verifySender(address _expected) external returns (bool) {\n    return _verifySender(_expected);\n  }\n\n  // ============ Virtual Functions ============\n\n  /**\n   * @notice This function is used by the Connext contract on the l2 domain to send a message to the\n   * l1 domain (i.e. called by Connext on optimism to send a message to mainnet with roots)\n   * @param _data The contents of the message\n   * @param _encodedData Data used to send the message; specific to connector\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal virtual;\n\n  /**\n   * @notice This function is used by the AMBs to handle incoming messages. Should store the latest\n   * root generated on the l2 domain.\n   */\n  function _processMessage(\n    bytes memory /* _data */\n  ) internal virtual {\n    // By default, reverts. This is to ensure the call path is not used unless this function is\n    // overridden by the inheriting class\n    revert Connector__processMessage_notUsed();\n  }\n\n  /**\n   * @notice Verify that the msg.sender is the correct AMB contract, and that the message's origin sender\n   * is the expected address.\n   * @dev Should be overridden by the implementing Connector contract.\n   */\n  function _verifySender(address _expected) internal virtual returns (bool);\n\n  // ============ Private Functions ============\n\n  function _setMirrorConnector(address _mirrorConnector) internal virtual {\n    emit MirrorConnectorUpdated(mirrorConnector, _mirrorConnector);\n    mirrorConnector = _mirrorConnector;\n  }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/shared/ProposedOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {ProposedOwnable} from \"./ProposedOwnable.sol\";\n\nabstract contract ProposedOwnableUpgradeable is Initializable, ProposedOwnable {\n  /**\n   * @dev Initializes the contract setting the deployer as the initial\n   */\n  function __ProposedOwnable_init() internal onlyInitializing {\n    __ProposedOwnable_init_unchained();\n  }\n\n  function __ProposedOwnable_init_unchained() internal onlyInitializing {\n    _setOwner(msg.sender);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[47] private __GAP;\n}\n"
    },
    "contracts/shared/ProposedOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"./interfaces/IProposedOwnable.sol\";\n\n/**\n * @title ProposedOwnable\n * @notice Contract module which provides a basic access control mechanism,\n * where there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed via a two step process:\n * 1. Call `proposeOwner`\n * 2. Wait out the delay period\n * 3. Call `acceptOwner`\n *\n * @dev This module is used through inheritance. It will make available the\n * modifier `onlyOwner`, which can be applied to your functions to restrict\n * their use to the owner.\n *\n * @dev The majority of this code was taken from the openzeppelin Ownable\n * contract\n *\n */\nabstract contract ProposedOwnable is IProposedOwnable {\n  // ========== Custom Errors ===========\n\n  error ProposedOwnable__onlyOwner_notOwner();\n  error ProposedOwnable__onlyProposed_notProposedOwner();\n  error ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\n  error ProposedOwnable__renounceOwnership_noProposal();\n  error ProposedOwnable__renounceOwnership_invalidProposal();\n\n  // ============ Properties ============\n\n  address private _owner;\n\n  address private _proposed;\n  uint256 private _proposedOwnershipTimestamp;\n\n  uint256 private constant _delay = 7 days;\n\n  // ======== Getters =========\n\n  /**\n   * @notice Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposed() public view virtual returns (address) {\n    return _proposed;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposedTimestamp() public view virtual returns (uint256) {\n    return _proposedOwnershipTimestamp;\n  }\n\n  /**\n   * @notice Returns the delay period before a new owner can be accepted.\n   */\n  function delay() public view virtual returns (uint256) {\n    return _delay;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if called by any account other than the proposed owner.\n   */\n  modifier onlyProposed() {\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\n    _;\n  }\n\n  /**\n   * @notice Throws if the ownership delay has not elapsed\n   */\n  modifier ownershipDelayElapsed() {\n    // Ensure delay has elapsed\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\n      revert ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\n    _;\n  }\n\n  /**\n   * @notice Indicates if the ownership has been renounced() by\n   * checking if current owner is address(0)\n   */\n  function renounced() public view returns (bool) {\n    return _owner == address(0);\n  }\n\n  // ======== External =========\n\n  /**\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\n   * newly proposed owner as step 1 in a 2-step process\n   */\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\n    // Contract as source of truth\n    if (_proposed == newlyProposed && _proposedOwnershipTimestamp != 0)\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\n\n    // Sanity check: reasonable proposal\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\n\n    _setProposed(newlyProposed);\n  }\n\n  /**\n   * @notice Renounces ownership of the contract after a delay\n   */\n  function renounceOwnership() public virtual onlyOwner ownershipDelayElapsed {\n    // Ensure there has been a proposal cycle started\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\n\n    // Require proposed is set to 0\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(address(0));\n  }\n\n  /**\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function acceptProposedOwner() public virtual onlyProposed ownershipDelayElapsed {\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\n    // is 0-d out and this check is implicitly enforced by modifier\n\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\n    // the only time this would happen is if the _proposed was never\n    // set (will fail from modifier) or if the owner == _proposed (checked\n    // above)\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(_proposed);\n  }\n\n  // ======== Internal =========\n\n  function _setOwner(address newOwner) internal {\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n    delete _proposedOwnershipTimestamp;\n    delete _proposed;\n  }\n\n  function _setProposed(address newlyProposed) private {\n    _proposedOwnershipTimestamp = block.timestamp;\n    _proposed = newlyProposed;\n    emit OwnershipProposed(newlyProposed);\n  }\n}\n"
    },
    "contracts/messaging/WatcherManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../shared/ProposedOwnable.sol\";\n\n/**\n * @notice This contract manages a set of watchers. This is meant to be used as a shared resource that contracts can\n * inherit to make use of the same watcher set.\n */\n\ncontract WatcherManager is ProposedOwnable {\n  // ============ Events ============\n  event WatcherAdded(address watcher);\n\n  event WatcherRemoved(address watcher);\n\n  // ============ Properties ============\n  mapping(address => bool) public isWatcher;\n\n  // ============ Constructor ============\n  constructor() ProposedOwnable() {\n    _setOwner(msg.sender);\n  }\n\n  // ============ Modifiers ============\n\n  // ============ Admin fns ============\n  /**\n   * @dev Owner can enroll a watcher (abilities are defined by inheriting contracts)\n   */\n  function addWatcher(address _watcher) external onlyOwner {\n    require(!isWatcher[_watcher], \"already watcher\");\n    isWatcher[_watcher] = true;\n    emit WatcherAdded(_watcher);\n  }\n\n  /**\n   * @dev Owner can unenroll a watcher (abilities are defined by inheriting contracts)\n   */\n  function removeWatcher(address _watcher) external onlyOwner {\n    require(isWatcher[_watcher], \"!exist\");\n    delete isWatcher[_watcher];\n    emit WatcherRemoved(_watcher);\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as the watcher griefing\n   * vector exists. You can still propose `address(0)`, but it will never be accepted.\n   */\n  function renounceOwnership() public virtual override onlyOwner {}\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/messaging/interfaces/IConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IProposedOwnable} from \"../../shared/interfaces/IProposedOwnable.sol\";\n\n/**\n * @notice This interface is what the Connext contract will send and receive messages through.\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\n * could be Nomad or a generic AMB under the hood).\n *\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\n *\n * Flow from transfer from polygon to optimism:\n * 1. User calls `xcall` with destination specified\n * 2. This will swap in to the bridge assets\n * 3. The swapped assets will get burned\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\n *    to the root\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\n *    mainnet. This is done on all \"spoke\" domains.\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\n *    root from all of the AMBs\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\n *      tree root\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\n *    process on the `Connext` contract\n * 9. Takes minted bridge tokens and credits the LP\n *\n * AMB requirements:\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\n * - Ability to read *our root* from the AMB\n *\n * AMBs:\n * - PoS bridge from polygon\n * - arbitrum bridge\n * - optimism bridge\n * - gnosis chain\n * - bsc (use multichain for messaging)\n */\ninterface IConnector is IProposedOwnable {\n  // ============ Events ============\n  /**\n   * @notice Emitted whenever a message is successfully sent over an AMB\n   * @param data The contents of the message\n   * @param encodedData Data used to send the message; specific to connector\n   * @param caller Who called the function (sent the message)\n   */\n  event MessageSent(bytes data, bytes encodedData, address caller);\n\n  /**\n   * @notice Emitted whenever a message is successfully received over an AMB\n   * @param data The contents of the message\n   * @param caller Who called the function\n   */\n  event MessageProcessed(bytes data, address caller);\n\n  // ============ Public fns ============\n\n  function processMessage(bytes memory _data) external;\n\n  function verifySender(address _expected) external returns (bool);\n}\n"
    },
    "contracts/messaging/connectors/zksync/ZkSyncSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// Importing interfaces and addresses of the system contracts\nimport \"@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol\";\n\nimport {SpokeConnector} from \"../SpokeConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\ncontract ZkSyncSpokeConnector is SpokeConnector {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager\n  )\n    SpokeConnector(\n      _domain,\n      _mirrorDomain,\n      _amb,\n      _rootManager,\n      _mirrorConnector,\n      _processGas,\n      _reserveGas,\n      _delayBlocks,\n      _merkle,\n      _watcherManager\n    )\n  {}\n\n  // ============ Override Fns ============\n  function _verifySender(address _expected) internal view override returns (bool) {\n    // NOTE: msg.sender is preserved for L1 -> L2 calls. See the L2 contract in the tutorial\n    // here: https://v2-docs.zksync.io/dev/tutorials/cross-chain-tutorial.html#l2-counter\n\n    // NOTE: if an attacker controls the msg.sender, they could insert malicious roots.\n    // From the zksync team:\n    // 'We have a different address generation schema that would not allow address\n    // to be claimed on L2 by an adversary. Even if you deploy same address and same\n    // private key it would still be different'\n    return msg.sender == _expected;\n  }\n\n  /**\n   * @dev Sends `outboundRoot` to root manager on l1\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    // Dispatch message through zkSync AMB\n    L1_MESSENGER_CONTRACT.sendToL1(_data);\n  }\n\n  /**\n   * @dev Handles an incoming `aggregateRoot`\n   * NOTE: Could store latest root sent and prove aggregate root\n   */\n  function _processMessage(bytes memory _data) internal override {\n    // enforce this came from connector on l2\n    require(_verifySender(mirrorConnector), \"!mirrorConnector\");\n    // get the data (should be the aggregate root)\n    require(_data.length == 32, \"!length\");\n    // set the aggregate root\n    receiveAggregateRoot(bytes32(_data));\n  }\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccountCodeStorage.sol\";\nimport \"./interfaces/INonceHolder.sol\";\nimport \"./interfaces/IContractDeployer.sol\";\nimport \"./interfaces/IKnownCodesStorage.sol\";\nimport \"./interfaces/IImmutableSimulator.sol\";\nimport \"./interfaces/IEthToken.sol\";\nimport \"./interfaces/IL1Messenger.sol\";\nimport \"./interfaces/ISystemContext.sol\";\n\nuint160 constant SYSTEM_CONTRACTS_OFFSET = 0x8000; // 2^15\nuint160 constant MAX_SYSTEM_CONTRACT_ADDRESS = 0xffff; // 2^16 - 1\n\naddress constant ECRECOVER_SYSTEM_CONTRACT = address(0x01);\naddress constant SHA256_SYSTEM_CONTRACT = address(0x02);\n\naddress payable constant BOOTLOADER_FORMAL_ADDRESS = payable(address(SYSTEM_CONTRACTS_OFFSET + 0x01));\nIAccountCodeStorage constant ACCOUNT_CODE_STORAGE_SYSTEM_CONTRACT = IAccountCodeStorage(address(SYSTEM_CONTRACTS_OFFSET + 0x02));\nINonceHolder constant NONCE_HOLDER_SYSTEM_CONTRACT = INonceHolder(address(SYSTEM_CONTRACTS_OFFSET + 0x03));\nIKnownCodesStorage constant KNOWN_CODE_STORAGE_CONTRACT = IKnownCodesStorage(address(SYSTEM_CONTRACTS_OFFSET + 0x04));\nIImmutableSimulator constant IMMUTABLE_SIMULATOR_SYSTEM_CONTRACT = IImmutableSimulator(address(SYSTEM_CONTRACTS_OFFSET + 0x05));\nIContractDeployer constant DEPLOYER_SYSTEM_CONTRACT = IContractDeployer(address(SYSTEM_CONTRACTS_OFFSET + 0x06));\n\n// A contract that is allowed to deploy any codehash\n// on any address. To be used only during an upgrade.\naddress constant FORCE_DEPLOYER = address(SYSTEM_CONTRACTS_OFFSET + 0x07);\nIL1Messenger constant L1_MESSENGER_CONTRACT = IL1Messenger(address(SYSTEM_CONTRACTS_OFFSET + 0x08));\naddress constant MSG_VALUE_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x09);\n\nIEthToken constant ETH_TOKEN_SYSTEM_CONTRACT = IEthToken(address(SYSTEM_CONTRACTS_OFFSET + 0x0a));\n\naddress constant KECCAK256_SYSTEM_CONTRACT = address(SYSTEM_CONTRACTS_OFFSET + 0x10);\n\nISystemContext constant SYSTEM_CONTEXT_CONTRACT = ISystemContext(payable(address(SYSTEM_CONTRACTS_OFFSET + 0x0b)));\n\nbytes32 constant DEFAULT_ACCOUNT_CODE_HASH = 0x00;\n\n// The number of bytes that are published during the contract deployment\n// in addition to the bytecode itself.\nuint256 constant BYTECODE_PUBLISHING_OVERHEAD = 100;\n\nuint256 constant MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT = 2**128;\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IContractDeployer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface IContractDeployer {\n    event ContractDeployed(address indexed deployerAddress, bytes32 indexed bytecodeHash, address indexed contractAddress);\n\n    function getNewAddressCreate2(\n        address _sender,\n        bytes32 _bytecodeHash,\n        bytes32 _salt,\n        bytes calldata _input\n    ) external pure returns (address newAddress);\n \n    function getNewAddressCreate(\n        address _sender,\n        uint256 _senderNonce\n    ) external pure returns (address newAddress);\n\n    function create2 (\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress, bytes memory constructorRevertData);\n\n    function create2Account (\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress, bytes memory constructorRevertData);\n\n    /// @dev While the `_salt` parameter is not used anywhere here, \n    /// it is still needed for consistency between `create` and\n    /// `create2` functions (required by the compiler).\n    function create (\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress, bytes memory constructorRevertData);\n\n    /// @dev While `_salt` is never used here, we leave it here as a parameter\n    /// for the consistency with the `create` function.\n    function createAccount (\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes calldata _input\n    ) external payable returns (address newAddress, bytes memory constructorRevertData);\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IAccountCodeStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface IAccountCodeStorage {\n    function storeCodeHash(address _address, bytes32 _hash) external;\n\n    function getRawCodeHash(address _address) external view returns (bytes32 codeHash);\n\n    function getCodeHash(uint256 _input) external returns (bytes32 codeHash);\n    \n    function getCodeSize(uint256 _input) external returns (uint256 codeSize);\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IImmutableSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nstruct ImmutableData {\n    uint256 index;\n    bytes32 value;\n}\n\ninterface IImmutableSimulator {\n    function getImmutable(address _dest, uint256 _index) external view returns (bytes32);\n\n    function setImmutables(address _dest, ImmutableData[] calldata immutables) external;\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/INonceHolder.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @author Matter Labs\n * @dev Interface of the nonce holder contract -- a contract used by the system to ensure\n * that there is always a unique identifier for a transaction with a particular account (we call it nonce).\n * In other words, the pair of (address, nonce) should always be unique.\n * @dev Custom accounts should use methods of this contract to store nonces or other possible unique identifiers \n * for the transaction.\n */\ninterface INonceHolder {\n    /// @dev Returns the current minimal nonce for account.\n    function getMinNonce(address _address) external view returns(uint256);\n\n    /// @dev Returns the raw version of the current minimal nonce \n    /// (equal to minNonce + 2^128 * deployment nonce).\n    function getRawNonce(address _address) external view returns (uint256);\n\n    /// @dev Increases the minimal nonce for the msg.sender.\n    function increaseMinNonce(uint256 _value) external returns (uint256);\n\n    /// @dev Sets the nonce value `key` as used.\n    function setValueUnderNonce(uint256 _key, uint256 _value) external;\n\n    /// @dev Gets the value stored inside a custom nonce.\n    function getValueUnderNonce(uint256 _key) external view returns (uint256);\n\n    /// @dev A convenience method to increment the minimal nonce if it is equal\n    /// to the `_expectedNonce`.\n    function incrementMinNonceIfEquals(uint256 _expectedNonce) external;\n\n    /// @dev Returns the deployment nonce for the accounts used for CREATE opcode.\n    function getDeploymentNonce(address _address) external view returns (uint256);\n\n    /// @dev Increments the deployment nonce for the account and returns the previous one.\n    function incrementDeploymentNonce(address _address) external returns (uint256);\n\n    /// @dev Determines whether a certain nonce has been already used for an account.\n    function validateNonceUsage(address _address, uint256 _key, bool _shouldBeUsed) external view;\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IEthToken.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface IEthToken {\n    function balanceOf(address) external returns (uint256);\n    \n    function transferFromTo(address _from, address _to, uint256 _amount) external;\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IL1Messenger.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface IL1Messenger {\n    // Possibly in the future we will be able to track the messages sent to L1 with \n    // some hooks in the VM. For now, it is much easier to track them with L2 events.\n    event L1MessageSent(address indexed _sender, bytes32 indexed _hash, bytes _message);\n\n    function sendToL1(bytes memory _message) external returns (bytes32);\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/IKnownCodesStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface IKnownCodesStorage {\n    event MarkedAsKnown(bytes32 indexed bytecodeHash, bool indexed sendBytecodeToL1);\n\n    function markFactoryDeps(bool _shouldSendToL1, bytes32[] calldata _hashes) external;\n\n    function getMarker(bytes32 _hash) external view returns (uint256);\n}\n"
    },
    "@matterlabs/zksync-contracts/l2/system-contracts/interfaces/ISystemContext.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @author Matter Labs\n * @notice Contract that stores some of the context variables, that may be either \n * block-scoped, tx-scoped or system-wide.\n */\ninterface ISystemContext {\n    function chainId() external view returns (uint256);\n\n    function origin() external view returns (address);\n\n    function ergsPrice() external view returns (uint256);\n\n    function blockErgsLimit() external view returns (uint256);\n\n    function coinbase() external view returns (address);\n\n    function difficulty() external view returns (uint256);\n\n    function msize() external view returns (uint256);\n\n    function baseFee() external view returns (uint256);\n\n    function blockHash(uint256 _block) external view returns (bytes32);\n\n    function getBlockHashEVM(uint256 _block) external view returns (bytes32);\n\n    function getBlockNumberAndTimestamp() external view returns (uint256 blockNumber, uint256 blockTimestamp);\n\n    // Note, that for now, the implementation of the bootloader allows this variables to \n    // be incremented multiple times inside a block, so it should not relied upon right now.\n    function getBlockNumber() external view returns (uint256);\n\n    function getBlockTimestamp() external view returns (uint256);\n}\n"
    },
    "contracts/messaging/connectors/zksync/ZkSyncHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// Importing zkSync contract interface\nimport \"@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IZkSync.sol\";\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {HubConnector} from \"../HubConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\nimport {GasCap} from \"../GasCap.sol\";\n\ncontract ZkSyncHubConnector is HubConnector, GasCap {\n  // ============ Storage ============\n\n  // NOTE: This is needed because we need to track the roots we've\n  // already sent across chains. When sending an zkSync message, we send calldata\n  // for Connector.processMessage. At any point these messages could be processed\n  // before the timeout using `processFromRoot` or after the timeout using `process`\n  // we track the roots sent here to ensure we process each root once\n  mapping(bytes32 => bool) public processed;\n\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    address _stateCommitmentChain,\n    uint256 _gasCap\n  ) HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) GasCap(_gasCap) {}\n\n  // ============ Override Fns ============\n  function _verifySender(address) internal pure override returns (bool) {\n    // NOTE: sender from L2 is asserted in the `processMessageFromRoot` function. Cross domain\n    // sender is packed in with the L2Message struct, so you should not be verifying the\n    // sender using this method. Always return false.\n    // See docs here: https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block\n    return false;\n  }\n\n  /**\n   * @dev Sends `aggregateRoot` to messaging on l2\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should include gasPrice value for `l2TransactionBaseCOst` specialized calldata\n    require(_encodedData.length == 32, \"!data length\");\n    // Should always be dispatching the aggregate root\n    require(_data.length == 32, \"!length\");\n    // Get the calldata\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\n    // Get the gas data\n    uint256 gasPrice = abi.decode(_encodedData, (uint256));\n\n    // Declare the ergs limit\n    uint256 ERGS_LIMIT = 10000;\n\n    // Get the max supplied\n    uint256 fee = _getGas(msg.value);\n\n    // Ensure it is above minimum\n    require(fee > IZkSync(AMB).l2TransactionBaseCost(gasPrice, ERGS_LIMIT, uint32(_calldata.length)), \"!fees\");\n\n    // Dispatch message\n    // https://v2-docs.zksync.io/dev/developer-guides/Bridging/l1-l2.html#structure\n    // calling L2 smart contract from L1 Example contract\n    // note: msg.value must be passed in and can be retrieved from the AMB view function `l2TransactionBaseCost`\n    // https://v2-docs.zksync.io/dev/developer-guides/Bridging/l1-l2.html#using-contract-interface-in-your-project\n    IZkSync(AMB).requestL2Transaction{value: fee}(\n      // The address of the L2 contract to call\n      mirrorConnector,\n      // We pass no ETH with the call\n      0,\n      // Encoding the calldata for the execute\n      _calldata,\n      // Ergs limit\n      ERGS_LIMIT,\n      // factory dependencies\n      new bytes[](0)\n    );\n  }\n\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\n  // `processMessageFromRoot` flow.\n\n  /**\n   * @notice Processes message and proves inclusion of that message in the root.\n   *\n   * @dev modified from: https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block\n   */\n  function processMessageFromRoot(\n    // zkSync block number in which the message was sent\n    uint32 _l2BlockNumber,\n    // Message index, that can be received via API\n    uint256 _l2MessageIndex,\n    // The L2 transaction number in a block, in which the log was sent\n    uint16 _l2TxNumberInBlock,\n    // The message that was sent from l2\n    bytes calldata _message,\n    // Merkle proof for the message\n    bytes32[] calldata _proof\n  ) external {\n    // sanity check root length (32 bytes root)\n    require(_message.length == 32, \"!length\");\n\n    IZkSync zksync = IZkSync(AMB);\n    L2Message memory message = L2Message({\n      txNumberInBlock: _l2TxNumberInBlock,\n      sender: mirrorConnector,\n      data: _message\n    });\n\n    bool success = zksync.proveL2MessageInclusion(_l2BlockNumber, _l2MessageIndex, message, _proof);\n    require(success, \"!proven\");\n\n    bytes32 _root = bytes32(_message);\n\n    // NOTE: there are no guarantees the messages are processed once, so processed roots\n    // must be tracked within the connector. See:\n    // https://v2-docs.zksync.io/dev/developer-guides/Bridging/l2-l1.html#prove-inclusion-of-the-message-into-the-l2-block\n    if (!processed[_root]) {\n      // set root to processed\n      processed[_root] = true;\n      // update the root on the root manager\n      IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, _root);\n      emit MessageProcessed(_message, msg.sender);\n    } // otherwise root was already sent to root manager\n  }\n}\n"
    },
    "contracts/messaging/interfaces/IRootManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\ninterface IRootManager {\n  /**\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\n   * spoke domains.\n   * @dev This must read information for the root from the registered AMBs.\n   */\n  function propagate(\n    address[] calldata _connectors,\n    uint256[] calldata _fees,\n    bytes[] memory _encodedData\n  ) external payable;\n\n  /**\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\n   * inbound root.\n   * @dev This must read information for the root from the registered AMBs\n   */\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\n}\n"
    },
    "contracts/messaging/connectors/HubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Connector} from \"./Connector.sol\";\n\n/**\n * @title HubConnector\n * @author Connext Labs, Inc.\n * @notice This contract implements the messaging functions needed on the hub-side of a given AMB.\n * The HubConnector has a limited set of functionality compared to the SpokeConnector, namely that\n * it contains no logic to store or prove messages.\n *\n * @dev This contract should be deployed on the hub-side of an AMB (i.e. on L1), and contracts\n * which extend this should implement the virtual functions defined in the BaseConnector class\n */\nabstract contract HubConnector is Connector {\n  /**\n   * @notice Creates a new HubConnector instance\n   * @dev The connectors are deployed such that there is one on each side of an AMB (i.e.\n   * for optimism, there is one connector on optimism and one connector on mainnet)\n   * @param _domain The domain this connector lives on\n   * @param _mirrorDomain The spoke domain\n   * @param _amb The address of the amb on the domain this connector lives on\n   * @param _rootManager The address of the RootManager on mainnet\n   * @param _mirrorConnector The address of the spoke connector\n   */\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector\n  ) Connector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) {}\n\n  // ============ Public fns ============\n  /**\n   * @notice Sends a message over the amb\n   * @dev This is called by the root manager *only* on mainnet to propagate the aggregate root\n   */\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable onlyRootManager {\n    _sendMessage(_data, _encodedData);\n    emit MessageSent(_data, _encodedData, msg.sender);\n  }\n}\n"
    },
    "contracts/messaging/connectors/GasCap.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../../shared/ProposedOwnable.sol\";\n\nabstract contract GasCap is ProposedOwnable {\n  // ============ Storage ============\n  /**\n   * @notice The gnosis amb requires destination gas to be specified on the origin.\n   * The gas used will be passed in by the relayer to allow for real-time estimates,\n   * but will be capped at the admin-set cap.\n   */\n  uint256 gasCap;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when admin updates the gas cap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event GasCapUpdated(uint256 _previous, uint256 _updated);\n\n  // ============ Constructor ============\n  constructor(uint256 _gasCap) {\n    _setGasCap(_gasCap);\n  }\n\n  // ============ Admin Fns ============\n  function setGasCap(uint256 _gasCap) public onlyOwner {\n    _setGasCap(_gasCap);\n  }\n\n  // ============ Internal Fns ============\n\n  /**\n   * @notice Used (by admin) to update the gas cap\n   * @param _gasCap The new value\n   */\n  function _setGasCap(uint256 _gasCap) internal {\n    emit GasCapUpdated(gasCap, _gasCap);\n    gasCap = _gasCap;\n  }\n\n  /**\n   * @notice Used to get the gas to use. Will be the original value IFF it\n   * is less than the cap\n   * @param _gas The proposed gas value\n   */\n  function _getGas(uint256 _gas) internal view returns (uint256) {\n    if (_gas > gasCap) {\n      _gas = gasCap;\n    }\n    return _gas;\n  }\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IZkSync.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8;\n\nimport \"./IMailbox.sol\";\nimport \"./IGovernance.sol\";\nimport \"./IExecutor.sol\";\nimport \"./IDiamondCut.sol\";\nimport \"./IGetters.sol\";\n\ninterface IZkSync is IMailbox, IGovernance, IExecutor, IDiamondCut, IGetters {}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IMailbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8;\n\nimport {L2Log, L2Message} from \"../Storage.sol\";\nimport \"../../common/interfaces/IERC20.sol\";\n\ninterface IMailbox {\n    /// @dev Structure that includes all fields of the L2 transaction\n    /// @dev The hash of this structure is the \"canonical L2 transaction hash\" and can be used as a unique identifier of a tx\n    /// @param txType The tx type number, depending on which the L2 transaction can be interpreted differently\n    /// @param from The sender's address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param to The recipient's address. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param ergsLimit Ergs limit on L2 transaction. Analog to the `gasLimit` on an L1 transactions\n    /// @param ergsPerPubdataByteLimit Maximum number of ergs that will cost one byte of pubdata (every piece of data that will be stored on L1 as calldata)\n    /// @param maxFeePerErg The absolute maximum sender willing to pay per unit of ergs to get the transaction included in a block. Analog to the EIP-1559 `maxFeePerGas` on an L1 transactions\n    /// @param maxPriorityFeePerErg The additional fee that is paid directly to the validator to incentivize them to include the transaction in a block. Analog to the EIP-1559 `maxPriorityFeePerGas` on an L1 transactions\n    /// @param paymaster The address of the EIP-4337 paymaster, that will pay fees for the transaction. `uint256` type for possible address format changes and maintaining backward compatibility\n    /// @param reserved The fixed-length fields for usage in a future extension of transaction formats\n    /// @param data The calldata that is transmitted for the transaction call\n    /// @param signature An abstract set of bytes that are used for transaction authorization\n    /// @param factoryDeps The set of L2 bytecode hashes whose preimages were shown on L1\n    /// @param paymasterInput The arbitrary-length data that is used as a calldata to the paymaster pre-call\n    /// @param reservedDynamic The arbitrary-length field for usage in a future extension of transaction formats\n    struct L2CanonicalTransaction {\n        uint256 txType;\n        uint256 from;\n        uint256 to;\n        uint256 ergsLimit;\n        uint256 ergsPerPubdataByteLimit;\n        uint256 maxFeePerErg;\n        uint256 maxPriorityFeePerErg;\n        uint256 paymaster;\n        // In the future, we might want to add some\n        // new fields to the struct. The `txData` struct\n        // is to be passed to account and any changes to its structure\n        // would mean a breaking change to these accounts. To prevent this,\n        // we should keep some fields as \"reserved\".\n        // It is also recommended that their length is fixed, since\n        // it would allow easier proof integration (in case we will need\n        // some special circuit for preprocessing transactions).\n        uint256[6] reserved;\n        bytes data;\n        bytes signature;\n        uint256[] factoryDeps;\n        bytes paymasterInput;\n        // Reserved dynamic type for the future use-case. Using it should be avoided,\n        // But it is still here, just in case we want to enable some additional functionality.\n        bytes reservedDynamic;\n    }\n\n    function proveL2MessageInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Message calldata _message,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function proveL2LogInclusion(\n        uint256 _blockNumber,\n        uint256 _index,\n        L2Log memory _log,\n        bytes32[] calldata _proof\n    ) external view returns (bool);\n\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) external pure returns (L2CanonicalTransaction memory);\n\n    function requestL2Transaction(\n        address _contractAddressL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) external payable returns (bytes32 txHash);\n\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n        uint256 _ergsLimit,\n        uint32 _calldataLength\n    ) external view returns (uint256);\n\n    /// @notice New priority request event. Emitted when a request is placed into the priority queue\n    /// @param txId Serial number of the priority operation\n    /// @param txHash keccak256 hash of encoded transaction representation\n    /// @param expirationBlock Ethereum block number up to which priority request should be processed\n    /// @param transaction The whole transaction structure that is requested to be executed on L2\n    /// @param factoryDeps An array of bytecodes that were shown in the L1 public data. Will be marked as known bytecodes in L2\n    event NewPriorityRequest(\n        uint256 txId,\n        bytes32 txHash,\n        uint64 expirationBlock,\n        L2CanonicalTransaction transaction,\n        bytes[] factoryDeps\n    );\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8;\n\ninterface IGovernance {\n    function setPendingGovernor(address _newPendingGovernor) external;\n\n    function acceptGovernor() external;\n\n    function setValidator(address _validator, bool _active) external;\n\n    function setL2BootloaderBytecodeHash(bytes32 _l2BootloaderBytecodeHash) external;\n\n    function setL2DefaultAccountBytecodeHash(bytes32 _l2DefaultAccountBytecodeHash) external;\n\n    function setPorterAvailability(bool _isPorterAvailable) external;\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a bootloader (start program)\n    event NewL2BootloaderBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Сhanges to the bytecode that is used in L2 as a default account\n    event NewL2DefaultAccountBytecodeHash(bytes32 indexed previousBytecodeHash, bytes32 indexed newBytecodeHash);\n\n    /// @notice Porter availability status changes\n    event IsPorterAvailableStatusUpdate(bool isPorterAvailable);\n\n    /// @notice Validator's status changed\n    event ValidatorStatusUpdate(address indexed validatorAddress, bool isActive);\n\n    /// @notice pendingGovernor is changed\n    /// @dev Also emitted when new governor is accepted and in this case, `newPendingGovernor` would be zero address\n    event NewPendingGovernor(address indexed oldPendingGovernor, address indexed newPendingGovernor);\n\n    /// @notice Governor changed\n    event NewGovernor(address indexed newGovernor);\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8;\n\nimport \"../libraries/Diamond.sol\";\n\ninterface IDiamondCut {\n    function proposeDiamondCut(Diamond.FacetCut[] calldata _facetCuts, address _initAddress) external;\n\n    function cancelDiamondCutProposal() external;\n\n    function executeDiamondCutProposal(Diamond.DiamondCutData calldata _diamondCut) external;\n\n    function emergencyFreezeDiamond() external;\n\n    function unfreezeDiamond() external;\n\n    function approveEmergencyDiamondCutAsSecurityCouncilMember(bytes32 _diamondCutHash) external;\n\n    // FIXME: token holders should have the ability to cancel the upgrade\n\n    event DiamondCutProposal(Diamond.FacetCut[] _facetCuts, address _initAddress);\n\n    event DiamondCutProposalCancelation();\n\n    event DiamondCutProposalExecution(Diamond.DiamondCutData _diamondCut);\n\n    event EmergencyFreeze();\n\n    event Unfreeze();\n\n    event EmergencyDiamondCutApproved(address _address);\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8;\n\ninterface IExecutor {\n    /// @notice Rollup block stored data\n    /// @param blockNumber Rollup block number\n    /// @param blockHash Hash of L2 block\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this block\n    /// @param timestamp Rollup block timestamp, have the same format as Ethereum block constant\n    /// @param stateRoot Merkle root of the rollup state tree\n    /// @param commitment Verified input for the zkSync circuit\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n        bytes32 blockHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new block\n    /// @param blockNumber Number of the committed block\n    /// @param timestamp Unix timestamp denoting the start of the block execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param ergsPerPubdataByteInBlock Price in ergs per one byte of published pubdata in block\n    /// @param ergsPerCodeDecommittmentWord Price in ergs per decommittment of one machine word from l2 bytecode\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param l2LogsTreeRoot The root hash of the tree that contains all L2 -> L1 logs in the block\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param initialStorageChanges Storage write access as a concatenation key-value\n    /// @param repeatedStorageChanges Storage write access as a concatenation index-value\n    /// @param l2Logs concatenation of all L2 -> L1 logs in the block\n    /// @param l2ArbitraryLengthMessages array of hash preimages that were sent as value of L2 logs by special system L2 contract\n    /// @param factoryDeps array of l2 bytecodes that were marked as known on L2\n    struct CommitBlockInfo {\n        uint64 blockNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint16 ergsPerCodeDecommittmentWord;\n        uint256 numberOfLayer1Txs;\n        bytes32 l2LogsTreeRoot;\n        bytes32 priorityOperationsHash;\n        bytes initialStorageChanges;\n        bytes repeatedStorageChanges;\n        bytes l2Logs;\n        bytes[] l2ArbitraryLengthMessages;\n        bytes[] factoryDeps;\n    }\n\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\n    /// TODO: The verifier integration is not finished yet, change the structure for compatibility later\n    struct ProofInput {\n        uint256[] recurisiveAggregationInput;\n        uint256[] serializedProof;\n    }\n\n    function commitBlocks(StoredBlockInfo calldata _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\n        external;\n\n    function proveBlocks(\n        StoredBlockInfo calldata _prevBlock,\n        StoredBlockInfo[] calldata _committedBlocks,\n        ProofInput calldata _proof\n    ) external;\n\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external;\n\n    function revertBlocks(uint256 _blocksToRevert) external;\n\n    /// @notice Event emitted when a block is committed\n    event BlockCommit(uint256 indexed blockNumber);\n\n    /// @notice Event emitted when a block is executed\n    event BlockExecution(uint256 indexed blockNumber);\n\n    /// @notice Event emitted when blocks are reverted\n    event BlocksRevert(uint256 totalBlocksCommitted, uint256 totalBlocksVerified, uint256 totalBlocksExecuted);\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/interfaces/IGetters.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8;\n\ninterface IGetters {\n    /*//////////////////////////////////////////////////////////////\n                            CUSTOM GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    function getVerifier() external view returns (address);\n\n    function getGovernor() external view returns (address);\n\n    function getTotalBlocksCommitted() external view returns (uint256);\n\n    function getTotalBlocksVerified() external view returns (uint256);\n\n    function getTotalBlocksExecuted() external view returns (uint256);\n\n    function getTotalPriorityTxs() external view returns (uint256);\n\n    function getFirstUnprocessedPriorityTx() external view returns (uint256);\n\n    function isValidator(address _address) external view returns (bool);\n\n    function l2LogsRootHash(uint32 blockNumber) external view returns (bytes32 hash);\n\n    function isFunctionFreezable(bytes4 _selector) external view returns (bool);\n\n    function isFacetFreezable(address _facet) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                            DIAMOND LOUPE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Faсet structure compatible with the EIP-2535 diamond loupe\n    /// @param addr The address of the facet contract\n    /// @param selectors The NON-sorted array with selectors associated with facet\n    struct Facet {\n        address addr;\n        bytes4[] selectors;\n    }\n\n    function facets() external view returns (Facet[] memory);\n\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory);\n\n    function facetAddresses() external view returns (address[] memory facets);\n\n    function facetAddress(bytes4 _selector) external view returns (address facet);\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/common/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n * @dev Unlike EIP-20 standard \"transfer\" and \"transferFrom\" functions do not return any value.\n * This is made to be compatible with popular tokens that are implemented standard incorrectly.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external;\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./Verifier.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./libraries/PriorityQueue.sol\";\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy upgrades and diamond cuts\n/// @param proposedDiamondCutHash The hash of diamond cut that was proposed in the current upgrade\n/// @param proposedDiamondCutTimestamp The timestamp when the diamond cut was proposed, zero if there are no active proposals\n/// @param lastDiamondFreezeTimestamp The timestamp when the diamond was frozen last time, zero if the diamond was never frozen\n/// @param currentProposalId The serial number of proposed diamond cuts, increments when proposing a new diamond cut\n/// @param securityCouncilMembers The set of the trusted addresses that can instantly finish upgrade (diamond cut)\n/// @param securityCouncilMemberLastApprovedProposalId The mapping of the security council addresses and the last diamond cut that they approved\n/// @param securityCouncilEmergencyApprovals The number of received upgrade approvals from the security council\nstruct DiamondCutStorage {\n    bytes32 proposedDiamondCutHash;\n    uint256 proposedDiamondCutTimestamp;\n    uint256 lastDiamondFreezeTimestamp;\n    uint256 currentProposalId;\n    mapping(address => bool) securityCouncilMembers;\n    mapping(address => uint256) securityCouncilMemberLastApprovedProposalId;\n    uint256 securityCouncilEmergencyApprovals;\n}\n\n/// @dev The log passed from L2\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for the future\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\n/// This field is required formally but does not have any special meaning.\n/// @param txNumberInBlock The L2 transaction number in a block, in which the log was sent\n/// @param sender The L2 address which sent the log\n/// @param key The 32 bytes of information that was sent in the log\n/// @param value The 32 bytes of information that was sent in the log\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\nstruct L2Log {\n    uint8 l2ShardId;\n    bool isService;\n    uint16 txNumberInBlock;\n    address sender;\n    bytes32 key;\n    bytes32 value;\n}\n\n/// @dev An arbitrary length message passed from L2\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\n/// @param txNumberInBlock The L2 transaction number in a block, in which the message was sent\n/// @param sender The address of the L2 account from which the message was passed\n/// @param data An arbitrary length message\nstruct L2Message {\n    uint16 txNumberInBlock;\n    address sender;\n    bytes data;\n}\n\n/// @notice Part of the configuration parameters of ZKP circuits\nstruct VerifierParams {\n    bytes32 recursionNodeLevelVkHash;\n    bytes32 recursionLeafLevelVkHash;\n    bytes32 recursionCircuitsSetVksHash;\n}\n\n/// @dev storing all storage variables for zkSync facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// NOTE: but NOT to modify already existing variables or change their order\nstruct AppStorage {\n    /// @dev Storage of variables needed for diamond cut facet\n    DiamondCutStorage diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n    /// @notice Address that governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address => bool) validators;\n    // TODO: should be used an external library approach\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 => bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 => bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"../common/libraries/UncheckedMath.sol\";\nimport \"./Plonk4VerifierWithAccessToDNext.sol\";\n\ncontract Verifier is Plonk4VerifierWithAccessToDNext {\n    using UncheckedMath for uint256;\n\n    function get_verification_key() internal pure returns (VerificationKey memory vk) {\n        vk.num_inputs = 1;\n        vk.domain_size = 256;\n        vk.omega = PairingsBn254.new_fr(0x1058a83d529be585820b96ff0a13f2dbd8675a9e5dd2336a6692cc1e5a526c81);\n        // coefficients\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\n            0x05f5cabc4eab14cfabee1334ef7f33a66259cc9fd07af862308d5c41765adb4b,\n            0x128a103fbe66c8ff697182c0963d963208b55a5a53ddeab9b4bc09dc2a68a9cc\n        );\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\n            0x0d9980170c334c107e6ce4d66bbc4d23bbcdc97c020b1e1c3f6e04c6c663d2c2,\n            0x0968205845091ceaf3f863b1613fbdf7ce9a87ccfd97f22011679e6350384419\n        );\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\n            0x0c84a19b149a1612cb042ad86382b9e94367c0add60d07e12399999e7db09efe,\n            0x1e02f70c44c9bfb7bf2164cee2ab4813bcb9be56eb432e2e9dfffffe196d846d\n        );\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\n            0x1eb3599506a41a7d62e1f7438d6732fbb9d1eda7b9c7a0213eca63c9334ac5a9,\n            0x23563d9f429908d8ea80bffa642840fb081936d45b388bafc504d9b1e5b1c410\n        );\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\n            0x0000000000000000000000000000000000000000000000000000000000000000,\n            0x0000000000000000000000000000000000000000000000000000000000000001\n        );\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\n            0x063e8dac7ee3ee6a4569fd53b416fe17f8f10de8c435c336e5a1cf2e02643200,\n            0x1d4c1781b78f926d55f89ef72abb96bee350ce60ddc684f5a02d87c5f4cdf943\n        );\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\n            0x0000000000000000000000000000000000000000000000000000000000000000,\n            0x0000000000000000000000000000000000000000000000000000000000000001\n        );\n        // gate selectors\n        vk.gate_selectors_commitments[0] = PairingsBn254.new_g1(\n            0x0b487eb34c8480ea506f5c6c25857155d61d7f9824b60bc80e1a415a5bcf247f,\n            0x07ea0d0d0df9dbcc944e9341a5bb49ae796d9dc9d7ca1c032b53784715b946db\n        );\n        vk.gate_selectors_commitments[1] = PairingsBn254.new_g1(\n            0x0fa66faa0b9ea782eb400175ac9f0c05f0de64332eec54a87cd20db4540baec2,\n            0x07dea33d314c690c4bd4b21deda1a44b9f8dd87e539024622768c2f8b8bdabe1\n        );\n        // permutation\n        vk.permutation_commitments[0] = PairingsBn254.new_g1(\n            0x120482c52e31d2373f9b2dc80a47e68f035e278d220fa8a89d0c81f133343953,\n            0x02928a78ea2e1a943e9220b7e288fd48a561263f8e5f94518f21aaa43781ceac\n        );\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\n            0x1dfad2c4d60704bcf6af0abd9cce09151f063c4b52200c268e470c6a6c93cbca,\n            0x08b28dd6ca14d7c33e078fe0f332a9a4d95ac8df171355de9e69930aec02b5dc\n        );\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\n            0x0935a4fd6ab67925929661cf2d2e814f87f589ee6234cb9675ecc2d897f1b338,\n            0x1032ccc41c047413fce4a847ba7e51e4a2ea406d89a88d480c5f0efaf6c8c89a\n        );\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\n            0x0eafaea3af7d1fadb2138db1b991af5d2218f6892714fd019898c7e1a43ecfe8,\n            0x28fb17eda285ed74cc9771d62fad22ab459bbb0a4968c489972aca8b7e618fcb\n        );\n        // lookup table commitments\n        vk.lookup_selector_commitment = PairingsBn254.new_g1(\n            0x155201a564e721b1f5c06315ad4e24eaad3cbdd6197b19cd903fe85613080f86,\n            0x12fb201bc896572ac14357e2601f5118636f1eeb7b89c177ac940aac3b5253ec\n        );\n        vk.lookup_tables_commitments[0] = PairingsBn254.new_g1(\n            0x1cb0e2ae4d52743898d94d7f1729bd0d3357ba035cdb6b3af7ebff9159f8f297,\n            0x15ee595227c9e0f7a487ddb8072d5ea3cfd058bc569211c3546bc0e80051553f\n        );\n        vk.lookup_tables_commitments[1] = PairingsBn254.new_g1(\n            0x13e4ab94c03a5a29719930c1361d854e244cf918f1e29cb031303f4a13b71977,\n            0x0f792ef4c6c8746c97be61ed9b20f31ba2dec3bd5c91a2d9a4a586f19af3a07c\n        );\n        vk.lookup_tables_commitments[2] = PairingsBn254.new_g1(\n            0x1c9e69bd2b04240ebe44fb23d67c596fce4a1336109fdce38c2f184a63cd8acc,\n            0x1cbd3e72bdbce827227e503690b10be9365ae760e9d2babde5ba81edf12f8206\n        );\n        vk.lookup_tables_commitments[3] = PairingsBn254.new_g1(\n            0x2a0d46339fbf72104df6a241b53a957602b1a16f6e3b9f89bf3e4c4645df823c,\n            0x11a601d7b2eee4b7885f34c9873426ba1263f38eae2e0351d653b8b1ba9c67f6\n        );\n        vk.lookup_table_type_commitment = PairingsBn254.new_g1(\n            0x1a70e43f18b18d686807c2b1c6471cd949dd251b48090bca443d86b97afae951,\n            0x0e6e23ad15a1bd851b228788ae4a03bf25bda39ede6d5a92d501a8402a0dfe43\n        );\n        // non residues\n        vk.non_residues[0] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000005);\n        vk.non_residues[1] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000007);\n        vk.non_residues[2] = PairingsBn254.new_fr(0x000000000000000000000000000000000000000000000000000000000000000a);\n\n        // g2 elements\n        vk.g2_elements[0] = PairingsBn254.new_g2(\n            [\n                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n            ],\n            [\n                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n            ]\n        );\n        vk.g2_elements[1] = PairingsBn254.new_g2(\n            [\n                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0\n            ],\n            [\n                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\n            ]\n        );\n    }\n\n    function deserialize_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\n        internal\n        pure\n        returns (Proof memory proof)\n    {\n        // require(serialized_proof.length == 44); TODO\n        proof.input_values = new uint256[](public_inputs.length);\n        for (uint256 i = 0; i < public_inputs.length; i = i.uncheckedInc()) {\n            proof.input_values[i] = public_inputs[i];\n        }\n\n        uint256 j;\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            proof.state_polys_commitments[i] = PairingsBn254.new_g1_checked(\n                serialized_proof[j],\n                serialized_proof[j.uncheckedInc()]\n            );\n\n            j = j.uncheckedAdd(2);\n        }\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n\n        proof.lookup_s_poly_commitment = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n\n        proof.lookup_grand_product_commitment = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n            proof.quotient_poly_parts_commitments[i] = PairingsBn254.new_g1_checked(\n                serialized_proof[j],\n                serialized_proof[j.uncheckedInc()]\n            );\n            j = j.uncheckedAdd(2);\n        }\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            proof.state_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\n            proof.state_polys_openings_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\n            proof.gate_selectors_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            proof.copy_permutation_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n        proof.copy_permutation_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j = j.uncheckedInc();\n        proof.lookup_s_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.lookup_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j = j.uncheckedInc();\n        proof.lookup_t_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j = j.uncheckedInc();\n        proof.lookup_t_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.lookup_selector_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.lookup_table_type_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.quotient_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.linearization_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.opening_proof_at_z = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n        proof.opening_proof_at_z_omega = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n    }\n\n    function verify_serialized_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\n        public\n        view\n        returns (bool)\n    {\n        VerificationKey memory vk = get_verification_key();\n        require(vk.num_inputs == public_inputs.length);\n\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\n\n        return verify(proof, vk);\n    }\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/common/interfaces/IAllowList.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\ninterface IAllowList {\n    /*//////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice public access is changed\n    event UpdatePublicAccess(address indexed target, bool newStatus);\n\n    /// @notice permission to call is changed\n    event UpdateCallPermission(address indexed caller, address indexed target, bytes4 indexed functionSig, bool status);\n\n    /// @notice pendingOwner is changed\n    /// @dev Also emitted when the new owner is accepted and in this case, `newPendingOwner` would be zero address\n    event NewPendingOwner(address indexed oldPendingOwner, address indexed newPendingOwner);\n\n    /// @notice Owner changed\n    event NewOwner(address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    function pendingOwner() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function isAccessPublic(address _target) external view returns (bool);\n\n    function hasSpecialAccessToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig\n    ) external view returns (bool);\n\n    function canCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig\n    ) external view returns (bool);\n\n    /*//////////////////////////////////////////////////////////////\n                           ALLOW LIST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setBatchPublicAccess(address[] calldata _targets, bool[] calldata _enables) external;\n\n    function setPublicAccess(address _target, bool _enable) external;\n\n    function setBatchPermissionToCall(\n        address[] calldata _callers,\n        address[] calldata _targets,\n        bytes4[] calldata _functionSigs,\n        bool[] calldata _enables\n    ) external;\n\n    function setPermissionToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig,\n        bool _enable\n    ) external;\n\n    function setPendingOwner(address _newPendingOwner) external;\n\n    function acceptOwner() external;\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/PriorityQueue.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\n/// @notice The structure that contains meta information of the L2 transaction that was requested from L1\n/// @dev The weird size of fields was selected specifically to minimize the structure storage size\n/// @param canonicalTxHash Hashed L2 transaction data that is needed to process it\n/// @param expirationBlock Expiration block number (ETH block) for this request (must be satisfied before)\n/// @param layer2Tip Additional payment to the validator as an incentive to perform the operation\nstruct PriorityOperation {\n    bytes32 canonicalTxHash;\n    uint64 expirationBlock;\n    uint192 layer2Tip;\n}\n\n/// @author Matter Labs\n/// @dev The library provides the API to interact with the priority queue container\n/// @dev Order of processing operations from queue - FIFO (Fist in - first out)\nlibrary PriorityQueue {\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the last added priority operation\n    /// @param tail The pointer to the first unprocessed priority operation\n    struct Queue {\n        mapping(uint256 => PriorityOperation) data;\n        uint256 head;\n        uint256 tail;\n    }\n\n    /// @return Index of the oldest priority operation that wasn't processed yet\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.head - _queue.tail);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.head == _queue.tail;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        _queue.data[head] = _operation;\n        _queue.head = head + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), \"D\"); // priority queue is empty\n\n        return _queue.data[_queue.tail];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), \"s\"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        priorityOperation = _queue.data[tail];\n        delete _queue.data[tail];\n        _queue.tail = tail + 1;\n    }\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/common/libraries/UncheckedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nlibrary UncheckedMath {\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\n        unchecked {\n            return _number + 1;\n        }\n    }\n\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\n        unchecked {\n            return _lhs + _rhs;\n        }\n    }\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/Plonk4VerifierWithAccessToDNext.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./libraries/PairingsBn254.sol\";\nimport \"./libraries/TranscriptLib.sol\";\nimport \"../common/libraries/UncheckedMath.sol\";\n\nuint256 constant STATE_WIDTH = 4;\nuint256 constant NUM_G2_ELS = 2;\n\nstruct VerificationKey {\n    uint256 domain_size;\n    uint256 num_inputs;\n    PairingsBn254.Fr omega;\n    PairingsBn254.G1Point[2] gate_selectors_commitments;\n    PairingsBn254.G1Point[7] gate_setup_commitments;\n    PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\n    PairingsBn254.G1Point lookup_selector_commitment;\n    PairingsBn254.G1Point[4] lookup_tables_commitments;\n    PairingsBn254.G1Point lookup_table_type_commitment;\n    PairingsBn254.Fr[STATE_WIDTH - 1] non_residues;\n    PairingsBn254.G2Point[NUM_G2_ELS] g2_elements;\n}\n\ncontract Plonk4VerifierWithAccessToDNext {\n    using PairingsBn254 for PairingsBn254.G1Point;\n    using PairingsBn254 for PairingsBn254.G2Point;\n    using PairingsBn254 for PairingsBn254.Fr;\n\n    using TranscriptLib for TranscriptLib.Transcript;\n\n    using UncheckedMath for uint256;\n\n    struct Proof {\n        uint256[] input_values;\n        // commitments\n        PairingsBn254.G1Point[STATE_WIDTH] state_polys_commitments;\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_parts_commitments;\n        // openings\n        PairingsBn254.Fr[STATE_WIDTH] state_polys_openings_at_z;\n        PairingsBn254.Fr[1] state_polys_openings_at_z_omega; // TODO: not use array while there is only D_next\n        PairingsBn254.Fr[1] gate_selectors_openings_at_z;\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_polys_openings_at_z;\n        PairingsBn254.Fr copy_permutation_grand_product_opening_at_z_omega;\n        PairingsBn254.Fr quotient_poly_opening_at_z;\n        PairingsBn254.Fr linearization_poly_opening_at_z;\n        // lookup commitments\n        PairingsBn254.G1Point lookup_s_poly_commitment;\n        PairingsBn254.G1Point lookup_grand_product_commitment;\n        // lookup openings\n        PairingsBn254.Fr lookup_s_poly_opening_at_z_omega;\n        PairingsBn254.Fr lookup_grand_product_opening_at_z_omega;\n        PairingsBn254.Fr lookup_t_poly_opening_at_z;\n        PairingsBn254.Fr lookup_t_poly_opening_at_z_omega;\n        PairingsBn254.Fr lookup_selector_poly_opening_at_z;\n        PairingsBn254.Fr lookup_table_type_poly_opening_at_z;\n        PairingsBn254.G1Point opening_proof_at_z;\n        PairingsBn254.G1Point opening_proof_at_z_omega;\n    }\n\n    struct PartialVerifierState {\n        PairingsBn254.Fr zero;\n        PairingsBn254.Fr alpha;\n        PairingsBn254.Fr beta;\n        PairingsBn254.Fr gamma;\n        PairingsBn254.Fr[9] alpha_values;\n        PairingsBn254.Fr eta;\n        PairingsBn254.Fr beta_lookup;\n        PairingsBn254.Fr gamma_lookup;\n        PairingsBn254.Fr beta_plus_one;\n        PairingsBn254.Fr beta_gamma;\n        PairingsBn254.Fr v;\n        PairingsBn254.Fr u;\n        PairingsBn254.Fr z;\n        PairingsBn254.Fr z_omega;\n        PairingsBn254.Fr z_minus_last_omega;\n        PairingsBn254.Fr l_0_at_z;\n        PairingsBn254.Fr l_n_minus_one_at_z;\n        PairingsBn254.Fr t;\n        PairingsBn254.G1Point tp;\n    }\n\n    function evaluate_l0_at_point(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory num)\n    {\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n\n        PairingsBn254.Fr memory size_fe = PairingsBn254.new_fr(domain_size);\n        PairingsBn254.Fr memory den = at.copy();\n        den.sub_assign(one);\n        den.mul_assign(size_fe);\n\n        den = den.inverse();\n\n        num = at.pow(domain_size);\n        num.sub_assign(one);\n        num.mul_assign(den);\n    }\n\n    function evaluate_lagrange_poly_out_of_domain(\n        uint256 poly_num,\n        uint256 domain_size,\n        PairingsBn254.Fr memory omega,\n        PairingsBn254.Fr memory at\n    ) internal view returns (PairingsBn254.Fr memory res) {\n        // (omega^i / N) / (X - omega^i) * (X^N - 1)\n        require(poly_num < domain_size);\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\n        res = at.pow(domain_size);\n        res.sub_assign(one);\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\n        res.mul_assign(omega_power);\n\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\n        den.sub_assign(omega_power);\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\n\n        den = den.inverse();\n\n        res.mul_assign(den);\n    }\n\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory res)\n    {\n        res = at.pow(domain_size);\n        res.sub_assign(PairingsBn254.new_fr(1));\n    }\n\n    function initialize_transcript(Proof memory proof, VerificationKey memory vk)\n        internal\n        pure\n        returns (PartialVerifierState memory state)\n    {\n        TranscriptLib.Transcript memory transcript = TranscriptLib.new_transcript();\n\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\n            transcript.update_with_u256(proof.input_values[i]);\n        }\n\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            transcript.update_with_g1(proof.state_polys_commitments[i]);\n        }\n\n        state.eta = transcript.get_challenge();\n        transcript.update_with_g1(proof.lookup_s_poly_commitment);\n\n        state.beta = transcript.get_challenge();\n        state.gamma = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\n        state.beta_lookup = transcript.get_challenge();\n        state.gamma_lookup = transcript.get_challenge();\n        transcript.update_with_g1(proof.lookup_grand_product_commitment);\n        state.alpha = transcript.get_challenge();\n\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n            transcript.update_with_g1(proof.quotient_poly_parts_commitments[i]);\n        }\n        state.z = transcript.get_challenge();\n\n        transcript.update_with_fr(proof.quotient_poly_opening_at_z);\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.state_polys_openings_at_z[i]);\n        }\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.state_polys_openings_at_z_omega[i]);\n        }\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.gate_selectors_openings_at_z[i]);\n        }\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.copy_permutation_polys_openings_at_z[i]);\n        }\n\n        state.z_omega = state.z.copy();\n        state.z_omega.mul_assign(vk.omega);\n\n        transcript.update_with_fr(proof.copy_permutation_grand_product_opening_at_z_omega);\n\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_selector_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_table_type_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_s_poly_opening_at_z_omega);\n        transcript.update_with_fr(proof.lookup_grand_product_opening_at_z_omega);\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z_omega);\n        transcript.update_with_fr(proof.linearization_poly_opening_at_z);\n\n        state.v = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.opening_proof_at_z);\n        transcript.update_with_g1(proof.opening_proof_at_z_omega);\n\n        state.u = transcript.get_challenge();\n    }\n\n    // compute some powers of challenge alpha([alpha^1, .. alpha^8])\n    function compute_powers_of_alpha(PartialVerifierState memory state) public pure {\n        require(state.alpha.value != 0);\n        state.alpha_values[0] = PairingsBn254.new_fr(1);\n        state.alpha_values[1] = state.alpha.copy();\n        PairingsBn254.Fr memory current_alpha = state.alpha.copy();\n        for (uint256 i = 2; i < state.alpha_values.length; i = i.uncheckedInc()) {\n            current_alpha.mul_assign(state.alpha);\n            state.alpha_values[i] = current_alpha.copy();\n        }\n    }\n\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\n        // we initialize all challenges beforehand, we can draw each challenge in its own place\n        PartialVerifierState memory state = initialize_transcript(proof, vk);\n        if (verify_quotient_evaluation(vk, proof, state) == false) {\n            return false;\n        }\n        require(proof.state_polys_openings_at_z_omega.length == 1); // TODO\n\n        PairingsBn254.G1Point memory quotient_result = proof.quotient_poly_parts_commitments[0].copy_g1();\n        {\n            // block scope\n            PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\n            PairingsBn254.Fr memory current_z = z_in_domain_size.copy();\n            PairingsBn254.G1Point memory tp;\n            // start from i =1\n            for (uint256 i = 1; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n                tp = proof.quotient_poly_parts_commitments[i].copy_g1();\n                tp.point_mul_assign(current_z);\n                quotient_result.point_add_assign(tp);\n\n                current_z.mul_assign(z_in_domain_size);\n            }\n        }\n\n        Queries memory queries = prepare_queries(vk, proof, state);\n        queries.commitments_at_z[0] = quotient_result;\n        queries.values_at_z[0] = proof.quotient_poly_opening_at_z;\n        queries.commitments_at_z[1] = aggregated_linearization_commitment(vk, proof, state);\n        queries.values_at_z[1] = proof.linearization_poly_opening_at_z;\n\n        require(queries.commitments_at_z.length == queries.values_at_z.length);\n\n        PairingsBn254.G1Point memory aggregated_commitment_at_z = queries.commitments_at_z[0];\n\n        PairingsBn254.Fr memory aggregated_opening_at_z = queries.values_at_z[0];\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\n        PairingsBn254.G1Point memory scaled;\n        for (uint256 i = 1; i < queries.commitments_at_z.length; i = i.uncheckedInc()) {\n            aggregation_challenge.mul_assign(state.v);\n            scaled = queries.commitments_at_z[i].point_mul(aggregation_challenge);\n            aggregated_commitment_at_z.point_add_assign(scaled);\n\n            state.t = queries.values_at_z[i];\n            state.t.mul_assign(aggregation_challenge);\n            aggregated_opening_at_z.add_assign(state.t);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega = queries.commitments_at_z_omega[0].point_mul(\n            aggregation_challenge\n        );\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega = queries.values_at_z_omega[0];\n        aggregated_opening_at_z_omega.mul_assign(aggregation_challenge);\n        for (uint256 i = 1; i < queries.commitments_at_z_omega.length; i = i.uncheckedInc()) {\n            aggregation_challenge.mul_assign(state.v);\n\n            scaled = queries.commitments_at_z_omega[i].point_mul(aggregation_challenge);\n            aggregated_commitment_at_z_omega.point_add_assign(scaled);\n\n            state.t = queries.values_at_z_omega[i];\n            state.t.mul_assign(aggregation_challenge);\n            aggregated_opening_at_z_omega.add_assign(state.t);\n        }\n\n        return\n            final_pairing(\n                vk.g2_elements,\n                proof,\n                state,\n                aggregated_commitment_at_z,\n                aggregated_commitment_at_z_omega,\n                aggregated_opening_at_z,\n                aggregated_opening_at_z_omega\n            );\n    }\n\n    function verify_quotient_evaluation(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (bool) {\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i.uncheckedInc()) {\n            lagrange_poly_numbers[i] = i;\n        }\n        // require(vk.num_inputs > 0); // TODO\n\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\n            // TODO we may use batched lagrange compputation\n            state.t = evaluate_lagrange_poly_out_of_domain(i, vk.domain_size, vk.omega, state.z);\n            state.t.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\n            inputs_term.add_assign(state.t);\n        }\n        inputs_term.mul_assign(proof.gate_selectors_openings_at_z[0]);\n        PairingsBn254.Fr memory result = proof.linearization_poly_opening_at_z.copy();\n        result.add_assign(inputs_term);\n\n        // compute powers of alpha\n        compute_powers_of_alpha(state);\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\n\n        // - alpha_0 * (a + perm(z) * beta + gamma)*()*(d + gamma) * z(z*omega)\n        require(proof.copy_permutation_polys_openings_at_z.length == STATE_WIDTH - 1);\n        PairingsBn254.Fr memory t; // TMP;\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\n            t.mul_assign(state.beta);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n            t.add_assign(state.gamma);\n\n            factor.mul_assign(t);\n        }\n\n        t = proof.state_polys_openings_at_z[3].copy();\n        t.add_assign(state.gamma);\n        factor.mul_assign(t);\n        result.sub_assign(factor);\n\n        // - L_0(z) * alpha_1\n        PairingsBn254.Fr memory l_0_at_z = evaluate_l0_at_point(vk.domain_size, state.z);\n        l_0_at_z.mul_assign(state.alpha_values[4 + 1]);\n        result.sub_assign(l_0_at_z);\n\n        PairingsBn254.Fr memory lookup_quotient_contrib = lookup_quotient_contribution(vk, proof, state);\n        result.add_assign(lookup_quotient_contrib);\n\n        PairingsBn254.Fr memory lhs = proof.quotient_poly_opening_at_z.copy();\n        lhs.mul_assign(evaluate_vanishing(vk.domain_size, state.z));\n        return lhs.value == result.value;\n    }\n\n    function lookup_quotient_contribution(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (PairingsBn254.Fr memory result) {\n        PairingsBn254.Fr memory t;\n\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        state.beta_plus_one = state.beta_lookup.copy();\n        state.beta_plus_one.add_assign(one);\n        state.beta_gamma = state.beta_plus_one.copy();\n        state.beta_gamma.mul_assign(state.gamma_lookup);\n\n        // (s'*beta + gamma)*(zw')*alpha\n        t = proof.lookup_s_poly_opening_at_z_omega.copy();\n        t.mul_assign(state.beta_lookup);\n        t.add_assign(state.beta_gamma);\n        t.mul_assign(proof.lookup_grand_product_opening_at_z_omega);\n        t.mul_assign(state.alpha_values[6]);\n\n        // (z - omega^{n-1}) for this part\n        PairingsBn254.Fr memory last_omega = vk.omega.pow(vk.domain_size - 1);\n        state.z_minus_last_omega = state.z.copy();\n        state.z_minus_last_omega.sub_assign(last_omega);\n        t.mul_assign(state.z_minus_last_omega);\n        result.add_assign(t);\n\n        // - alpha_1 * L_{0}(z)\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\n        t = state.l_0_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 1]);\n        result.sub_assign(t);\n\n        // - alpha_2 * beta_gamma_powered L_{n-1}(z)\n        PairingsBn254.Fr memory beta_gamma_powered = state.beta_gamma.pow(vk.domain_size - 1);\n        state.l_n_minus_one_at_z = evaluate_lagrange_poly_out_of_domain(\n            vk.domain_size - 1,\n            vk.domain_size,\n            vk.omega,\n            state.z\n        );\n        t = state.l_n_minus_one_at_z.copy();\n        t.mul_assign(beta_gamma_powered);\n        t.mul_assign(state.alpha_values[6 + 2]);\n\n        result.sub_assign(t);\n    }\n\n    function aggregated_linearization_commitment(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (PairingsBn254.G1Point memory result) {\n        // qMain*(Q_a * A + Q_b * B + Q_c * C + Q_d * D + Q_m * A*B + Q_const + Q_dNext * D_next)\n        result = PairingsBn254.new_g1(0, 0);\n        // Q_a * A\n        PairingsBn254.G1Point memory scaled = vk.gate_setup_commitments[0].point_mul(\n            proof.state_polys_openings_at_z[0]\n        );\n        result.point_add_assign(scaled);\n        // Q_b * B\n        scaled = vk.gate_setup_commitments[1].point_mul(proof.state_polys_openings_at_z[1]);\n        result.point_add_assign(scaled);\n        // Q_c * C\n        scaled = vk.gate_setup_commitments[2].point_mul(proof.state_polys_openings_at_z[2]);\n        result.point_add_assign(scaled);\n        // Q_d * D\n        scaled = vk.gate_setup_commitments[3].point_mul(proof.state_polys_openings_at_z[3]);\n        result.point_add_assign(scaled);\n        // Q_m* A*B or Q_ab*A*B\n        PairingsBn254.Fr memory t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[1]);\n        scaled = vk.gate_setup_commitments[4].point_mul(t);\n        result.point_add_assign(scaled);\n        // Q_const\n        result.point_add_assign(vk.gate_setup_commitments[5]);\n        // Q_dNext * D_next\n        scaled = vk.gate_setup_commitments[6].point_mul(proof.state_polys_openings_at_z_omega[0]);\n        result.point_add_assign(scaled);\n        result.point_mul_assign(proof.gate_selectors_openings_at_z[0]);\n\n        PairingsBn254.G1Point\n            memory rescue_custom_gate_linearization_contrib = rescue_custom_gate_linearization_contribution(\n                vk,\n                proof,\n                state\n            );\n        result.point_add_assign(rescue_custom_gate_linearization_contrib);\n        require(vk.non_residues.length == STATE_WIDTH - 1);\n\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; ) {\n            t = state.z.copy();\n            if (i == 0) {\n                t.mul_assign(one);\n            } else {\n                t.mul_assign(vk.non_residues[i - 1]); // TODO add one into non-residues during codegen?\n            }\n            t.mul_assign(state.beta);\n            t.add_assign(state.gamma);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n\n            factor.mul_assign(t);\n            unchecked {\n                ++i;\n            }\n        }\n\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\n        factor = state.alpha_values[4].copy();\n        factor.mul_assign(state.beta);\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\n            t.mul_assign(state.beta);\n            t.add_assign(state.gamma);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n\n            factor.mul_assign(t);\n        }\n        scaled = vk.permutation_commitments[3].point_mul(factor);\n        result.point_sub_assign(scaled);\n\n        // + L_0(z) * Z(x)\n        // TODO\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\n        require(state.l_0_at_z.value != 0);\n        factor = state.l_0_at_z.copy();\n        factor.mul_assign(state.alpha_values[4 + 1]);\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        PairingsBn254.G1Point memory lookup_linearization_contrib = lookup_linearization_contribution(proof, state);\n        result.point_add_assign(lookup_linearization_contrib);\n    }\n\n    function rescue_custom_gate_linearization_contribution(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) public view returns (PairingsBn254.G1Point memory result) {\n        PairingsBn254.Fr memory t;\n        PairingsBn254.Fr memory intermediate_result;\n\n        // a^2 - b = 0\n        t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(t);\n        t.sub_assign(proof.state_polys_openings_at_z[1]);\n        // t.mul_assign(challenge1);\n        t.mul_assign(state.alpha_values[1]);\n        intermediate_result.add_assign(t);\n\n        // b^2 - c = 0\n        t = proof.state_polys_openings_at_z[1].copy();\n        t.mul_assign(t);\n        t.sub_assign(proof.state_polys_openings_at_z[2]);\n        t.mul_assign(state.alpha_values[1 + 1]);\n        intermediate_result.add_assign(t);\n\n        // c*a - d = 0;\n        t = proof.state_polys_openings_at_z[2].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[0]);\n        t.sub_assign(proof.state_polys_openings_at_z[3]);\n        t.mul_assign(state.alpha_values[1 + 2]);\n        intermediate_result.add_assign(t);\n\n        result = vk.gate_selectors_commitments[1].point_mul(intermediate_result);\n    }\n\n    function lookup_linearization_contribution(Proof memory proof, PartialVerifierState memory state)\n        internal\n        view\n        returns (PairingsBn254.G1Point memory result)\n    {\n        PairingsBn254.Fr memory zero = PairingsBn254.new_fr(0);\n\n        PairingsBn254.Fr memory t;\n        PairingsBn254.Fr memory factor;\n        // s(x) from the Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n        factor = proof.lookup_grand_product_opening_at_z_omega.copy();\n        factor.mul_assign(state.alpha_values[6]);\n        factor.mul_assign(state.z_minus_last_omega);\n\n        PairingsBn254.G1Point memory scaled = proof.lookup_s_poly_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        // Z(x) from - alpha_0 * Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega))\n        // + alpha_1 * Z(x) * L_{0}(z) + alpha_2 * Z(x) * L_{n-1}(z)\n\n        // accumulate coefficient\n        factor = proof.lookup_t_poly_opening_at_z_omega.copy();\n        factor.mul_assign(state.beta_lookup);\n        factor.add_assign(proof.lookup_t_poly_opening_at_z);\n        factor.add_assign(state.beta_gamma);\n\n        // (\\gamma + f(x))\n        PairingsBn254.Fr memory f_reconstructed;\n        PairingsBn254.Fr memory current = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory tmp0;\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            tmp0 = proof.state_polys_openings_at_z[i].copy();\n            tmp0.mul_assign(current);\n            f_reconstructed.add_assign(tmp0);\n\n            current.mul_assign(state.eta);\n        }\n\n        // add type of table\n        t = proof.lookup_table_type_poly_opening_at_z.copy();\n        t.mul_assign(current);\n        f_reconstructed.add_assign(t);\n\n        f_reconstructed.mul_assign(proof.lookup_selector_poly_opening_at_z);\n        f_reconstructed.add_assign(state.gamma_lookup);\n\n        // end of (\\gamma + f(x)) part\n        factor.mul_assign(f_reconstructed);\n        factor.mul_assign(state.beta_plus_one);\n        t = zero.copy();\n        t.sub_assign(factor);\n        factor = t;\n        factor.mul_assign(state.alpha_values[6]);\n\n        // Multiply by (z - omega^{n-1})\n        factor.mul_assign(state.z_minus_last_omega);\n\n        // L_{0}(z) in front of Z(x)\n        t = state.l_0_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 1]);\n        factor.add_assign(t);\n\n        // L_{n-1}(z) in front of Z(x)\n        t = state.l_n_minus_one_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 2]);\n        factor.add_assign(t);\n\n        scaled = proof.lookup_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n    }\n\n    struct Queries {\n        PairingsBn254.G1Point[13] commitments_at_z;\n        PairingsBn254.Fr[13] values_at_z;\n        PairingsBn254.G1Point[6] commitments_at_z_omega;\n        PairingsBn254.Fr[6] values_at_z_omega;\n    }\n\n    function prepare_queries(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) public view returns (Queries memory queries) {\n        // we set first two items in calee side so start idx from 2\n        uint256 idx = 2;\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            queries.commitments_at_z[idx] = proof.state_polys_commitments[i];\n            queries.values_at_z[idx] = proof.state_polys_openings_at_z[i];\n            idx = idx.uncheckedInc();\n        }\n        require(proof.gate_selectors_openings_at_z.length == 1);\n        queries.commitments_at_z[idx] = vk.gate_selectors_commitments[0];\n        queries.values_at_z[idx] = proof.gate_selectors_openings_at_z[0];\n        idx = idx.uncheckedInc();\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            queries.commitments_at_z[idx] = vk.permutation_commitments[i];\n            queries.values_at_z[idx] = proof.copy_permutation_polys_openings_at_z[i];\n            idx = idx.uncheckedInc();\n        }\n\n        queries.commitments_at_z_omega[0] = proof.copy_permutation_grand_product_commitment;\n        queries.commitments_at_z_omega[1] = proof.state_polys_commitments[STATE_WIDTH - 1];\n\n        queries.values_at_z_omega[0] = proof.copy_permutation_grand_product_opening_at_z_omega;\n        queries.values_at_z_omega[1] = proof.state_polys_openings_at_z_omega[0];\n\n        PairingsBn254.G1Point memory lookup_t_poly_commitment_aggregated = vk.lookup_tables_commitments[0];\n        PairingsBn254.Fr memory current_eta = state.eta.copy();\n        for (uint256 i = 1; i < vk.lookup_tables_commitments.length; i = i.uncheckedInc()) {\n            state.tp = vk.lookup_tables_commitments[i].point_mul(current_eta);\n            lookup_t_poly_commitment_aggregated.point_add_assign(state.tp);\n\n            current_eta.mul_assign(state.eta);\n        }\n        queries.commitments_at_z[idx] = lookup_t_poly_commitment_aggregated;\n        queries.values_at_z[idx] = proof.lookup_t_poly_opening_at_z;\n        idx = idx.uncheckedInc();\n        queries.commitments_at_z[idx] = vk.lookup_selector_commitment;\n        queries.values_at_z[idx] = proof.lookup_selector_poly_opening_at_z;\n        idx = idx.uncheckedInc();\n        queries.commitments_at_z[idx] = vk.lookup_table_type_commitment;\n        queries.values_at_z[idx] = proof.lookup_table_type_poly_opening_at_z;\n        queries.commitments_at_z_omega[2] = proof.lookup_s_poly_commitment;\n        queries.values_at_z_omega[2] = proof.lookup_s_poly_opening_at_z_omega;\n        queries.commitments_at_z_omega[3] = proof.lookup_grand_product_commitment;\n        queries.values_at_z_omega[3] = proof.lookup_grand_product_opening_at_z_omega;\n        queries.commitments_at_z_omega[4] = lookup_t_poly_commitment_aggregated;\n        queries.values_at_z_omega[4] = proof.lookup_t_poly_opening_at_z_omega;\n    }\n\n    function final_pairing(\n        // VerificationKey memory vk,\n        PairingsBn254.G2Point[NUM_G2_ELS] memory g2_elements,\n        Proof memory proof,\n        PartialVerifierState memory state,\n        PairingsBn254.G1Point memory aggregated_commitment_at_z,\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega,\n        PairingsBn254.Fr memory aggregated_opening_at_z,\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega\n    ) internal view returns (bool) {\n        // q(x) = f(x) - f(z) / (x - z)\n        // q(x) * (x-z)  = f(x) - f(z)\n\n        // f(x)\n        PairingsBn254.G1Point memory pair_with_generator = aggregated_commitment_at_z.copy_g1();\n        aggregated_commitment_at_z_omega.point_mul_assign(state.u);\n        pair_with_generator.point_add_assign(aggregated_commitment_at_z_omega);\n\n        // - f(z)*g\n        PairingsBn254.Fr memory aggregated_value = aggregated_opening_at_z_omega.copy();\n        aggregated_value.mul_assign(state.u);\n        aggregated_value.add_assign(aggregated_opening_at_z);\n        PairingsBn254.G1Point memory tp = PairingsBn254.P1().point_mul(aggregated_value);\n        pair_with_generator.point_sub_assign(tp);\n\n        // +z * q(x)\n        tp = proof.opening_proof_at_z.point_mul(state.z);\n        PairingsBn254.Fr memory t = state.z_omega.copy();\n        t.mul_assign(state.u);\n        PairingsBn254.G1Point memory t1 = proof.opening_proof_at_z_omega.point_mul(t);\n        tp.point_add_assign(t1);\n        pair_with_generator.point_add_assign(tp);\n\n        // rhs\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_proof_at_z_omega.point_mul(state.u);\n        pair_with_x.point_add_assign(proof.opening_proof_at_z);\n        pair_with_x.negate();\n        // Pairing precompile expects points to be in a `i*x[1] + x[0]` form instead of `x[0] + i*x[1]`\n        // so we handle it in code generation step\n        PairingsBn254.G2Point memory first_g2 = g2_elements[0];\n        PairingsBn254.G2Point memory second_g2 = g2_elements[1];\n        PairingsBn254.G2Point memory gen2 = PairingsBn254.P2();\n\n        return PairingsBn254.pairingProd2(pair_with_generator, first_g2, pair_with_x, second_g2);\n    }\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/PairingsBn254.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nlibrary PairingsBn254 {\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant bn254_b_coeff = 3;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    struct Fr {\n        uint256 value;\n    }\n\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\n        require(fr < r_mod);\n        return Fr({value: fr});\n    }\n\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\n        n.value = self.value;\n    }\n\n    function assign(Fr memory self, Fr memory other) internal pure {\n        self.value = other.value;\n    }\n\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\n        require(fr.value != 0);\n        return pow(fr, r_mod - 2);\n    }\n\n    function add_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = addmod(self.value, other.value, r_mod);\n    }\n\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\n    }\n\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = mulmod(self.value, other.value, r_mod);\n    }\n\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\n        uint256[1] memory result;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\n        }\n        require(success);\n        return Fr({value: result[0]});\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    function P1() internal pure returns (G1Point memory) {\n        return G1Point(1, 2);\n    }\n\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n        return G1Point(x, y);\n    }\n\n    // function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n        if (x == 0 && y == 0) {\n            // point of infinity is (0,0)\n            return G1Point(x, y);\n        }\n\n        // check encoding\n        require(x < q_mod, \"x axis isn't valid\");\n        require(y < q_mod, \"y axis isn't valid\");\n        // check on curve\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\n\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\n        rhs = mulmod(rhs, x, q_mod); // x^3\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\n        require(lhs == rhs, \"is not on curve\");\n\n        return G1Point(x, y);\n    }\n\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\n        return G2Point(x, y);\n    }\n\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\n        result.X = self.X;\n        result.Y = self.Y;\n    }\n\n    function P2() internal pure returns (G2Point memory) {\n        // for some reason ethereum expects to have c1*v + c0 form\n\n        return\n            G2Point(\n                [\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n                ],\n                [\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n                ]\n            );\n    }\n\n    function negate(G1Point memory self) internal pure {\n        // The prime q in the base field F_q for G1\n        if (self.Y == 0) {\n            require(self.X == 0);\n            return;\n        }\n\n        self.Y = q_mod - self.Y;\n    }\n\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        point_add_into_dest(p1, p2, r);\n        return r;\n    }\n\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\n        point_add_into_dest(p1, p2, p1);\n    }\n\n    function point_add_into_dest(\n        G1Point memory p1,\n        G1Point memory p2,\n        G1Point memory dest\n    ) internal view {\n        if (p2.X == 0 && p2.Y == 0) {\n            // we add zero, nothing happens\n            dest.X = p1.X;\n            dest.Y = p1.Y;\n            return;\n        } else if (p1.X == 0 && p1.Y == 0) {\n            // we add into zero, and we add non-zero point\n            dest.X = p2.X;\n            dest.Y = p2.Y;\n            return;\n        } else {\n            uint256[4] memory input;\n\n            input[0] = p1.X;\n            input[1] = p1.Y;\n            input[2] = p2.X;\n            input[3] = p2.Y;\n\n            bool success;\n            assembly {\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\n            }\n            require(success);\n        }\n    }\n\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\n        point_sub_into_dest(p1, p2, p1);\n    }\n\n    function point_sub_into_dest(\n        G1Point memory p1,\n        G1Point memory p2,\n        G1Point memory dest\n    ) internal view {\n        if (p2.X == 0 && p2.Y == 0) {\n            // we subtracted zero, nothing happens\n            dest.X = p1.X;\n            dest.Y = p1.Y;\n            return;\n        } else if (p1.X == 0 && p1.Y == 0) {\n            // we subtract from zero, and we subtract non-zero point\n            dest.X = p2.X;\n            dest.Y = q_mod - p2.Y;\n            return;\n        } else {\n            uint256[4] memory input;\n\n            input[0] = p1.X;\n            input[1] = p1.Y;\n            input[2] = p2.X;\n            input[3] = q_mod - p2.Y;\n\n            bool success = false;\n            assembly {\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\n            }\n            require(success);\n        }\n    }\n\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\n        // https://eips.ethereum.org/EIPS/eip-197\n        // Elliptic curve points are encoded as a Jacobian pair (X, Y) where the point at infinity is encoded as (0, 0)\n        // TODO\n        if (p.X == 0 && p.Y == 1) {\n            p.Y = 0;\n        }\n        point_mul_into_dest(p, s, r);\n        return r;\n    }\n\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\n        point_mul_into_dest(p, s, p);\n    }\n\n    function point_mul_into_dest(\n        G1Point memory p,\n        Fr memory s,\n        G1Point memory dest\n    ) internal view {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s.value;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\n        }\n        require(success);\n    }\n\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\n        require(p1.length == p2.length);\n        uint256 elements = p1.length;\n        uint256 inputSize = elements * 6;\n        uint256[] memory input = new uint256[](inputSize);\n        for (uint256 i = 0; i < elements; ) {\n            input[i * 6 + 0] = p1[i].X;\n            input[i * 6 + 1] = p1[i].Y;\n            input[i * 6 + 2] = p2[i].X[0];\n            input[i * 6 + 3] = p2[i].X[1];\n            input[i * 6 + 4] = p2[i].Y[0];\n            input[i * 6 + 5] = p2[i].Y[1];\n            unchecked {\n                ++i;\n            }\n        }\n        uint256[1] memory out;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n        }\n        require(success);\n        return out[0] != 0;\n    }\n\n    /// Convenience method for a pairing check for two pairs.\n    function pairingProd2(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2\n    ) internal view returns (bool) {\n        G1Point[] memory p1 = new G1Point[](2);\n        G2Point[] memory p2 = new G2Point[](2);\n        p1[0] = a1;\n        p1[1] = b1;\n        p2[0] = a2;\n        p2[1] = b2;\n        return pairing(p1, p2);\n    }\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/TranscriptLib.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n\npragma solidity ^0.8.0;\n\nimport \"./PairingsBn254.sol\";\n\nlibrary TranscriptLib {\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    uint32 constant DST_0 = 0;\n    uint32 constant DST_1 = 1;\n    uint32 constant DST_CHALLENGE = 2;\n\n    struct Transcript {\n        bytes32 state_0;\n        bytes32 state_1;\n        uint32 challenge_counter;\n    }\n\n    function new_transcript() internal pure returns (Transcript memory t) {\n        t.state_0 = bytes32(0);\n        t.state_1 = bytes32(0);\n        t.challenge_counter = 0;\n    }\n\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\n        bytes32 old_state_0 = self.state_0;\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\n    }\n\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\n        update_with_u256(self, value.value);\n    }\n\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\n        update_with_u256(self, p.X);\n        update_with_u256(self, p.Y);\n    }\n\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\n        self.challenge_counter += 1;\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\n    }\n}\n"
    },
    "@matterlabs/zksync-contracts/l1/contracts/zksync/libraries/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @author Matter Labs\n/// @notice The helper library for managing the EIP-2535 diamond proxy.\nlibrary Diamond {\n    /// @dev Magic value that should be returned by diamond cut initialize contracts.\n    /// @dev Used to distinguish calls to contracts that were supposed to be used as diamond initializer from other contracts.\n    bytes32 constant DIAMOND_INIT_SUCCESS_RETURN_VALUE = keccak256(\"diamond.zksync.init\");\n\n    /// @dev Storage position of `DiamondStorage` structure.\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    /// @dev Utility struct that contains associated facet & meta information of selector\n    /// @param facetAddress address of the facet which is connected with selector\n    /// @param selectorPosition index in `FacetToSelectors.selectors` array, where is selector stored\n    /// @param isFreezable denotes whether the selector can be frozen.\n    struct SelectorToFacet {\n        address facetAddress;\n        uint16 selectorPosition;\n        bool isFreezable;\n    }\n\n    /// @dev Utility struct that contains associated selectors & meta information of facet\n    /// @param selectors list of all selectors that belong to the facet\n    /// @param facetPosition index in `DiamondStorage.facets` array, where is facet stored\n    struct FacetToSelectors {\n        bytes4[] selectors;\n        uint16 facetPosition;\n    }\n\n    /// @notice The structure that holds all diamond proxy associated parameters\n    /// @dev According to the EIP-2535 should be stored on a special storage key - `DIAMOND_STORAGE_POSITION`\n    /// @param selectorToFacet An mapping from selector to the facet address and its' meta information\n    /// @param facetToSelectors An mapping from facet address to its' selector with meta information\n    /// @param facets The array of all unique facet addresses that belong to the diamond proxy\n    /// @param isFrozen Denotes whether the diamond proxy is frozen and all freezable facets are not accessible\n    struct DiamondStorage {\n        mapping(bytes4 => SelectorToFacet) selectorToFacet;\n        mapping(address => FacetToSelectors) facetToSelectors;\n        address[] facets;\n        bool isFrozen;\n    }\n\n    /// @return diamondStorage The pointer to the storage where all specific diamond proxy parameters stored\n    function getDiamondStorage() internal pure returns (DiamondStorage storage diamondStorage) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            diamondStorage.slot := position\n        }\n    }\n\n    /// @notice Action on selectors for one facet on a Diamond Cut\n    enum Action {\n        Add,\n        Replace,\n        Remove\n    }\n\n    /// @dev Parameters for diamond changes that touch one of the facets\n    /// @param facet The address of facet that's affected by the cut\n    /// @param action The action that is made on the facet\n    /// @param isFreezable Denotes whether the facet & all their selectors can be frozen\n    /// @param selectors An array of unique selectors that belongs to the facet address\n    struct FacetCut {\n        address facet;\n        Action action;\n        bool isFreezable;\n        bytes4[] selectors;\n    }\n\n    /// @dev Structure of the diamond proxy changes\n    /// @param facetCuts The set of changes (adding/removing/replacement) of implementation contracts\n    /// @param initAddress The address that's dellegate called after setting up new facet changes\n    /// @param initCalldata Calldata for the delegete call to `initAddress`\n    struct DiamondCutData {\n        FacetCut[] facetCuts;\n        address initAddress;\n        bytes initCalldata;\n    }\n\n    /// @dev Add/replace/remove any number of selectors and optionally execute a function with delegatecall\n    /// @param _diamondCut Diamond's facet changes and the parameters to optional initialization delegatecall\n    function diamondCut(DiamondCutData memory _diamondCut) internal {\n        FacetCut[] memory facetCuts = _diamondCut.facetCuts;\n        address initAddress = _diamondCut.initAddress;\n        bytes memory initCalldata = _diamondCut.initCalldata;\n        for (uint256 i = 0; i < facetCuts.length; ++i) {\n            Action action = facetCuts[i].action;\n            address facet = facetCuts[i].facet;\n            bool isFacetFreezable = facetCuts[i].isFreezable;\n            bytes4[] memory selectors = facetCuts[i].selectors;\n\n            require(selectors.length > 0, \"B\"); // no functions for diamond cut\n\n            if (action == Action.Add) {\n                _addFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Replace) {\n                _replaceFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Remove) {\n                _removeFunctions(facet, selectors);\n            } else {\n                revert(\"C\"); // undefined diamond cut action\n            }\n        }\n\n        _initializeDiamondCut(initAddress, initCalldata);\n        emit DiamondCut(facetCuts, initAddress, initCalldata);\n    }\n\n    event DiamondCut(FacetCut[] facetCuts, address initAddress, bytes initCalldata);\n\n    /// @dev Add new functions to the diamond proxy\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _addFunctions(\n        address _facet,\n        bytes4[] memory _selectors,\n        bool _isFacetFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet != address(0), \"G\"); // facet with zero address cannot be added\n\n        // Add facet to the list of facets if the facet address is new one\n        _saveFacetIfNew(_facet);\n\n        for (uint256 i = 0; i < _selectors.length; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress == address(0), \"J\"); // facet for this selector already exists\n\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Change associated facets to already known function selectors\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _replaceFunctions(\n        address _facet,\n        bytes4[] memory _selectors,\n        bool _isFacetFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet != address(0), \"K\"); // cannot replace facet with zero address\n\n        // Add facet to the list of facets if the facet address is a new one\n        _saveFacetIfNew(_facet);\n\n        for (uint256 i = 0; i < _selectors.length; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"L\"); // it is impossible to replace the facet with zero address\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n            _addOneFunction(_facet, selector, _isFacetFreezable);\n        }\n    }\n\n    /// @dev Remove association with function and facet\n    /// NOTE: expect but NOT enforce that `_selectors` is NON-EMPTY array\n    function _removeFunctions(address _facet, bytes4[] memory _selectors) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        require(_facet == address(0), \"a1\"); // facet address must be zero\n\n        for (uint256 i = 0; i < _selectors.length; ++i) {\n            bytes4 selector = _selectors[i];\n            SelectorToFacet memory oldFacet = ds.selectorToFacet[selector];\n            require(oldFacet.facetAddress != address(0), \"a2\"); // Can't delete a non-existent facet\n\n            _removeOneFunction(oldFacet.facetAddress, selector);\n        }\n    }\n\n    /// @dev Add address to the list of known facets if it is not on the list yet\n    /// NOTE: should be called ONLY before adding a new selector associated with the address\n    function _saveFacetIfNew(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint16 selectorsLength = uint16(ds.facetToSelectors[_facet].selectors.length);\n        // If there are no selectors associated with facet then save facet as new one\n        if (selectorsLength == 0) {\n            ds.facetToSelectors[_facet].facetPosition = uint16(ds.facets.length);\n            ds.facets.push(_facet);\n        }\n    }\n\n    /// @dev Add one function to the already known facet\n    /// NOTE: It is expected but NOT enforced that:\n    /// - `_facet` is NON-ZERO address\n    /// - `_facet` is already stored address in `DiamondStorage.facets`\n    /// - `_selector` is NOT associated by another facet\n    function _addOneFunction(\n        address _facet,\n        bytes4 _selector,\n        bool _isSelectorFreezable\n    ) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        uint16 selectorPosition = uint16(ds.facetToSelectors[_facet].selectors.length);\n        ds.selectorToFacet[_selector] = SelectorToFacet({\n            facetAddress: _facet,\n            selectorPosition: selectorPosition,\n            isFreezable: _isSelectorFreezable\n        });\n        ds.facetToSelectors[_facet].selectors.push(_selector);\n    }\n\n    /// @dev Remove one associated function with facet\n    /// NOTE: It is expected but NOT enforced that `_facet` is NON-ZERO address\n    function _removeOneFunction(address _facet, bytes4 _selector) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `FacetToSelectors.selectors` of the selector and last element of array\n        uint256 selectorPosition = ds.selectorToFacet[_selector].selectorPosition;\n        uint256 lastSelectorPosition = ds.facetToSelectors[_facet].selectors.length - 1;\n\n        // If the selector is not at the end of the array then move the last element to the selector position\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetToSelectors[_facet].selectors[lastSelectorPosition];\n\n            ds.facetToSelectors[_facet].selectors[selectorPosition] = lastSelector;\n            ds.selectorToFacet[lastSelector].selectorPosition = uint16(selectorPosition);\n        }\n\n        // Remove last element from the selectors array\n        ds.facetToSelectors[_facet].selectors.pop();\n\n        // Finally, clean up the association with facet\n        delete ds.selectorToFacet[_selector];\n\n        // If there are no selectors for facet then remove the facet from the list of known facets\n        if (lastSelectorPosition == 0) {\n            _removeFacet(_facet);\n        }\n    }\n\n    /// @dev remove facet from the list of known facets\n    /// NOTE: It is expected but NOT enforced that there are no selectors associated wih `_facet`\n    function _removeFacet(address _facet) private {\n        DiamondStorage storage ds = getDiamondStorage();\n\n        // Get index of `DiamondStorage.facets` of the facet and last element of array\n        uint256 facetPosition = ds.facetToSelectors[_facet].facetPosition;\n        uint256 lastFacetPosition = ds.facets.length - 1;\n\n        // If the facet is not at the end of the array then move the last element to the facet position\n        if (facetPosition != lastFacetPosition) {\n            address lastFacet = ds.facets[lastFacetPosition];\n\n            ds.facets[facetPosition] = lastFacet;\n            ds.facetToSelectors[lastFacet].facetPosition = uint16(facetPosition);\n        }\n\n        // Remove last element from the facets array\n        ds.facets.pop();\n    }\n\n    /// @dev Delegates call to the initialization address with provided calldata\n    /// @dev Used as a final step of diamond cut to execute the logic of the initialization for changed facets\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"H\"); // Non-empty calldata for zero address\n        } else {\n            // Do not check whether `_init` is a contract since later we check that it returns data.\n            (bool success, bytes memory data) = _init.delegatecall(_calldata);\n            require(success, \"I\"); // delegatecall failed\n\n            // Check that called contract returns magic value to make sure that contract logic\n            // supposed to be used as diamond cut initializer.\n            require(data.length == 32 && abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \"lp\");\n        }\n    }\n}\n"
    },
    "contracts/messaging/connectors/optimism/BaseOptimism.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {OptimismAmb} from \"../../interfaces/ambs/optimism/OptimismAmb.sol\";\n\nimport {GasCap} from \"../GasCap.sol\";\n\nabstract contract BaseOptimism is GasCap {\n  // ============ Constructor ============\n  constructor(uint256 _gasCap) GasCap(_gasCap) {}\n\n  // ============ Override Fns ============\n  function _verifySender(address _amb, address _expected) internal view returns (bool) {\n    require(msg.sender == _amb, \"!bridge\");\n    return OptimismAmb(_amb).xDomainMessageSender() == _expected;\n  }\n\n  /**\n   * @notice Using Optimism AMB, the gas is provided to `sendMessage` as an encoded uint\n   */\n  function _getGasFromEncoded(bytes memory _encodedData) internal view returns (uint256 _gas) {\n    // Should include gas info in specialized calldata\n    require(_encodedData.length == 32, \"!data length\");\n\n    // Get the gas, if it is more than the cap use the cap\n    _gas = _getGas(abi.decode(_encodedData, (uint256)));\n  }\n}\n"
    },
    "contracts/messaging/interfaces/ambs/optimism/OptimismAmb.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @dev The optimism bridge shares both of these functions, but it is important\n * to note that when going from L2 -> L1, the message cannot be processed by the\n * AMB until the challenge period elapses.\n *\n * HOWEVER, before the challenge elapses, you can read the state of the L2 as it is\n * placed on mainnet. By processing data from the L2 state, we are able to \"circumvent\"\n * this delay to a reasonable degree.\n *\n * This means that for messages going L1 -> L2, you can call \"processMessage\" and expect\n * the call to be executed to pass up the aggregate root. When going from L2 -> L1, you\n * must read the root from the L2 state\n *\n * L2 messenger: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L2/messaging/L2CrossDomainMessenger.sol\n * L1 messenger: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol\n */\ninterface OptimismAmb {\n  function sendMessage(\n    address _target,\n    bytes memory _message,\n    uint32 _gasLimit\n  ) external;\n\n  function xDomainMessageSender() external view returns (address);\n}\n"
    },
    "contracts/messaging/connectors/optimism/OptimismSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {OptimismAmb} from \"../../interfaces/ambs/optimism/OptimismAmb.sol\";\n\nimport {SpokeConnector, ProposedOwnable} from \"../SpokeConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\nimport {BaseOptimism} from \"./BaseOptimism.sol\";\n\ncontract OptimismSpokeConnector is SpokeConnector, BaseOptimism {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager,\n    uint256 _gasCap // gasLimit of message call on L1\n  )\n    SpokeConnector(\n      _domain,\n      _mirrorDomain,\n      _amb,\n      _rootManager,\n      _mirrorConnector,\n      _processGas,\n      _reserveGas,\n      _delayBlocks,\n      _merkle,\n      _watcherManager\n    )\n    BaseOptimism(_gasCap)\n  {}\n\n  // ============ Override Fns ============\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _verifySender(AMB, _expected);\n  }\n\n  /**\n   * @notice Should not be able to renounce ownership\n   */\n  function renounceOwnership() public virtual override(SpokeConnector, ProposedOwnable) onlyOwner {}\n\n  /**\n   * @dev Sends `outboundRoot` to root manager on l1\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be sending the outbound root\n    require(_data.length == 32, \"!data length\");\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\n    OptimismAmb(AMB).sendMessage(mirrorConnector, _calldata, uint32(_getGasFromEncoded(_encodedData)));\n  }\n\n  /**\n   * @dev Handles an incoming `aggregateRoot`\n   * NOTE: Could store latest root sent and prove aggregate root\n   */\n  function _processMessage(bytes memory _data) internal override {\n    // enforce this came from connector on l2\n    require(_verifySender(mirrorConnector), \"!mirrorConnector\");\n    // get the data (should be the aggregate root)\n    require(_data.length == 32, \"!length\");\n    // set the aggregate root\n    receiveAggregateRoot(bytes32(_data));\n  }\n}\n"
    },
    "contracts/messaging/connectors/optimism/OptimismHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {OptimismAmb} from \"../../interfaces/ambs/optimism/OptimismAmb.sol\";\nimport {IStateCommitmentChain, L2MessageInclusionProof} from \"../../interfaces/ambs/optimism/IStateCommitmentChain.sol\";\n\nimport {TypedMemView} from \"../../../shared/libraries/TypedMemView.sol\";\n\nimport {HubConnector} from \"../HubConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\nimport {PredeployAddresses} from \"./lib/PredeployAddresses.sol\";\nimport {OVMCodec} from \"./lib/OVMCodec.sol\";\nimport {SecureMerkleTrie} from \"./lib/SecureMerkleTrie.sol\";\n\nimport {BaseOptimism} from \"./BaseOptimism.sol\";\n\ncontract OptimismHubConnector is HubConnector, BaseOptimism {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // ============ Storage ============\n  IStateCommitmentChain public immutable stateCommitmentChain;\n\n  // NOTE: This is needed because we need to track the roots we've\n  // already sent across chains. When sending an optimism message, we send calldata\n  // for Connector.processMessage. At any point these messages could be processed\n  // before the timeout using `processFromRoot` or after the timeout using `process`\n  // we track the roots sent here to ensure we process each root once\n  mapping(bytes32 => bool) public processed;\n\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    address _stateCommitmentChain,\n    uint256 _gasCap\n  ) HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) BaseOptimism(_gasCap) {\n    stateCommitmentChain = IStateCommitmentChain(_stateCommitmentChain);\n  }\n\n  // ============ Override Fns ============\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _verifySender(AMB, _expected);\n  }\n\n  /**\n   * @dev Sends `aggregateRoot` to messaging on l2\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be dispatching the aggregate root\n    require(_data.length == 32, \"!length\");\n    // Get the calldata\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\n    // Dispatch message\n    OptimismAmb(AMB).sendMessage(mirrorConnector, _calldata, uint32(gasCap));\n  }\n\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\n  // `processMessageFromRoot` flow.\n\n  /**\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L165\n   */\n  function processMessageFromRoot(\n    address _target,\n    address _sender,\n    bytes memory _message,\n    uint256 _messageNonce,\n    L2MessageInclusionProof memory _proof\n  ) external {\n    // verify the sender is the l2 contract\n    require(_sender == mirrorConnector, \"!mirrorConnector\");\n\n    // verify the target is this contract\n    require(_target == address(this), \"!this\");\n\n    // Get the encoded data\n    bytes memory xDomainData = _encodeXDomainCalldata(_target, _sender, _message, _messageNonce);\n\n    require(_verifyXDomainMessage(xDomainData, _proof), \"!proof\");\n\n    // NOTE: optimism seems to pad the calldata sent in to include more than the expected\n    // 36 bytes, i.e. in this transaction:\n    // https://blockscout.com/optimism/goerli/tx/0x440fda036d28eb547394a8689af90c5342a00a8ca2ab5117f2b85f54d1416ddd/logs\n    // the corresponding _message is:\n    // 0x4ff746f60000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002027ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\n    //\n    // this means the length check and byte parsing used in the `ArbitrumHubConnector` would\n    // not work here. Instead, take the back 32 bytes of the string\n\n    // NOTE: TypedMemView only loads 32-byte chunks onto stack, which is fine in this case\n    bytes29 _view = _message.ref(0);\n    bytes32 root = _view.index(_view.len() - 32, 32);\n\n    if (!processed[root]) {\n      // set root to processed\n      processed[root] = true;\n      // update the root on the root manager\n      IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, root);\n\n      emit MessageProcessed(abi.encode(root), msg.sender);\n    } // otherwise root was already sent to root manager\n  }\n\n  /**\n   * Verifies that the given message is valid.\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L283-L288\n   * @param _xDomainCalldata Calldata to verify.\n   * @param _proof Inclusion proof for the message.\n   * @return Whether or not the provided message is valid.\n   */\n  function _verifyXDomainMessage(bytes memory _xDomainCalldata, L2MessageInclusionProof memory _proof)\n    internal\n    view\n    returns (bool)\n  {\n    return (_verifyStateRootProof(_proof) && _verifyStorageProof(_xDomainCalldata, _proof));\n  }\n\n  /**\n   * Verifies that the state root within an inclusion proof is valid.\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L295-L311\n   * @param _proof Message inclusion proof.\n   * @return Whether or not the provided proof is valid.\n   */\n  function _verifyStateRootProof(L2MessageInclusionProof memory _proof) internal view returns (bool) {\n    return\n      stateCommitmentChain.verifyStateCommitment(_proof.stateRoot, _proof.stateRootBatchHeader, _proof.stateRootProof);\n  }\n\n  /**\n   * Verifies that the storage proof within an inclusion proof is valid.\n   * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/9973c1da3211e094a180a8a96ba9f8bb1ab1b389/packages/contracts/contracts/L1/messaging/L1CrossDomainMessenger.sol#L313-L357\n   * @param _xDomainCalldata Encoded message calldata.\n   * @param _proof Message inclusion proof.\n   * @return Whether or not the provided proof is valid.\n   */\n  function _verifyStorageProof(bytes memory _xDomainCalldata, L2MessageInclusionProof memory _proof)\n    internal\n    pure\n    returns (bool)\n  {\n    bytes32 storageKey = keccak256(\n      abi.encodePacked(\n        keccak256(abi.encodePacked(_xDomainCalldata, PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER)),\n        uint256(0)\n      )\n    );\n\n    (bool exists, bytes memory encodedMessagePassingAccount) = SecureMerkleTrie.get(\n      abi.encodePacked(PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),\n      _proof.stateTrieWitness,\n      _proof.stateRoot\n    );\n\n    require(exists == true, \"Message passing predeploy has not been initialized or invalid proof provided.\");\n\n    OVMCodec.EVMAccount memory account = OVMCodec.decodeEVMAccount(encodedMessagePassingAccount);\n\n    return\n      SecureMerkleTrie.verifyInclusionProof(\n        abi.encodePacked(storageKey),\n        abi.encodePacked(uint8(1)),\n        _proof.storageTrieWitness,\n        account.storageRoot\n      );\n  }\n\n  /**\n   * Generates the correct cross domain calldata for a message.\n   * @dev taken from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/bridge/Lib_CrossDomainUtils.sol\n   * @param _target Target contract address.\n   * @param _sender Message sender address.\n   * @param _message Message to send to the target.\n   * @param _messageNonce Nonce for the provided message.\n   * @return ABI encoded cross domain calldata.\n   */\n  function _encodeXDomainCalldata(\n    address _target,\n    address _sender,\n    bytes memory _message,\n    uint256 _messageNonce\n  ) internal pure returns (bytes memory) {\n    return\n      abi.encodeWithSignature(\"relayMessage(address,address,bytes,uint256)\", _target, _sender, _message, _messageNonce);\n  }\n}\n"
    },
    "contracts/messaging/interfaces/ambs/optimism/IStateCommitmentChain.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// modified from: https://github.com/ethereum-optimism/optimism/blob/fcfcf6e7e69801e63904ec53815db01a8d45dcac/packages/contracts/contracts/libraries/codec/Lib_OVMCodec.sol#L34-L40\nstruct ChainBatchHeader {\n  uint256 batchIndex;\n  bytes32 batchRoot;\n  uint256 batchSize;\n  uint256 prevTotalElements;\n  bytes extraData;\n}\n\n// modified from: https://github.com/ethereum-optimism/optimism/blob/fcfcf6e7e69801e63904ec53815db01a8d45dcac/packages/contracts/contracts/libraries/codec/Lib_OVMCodec.sol#L42-L45\nstruct ChainInclusionProof {\n  uint256 index;\n  bytes32[] siblings;\n}\n\n// modified from: https://github.com/ethereum-optimism/optimism/blob/fcfcf6e7e69801e63904ec53815db01a8d45dcac/packages/contracts/contracts/L1/messaging/IL1CrossDomainMessenger.sol#L18-L24\nstruct L2MessageInclusionProof {\n  bytes32 stateRoot;\n  ChainBatchHeader stateRootBatchHeader;\n  ChainInclusionProof stateRootProof;\n  bytes stateTrieWitness;\n  bytes storageTrieWitness;\n}\n\n/**\n * @title IStateCommitmentChain\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/L1/rollup/IStateCommitmentChain.sol\n */\ninterface IStateCommitmentChain {\n  /**********\n   * Events *\n   **********/\n\n  event StateBatchAppended(\n    uint256 indexed _batchIndex,\n    bytes32 _batchRoot,\n    uint256 _batchSize,\n    uint256 _prevTotalElements,\n    bytes _extraData\n  );\n\n  event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);\n\n  /********************\n   * Public Functions *\n   ********************/\n\n  /**\n   * Retrieves the total number of elements submitted.\n   * @return _totalElements Total submitted elements.\n   */\n  function getTotalElements() external view returns (uint256 _totalElements);\n\n  /**\n   * Retrieves the total number of batches submitted.\n   * @return _totalBatches Total submitted batches.\n   */\n  function getTotalBatches() external view returns (uint256 _totalBatches);\n\n  /**\n   * Retrieves the timestamp of the last batch submitted by the sequencer.\n   * @return _lastSequencerTimestamp Last sequencer batch timestamp.\n   */\n  function getLastSequencerTimestamp() external view returns (uint256 _lastSequencerTimestamp);\n\n  /**\n   * Appends a batch of state roots to the chain.\n   * @param _batch Batch of state roots.\n   * @param _shouldStartAtElement Index of the element at which this batch should start.\n   */\n  function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) external;\n\n  /**\n   * Deletes all state roots after (and including) a given batch.\n   * @param _batchHeader Header of the batch to start deleting from.\n   */\n  function deleteStateBatch(ChainBatchHeader memory _batchHeader) external;\n\n  /**\n   * Verifies a batch inclusion proof.\n   * @param _element Hash of the element to verify a proof for.\n   * @param _batchHeader Header of the batch in which the element was included.\n   * @param _proof Merkle inclusion proof for the element.\n   */\n  function verifyStateCommitment(\n    bytes32 _element,\n    ChainBatchHeader memory _batchHeader,\n    ChainInclusionProof memory _proof\n  ) external view returns (bool _verified);\n\n  /**\n   * Checks whether a given batch is still inside its fraud proof window.\n   * @param _batchHeader Header of the batch to check.\n   * @return _inside Whether or not the batch is inside the fraud proof window.\n   */\n  function insideFraudProofWindow(ChainBatchHeader memory _batchHeader) external view returns (bool _inside);\n}\n"
    },
    "contracts/messaging/connectors/optimism/lib/PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title PredeployAddresses\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/constants/Lib_PredeployAddresses.sol\n */\nlibrary PredeployAddresses {\n  address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n  address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n  address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n  address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n  address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x4200000000000000000000000000000000000007;\n  address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n  address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n  address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n  address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n  address internal constant L2_STANDARD_TOKEN_FACTORY = 0x4200000000000000000000000000000000000012;\n  address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n}\n"
    },
    "contracts/messaging/connectors/optimism/lib/OVMCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/* Library Imports */\nimport {RLPReader} from \"./RLPReader.sol\";\n\n/**\n * @title OVMCodec\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/codec/Lib_OVMCodec.sol\n */\nlibrary OVMCodec {\n  /***********\n   * Structs *\n   ***********/\n\n  struct EVMAccount {\n    uint256 nonce;\n    uint256 balance;\n    bytes32 storageRoot;\n    bytes32 codeHash;\n  }\n\n  /**\n   * @notice Decodes an RLP-encoded account state into a useful struct.\n   * @param _encoded RLP-encoded account state.\n   * @return Account state struct.\n   */\n  function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\n    RLPReader.RLPItem[] memory accountState = RLPReader.readList(_encoded);\n\n    return\n      EVMAccount({\n        nonce: RLPReader.readUint256(accountState[0]),\n        balance: RLPReader.readUint256(accountState[1]),\n        storageRoot: RLPReader.readBytes32(accountState[2]),\n        codeHash: RLPReader.readBytes32(accountState[3])\n      });\n  }\n}\n"
    },
    "contracts/messaging/connectors/optimism/lib/SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/* Library Imports */\nimport {MerkleTrie} from \"./MerkleTrie.sol\";\n\n/**\n * @title SecureMerkleTrie\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/trie/Lib_SecureMerkleTrie.sol\n */\nlibrary SecureMerkleTrie {\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /**\n   * @notice Verifies a proof that a given key/value pair is present in the\n   * Merkle trie.\n   * @param _key Key of the node to search for, as a hex string.\n   * @param _value Value of the node to search for, as a hex string.\n   * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n   * traditional Merkle trees, this proof is executed top-down and consists\n   * of a list of RLP-encoded nodes that make a path down to the target node.\n   * @param _root Known root of the Merkle trie. Used to verify that the\n   * included proof is correctly constructed.\n   * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n   */\n  function verifyInclusionProof(\n    bytes memory _key,\n    bytes memory _value,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _verified) {\n    bytes memory key = _getSecureKey(_key);\n    return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n  }\n\n  /**\n   * @notice Retrieves the value associated with a given key.\n   * @param _key Key to search for, as hex bytes.\n   * @param _proof Merkle trie inclusion proof for the key.\n   * @param _root Known root of the Merkle trie.\n   * @return _exists Whether or not the key exists.\n   * @return _value Value of the key if it exists.\n   */\n  function get(\n    bytes memory _key,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _exists, bytes memory _value) {\n    bytes memory key = _getSecureKey(_key);\n    return MerkleTrie.get(key, _proof, _root);\n  }\n\n  /*********************\n   * Private Functions *\n   *********************/\n\n  /**\n   * Computes the secure counterpart to a key.\n   * @param _key Key to get a secure key from.\n   * @return _secureKey Secure version of the key.\n   */\n  function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\n    return abi.encodePacked(keccak256(_key));\n  }\n}\n"
    },
    "contracts/messaging/connectors/optimism/lib/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title RLPReader\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/rlp/Lib_RLPReader.sol\n */\nlibrary RLPReader {\n  /*************\n   * Constants *\n   *************/\n\n  uint256 internal constant MAX_LIST_LENGTH = 32;\n\n  /*********\n   * Enums *\n   *********/\n\n  enum RLPItemType {\n    DATA_ITEM,\n    LIST_ITEM\n  }\n\n  /***********\n   * Structs *\n   ***********/\n\n  struct RLPItem {\n    uint256 length;\n    uint256 ptr;\n  }\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /**\n   * Converts bytes to a reference to memory position and length.\n   * @param _in Input bytes to convert.\n   * @return Output memory reference.\n   */\n  function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n    uint256 ptr;\n    assembly {\n      ptr := add(_in, 32)\n    }\n\n    return RLPItem({length: _in.length, ptr: ptr});\n  }\n\n  /**\n   * Reads an RLP list value into a list of RLP items.\n   * @param _in RLP list value.\n   * @return Decoded RLP list items.\n   */\n  function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n    (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n    require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\n\n    // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n    // writing to the length. Since we can't know the number of RLP items without looping over\n    // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n    // simply set a reasonable maximum list length and decrease the size before we finish.\n    RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n    uint256 itemCount = 0;\n    uint256 offset = listOffset;\n    while (offset < _in.length) {\n      require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\n\n      (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n        RLPItem({length: _in.length - offset, ptr: _in.ptr + offset})\n      );\n\n      out[itemCount] = RLPItem({length: itemLength + itemOffset, ptr: _in.ptr + offset});\n\n      itemCount += 1;\n      offset += itemOffset + itemLength;\n    }\n\n    // Decrease the array size to match the actual item count.\n    assembly {\n      mstore(out, itemCount)\n    }\n\n    return out;\n  }\n\n  /**\n   * Reads an RLP list value into a list of RLP items.\n   * @param _in RLP list value.\n   * @return Decoded RLP list items.\n   */\n  function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n    return readList(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP bytes value into bytes.\n   * @param _in RLP bytes value.\n   * @return Decoded bytes.\n   */\n  function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n    (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n    require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\n\n    return _copy(_in.ptr, itemOffset, itemLength);\n  }\n\n  /**\n   * Reads an RLP bytes value into bytes.\n   * @param _in RLP bytes value.\n   * @return Decoded bytes.\n   */\n  function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n    return readBytes(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP string value into a string.\n   * @param _in RLP string value.\n   * @return Decoded string.\n   */\n  function readString(RLPItem memory _in) internal pure returns (string memory) {\n    return string(readBytes(_in));\n  }\n\n  /**\n   * Reads an RLP string value into a string.\n   * @param _in RLP string value.\n   * @return Decoded string.\n   */\n  function readString(bytes memory _in) internal pure returns (string memory) {\n    return readString(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP bytes32 value into a bytes32.\n   * @param _in RLP bytes32 value.\n   * @return Decoded bytes32.\n   */\n  function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n    // instead of <= 33\n    require(_in.length < 33 + 1, \"Invalid RLP bytes32 value.\");\n\n    (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n    require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\n\n    uint256 ptr = _in.ptr + itemOffset;\n    bytes32 out;\n    assembly {\n      out := mload(ptr)\n\n      // Shift the bytes over to match the item size.\n      if lt(itemLength, 32) {\n        out := div(out, exp(256, sub(32, itemLength)))\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Reads an RLP bytes32 value into a bytes32.\n   * @param _in RLP bytes32 value.\n   * @return Decoded bytes32.\n   */\n  function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n    return readBytes32(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP uint256 value into a uint256.\n   * @param _in RLP uint256 value.\n   * @return Decoded uint256.\n   */\n  function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n    return uint256(readBytes32(_in));\n  }\n\n  /**\n   * Reads an RLP uint256 value into a uint256.\n   * @param _in RLP uint256 value.\n   * @return Decoded uint256.\n   */\n  function readUint256(bytes memory _in) internal pure returns (uint256) {\n    return readUint256(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP bool value into a bool.\n   * @param _in RLP bool value.\n   * @return Decoded bool.\n   */\n  function readBool(RLPItem memory _in) internal pure returns (bool) {\n    require(_in.length == 1, \"Invalid RLP boolean value.\");\n\n    uint256 ptr = _in.ptr;\n    uint256 out;\n    assembly {\n      out := byte(0, mload(ptr))\n    }\n\n    require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\n\n    return out != 0;\n  }\n\n  /**\n   * Reads an RLP bool value into a bool.\n   * @param _in RLP bool value.\n   * @return Decoded bool.\n   */\n  function readBool(bytes memory _in) internal pure returns (bool) {\n    return readBool(toRLPItem(_in));\n  }\n\n  /**\n   * Reads an RLP address value into a address.\n   * @param _in RLP address value.\n   * @return Decoded address.\n   */\n  function readAddress(RLPItem memory _in) internal pure returns (address) {\n    if (_in.length == 1) {\n      return address(0);\n    }\n\n    require(_in.length == 21, \"Invalid RLP address value.\");\n\n    return address(uint160(readUint256(_in)));\n  }\n\n  /**\n   * Reads an RLP address value into a address.\n   * @param _in RLP address value.\n   * @return Decoded address.\n   */\n  function readAddress(bytes memory _in) internal pure returns (address) {\n    return readAddress(toRLPItem(_in));\n  }\n\n  /**\n   * Reads the raw bytes of an RLP item.\n   * @param _in RLP item to read.\n   * @return Raw RLP bytes.\n   */\n  function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n    return _copy(_in);\n  }\n\n  /*********************\n   * Private Functions *\n   *********************/\n\n  /**\n   * Decodes the length of an RLP item.\n   * @param _in RLP item to decode.\n   * @return Offset of the encoded data.\n   * @return Length of the encoded data.\n   * @return RLP item type (LIST_ITEM or DATA_ITEM).\n   */\n  function _decodeLength(RLPItem memory _in)\n    private\n    pure\n    returns (\n      uint256,\n      uint256,\n      RLPItemType\n    )\n  {\n    require(_in.length > 0, \"RLP item cannot be null.\");\n\n    uint256 ptr = _in.ptr;\n    uint256 prefix;\n    assembly {\n      prefix := byte(0, mload(ptr))\n    }\n\n    if (prefix < 0x7f + 1) {\n      // Single byte.\n\n      return (0, 1, RLPItemType.DATA_ITEM);\n    } else if (prefix < 0xb7 + 1) {\n      // Short string.\n\n      // slither-disable-next-line variable-scope\n      uint256 strLen = prefix - 0x80;\n\n      require(_in.length > strLen, \"Invalid RLP short string.\");\n\n      return (1, strLen, RLPItemType.DATA_ITEM);\n    } else if (prefix < 0xbf + 1) {\n      // Long string.\n      uint256 lenOfStrLen = prefix - 0xb7;\n\n      require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\n\n      uint256 strLen;\n      assembly {\n        // Pick out the string length.\n        strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n      }\n\n      require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\n\n      return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n    } else if (prefix < 0xf7 + 1) {\n      // Short list.\n      // slither-disable-next-line variable-scope\n      uint256 listLen = prefix - 0xc0;\n\n      require(_in.length > listLen, \"Invalid RLP short list.\");\n\n      return (1, listLen, RLPItemType.LIST_ITEM);\n    } else {\n      // Long list.\n      uint256 lenOfListLen = prefix - 0xf7;\n\n      require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\n\n      uint256 listLen;\n      assembly {\n        // Pick out the list length.\n        listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n      }\n\n      require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\n\n      return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n    }\n  }\n\n  /**\n   * Copies the bytes from a memory location.\n   * @param _src Pointer to the location to read from.\n   * @param _offset Offset to start reading from.\n   * @param _length Number of bytes to read.\n   * @return Copied bytes.\n   */\n  function _copy(\n    uint256 _src,\n    uint256 _offset,\n    uint256 _length\n  ) private pure returns (bytes memory) {\n    bytes memory out = new bytes(_length);\n    if (out.length == 0) {\n      return out;\n    }\n\n    uint256 src = _src + _offset;\n    uint256 dest;\n    assembly {\n      dest := add(out, 32)\n    }\n\n    // Copy over as many complete words as we can.\n    for (uint256 i = 0; i < _length / 32; ) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n\n      src += 32;\n      dest += 32;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // Pick out the remaining bytes.\n    uint256 mask;\n    unchecked {\n      mask = 256**(32 - (_length % 32)) - 1;\n    }\n\n    assembly {\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n    }\n    return out;\n  }\n\n  /**\n   * Copies an RLP item into bytes.\n   * @param _in RLP item to copy.\n   * @return Copied bytes.\n   */\n  function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n    return _copy(_in.ptr, 0, _in.length);\n  }\n}\n"
    },
    "contracts/messaging/connectors/optimism/lib/MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/* Library Imports */\nimport {BytesUtils} from \"./BytesUtils.sol\";\nimport {RLPReader} from \"./RLPReader.sol\";\n\n/**\n * @title MerkleTrie\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/trie/Lib_MerkleTrie.sol\n */\nlibrary MerkleTrie {\n  /*******************\n   * Data Structures *\n   *******************/\n\n  enum NodeType {\n    BranchNode,\n    ExtensionNode,\n    LeafNode\n  }\n\n  struct TrieNode {\n    bytes encoded;\n    RLPReader.RLPItem[] decoded;\n  }\n\n  /**********************\n   * Contract Constants *\n   **********************/\n\n  // TREE_RADIX determines the number of elements per branch node.\n  uint256 constant TREE_RADIX = 16;\n  // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\n  uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n  // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\n  uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n  // Prefixes are prepended to the `path` within a leaf or extension node and\n  // allow us to differentiate between the two node types. `ODD` or `EVEN` is\n  // determined by the number of nibbles within the unprefixed `path`. If the\n  // number of nibbles if even, we need to insert an extra padding nibble so\n  // the resulting prefixed `path` has an even number of nibbles.\n  uint8 constant PREFIX_EXTENSION_EVEN = 0;\n  uint8 constant PREFIX_EXTENSION_ODD = 1;\n  uint8 constant PREFIX_LEAF_EVEN = 2;\n  uint8 constant PREFIX_LEAF_ODD = 3;\n\n  // Just a utility constant. RLP represents `NULL` as 0x80.\n  bytes1 constant RLP_NULL = bytes1(0x80);\n\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  /**\n   * @notice Verifies a proof that a given key/value pair is present in the\n   * Merkle trie.\n   * @param _key Key of the node to search for, as a hex string.\n   * @param _value Value of the node to search for, as a hex string.\n   * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n   * traditional Merkle trees, this proof is executed top-down and consists\n   * of a list of RLP-encoded nodes that make a path down to the target node.\n   * @param _root Known root of the Merkle trie. Used to verify that the\n   * included proof is correctly constructed.\n   * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n   */\n  function verifyInclusionProof(\n    bytes memory _key,\n    bytes memory _value,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _verified) {\n    (bool exists, bytes memory value) = get(_key, _proof, _root);\n\n    return (exists && BytesUtils.equal(_value, value));\n  }\n\n  /**\n   * @notice Retrieves the value associated with a given key.\n   * @param _key Key to search for, as hex bytes.\n   * @param _proof Merkle trie inclusion proof for the key.\n   * @param _root Known root of the Merkle trie.\n   * @return _exists Whether or not the key exists.\n   * @return _value Value of the key if it exists.\n   */\n  function get(\n    bytes memory _key,\n    bytes memory _proof,\n    bytes32 _root\n  ) internal pure returns (bool _exists, bytes memory _value) {\n    TrieNode[] memory proof = _parseProof(_proof);\n    (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(proof, _key, _root);\n\n    bool exists = keyRemainder.length == 0;\n\n    require(exists || isFinalNode, \"Provided proof is invalid.\");\n\n    bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\n    return (exists, value);\n  }\n\n  /*********************\n   * Private Functions *\n   *********************/\n\n  /**\n   * @notice Walks through a proof using a provided key.\n   * @param _proof Inclusion proof to walk through.\n   * @param _key Key to use for the walk.\n   * @param _root Known root of the trie.\n   * @return _pathLength Length of the final path\n   * @return _keyRemainder Portion of the key remaining after the walk.\n   * @return _isFinalNode Whether or not we've hit a dead end.\n   */\n  function _walkNodePath(\n    TrieNode[] memory _proof,\n    bytes memory _key,\n    bytes32 _root\n  )\n    private\n    pure\n    returns (\n      uint256 _pathLength,\n      bytes memory _keyRemainder,\n      bool _isFinalNode\n    )\n  {\n    uint256 pathLength = 0;\n    bytes memory key = BytesUtils.toNibbles(_key);\n\n    bytes32 currentNodeID = _root;\n    uint256 currentKeyIndex = 0;\n    uint256 currentKeyIncrement = 0;\n    TrieNode memory currentNode;\n\n    // Proof is top-down, so we start at the first element (root).\n    uint256 len = _proof.length;\n    for (uint256 i = 0; i < len; ) {\n      currentNode = _proof[i];\n      currentKeyIndex += currentKeyIncrement;\n\n      // Keep track of the proof elements we actually need.\n      // It's expensive to resize arrays, so this simply reduces gas costs.\n      pathLength += 1;\n\n      if (currentKeyIndex == 0) {\n        // First proof element is always the root node.\n        require(keccak256(currentNode.encoded) == currentNodeID, \"Invalid root hash\");\n      } else if (currentNode.encoded.length > 32 - 1) {\n        // Nodes 32 bytes or larger are hashed inside branch nodes.\n        require(keccak256(currentNode.encoded) == currentNodeID, \"Invalid large internal hash\");\n      } else {\n        // Nodes smaller than 31 bytes aren't hashed.\n        require(BytesUtils.toBytes32(currentNode.encoded) == currentNodeID, \"Invalid internal node hash\");\n      }\n\n      // unreachable code if it's below the if statement under this\n      unchecked {\n        ++i;\n      }\n\n      if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n        if (currentKeyIndex == key.length) {\n          // We've hit the end of the key\n          // meaning the value should be within this branch node.\n          break;\n        } else {\n          // We're not at the end of the key yet.\n          // Figure out what the next node ID should be and continue.\n          uint8 branchKey = uint8(key[currentKeyIndex]);\n          RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n          currentNodeID = _getNodeID(nextNode);\n          currentKeyIncrement = 1;\n          continue;\n        }\n      } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n        bytes memory path = _getNodePath(currentNode);\n        uint8 prefix = uint8(path[0]);\n        uint8 offset = 2 - (prefix % 2);\n        bytes memory pathRemainder = BytesUtils.slice(path, offset);\n        bytes memory keyRemainder = BytesUtils.slice(key, currentKeyIndex);\n        uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n        if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n          if (pathRemainder.length == sharedNibbleLength && keyRemainder.length == sharedNibbleLength) {\n            // The key within this leaf matches our key exactly.\n            // Increment the key index to reflect that we have no remainder.\n            currentKeyIndex += sharedNibbleLength;\n          }\n\n          // We've hit a leaf node, so our next node should be NULL.\n          currentNodeID = bytes32(RLP_NULL);\n          break;\n        } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n          if (sharedNibbleLength != pathRemainder.length) {\n            // Our extension node is not identical to the remainder.\n            // We've hit the end of this path\n            // updates will need to modify this extension.\n            currentNodeID = bytes32(RLP_NULL);\n            break;\n          } else {\n            // Our extension shares some nibbles.\n            // Carry on to the next node.\n            currentNodeID = _getNodeID(currentNode.decoded[1]);\n            currentKeyIncrement = sharedNibbleLength;\n            continue;\n          }\n        } else {\n          revert(\"Received a node with an unknown prefix\");\n        }\n      } else {\n        revert(\"Received an unparseable node.\");\n      }\n    }\n\n    // If our node ID is NULL, then we're at a dead end.\n    bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\n    return (pathLength, BytesUtils.slice(key, currentKeyIndex), isFinalNode);\n  }\n\n  /**\n   * @notice Parses an RLP-encoded proof into something more useful.\n   * @param _proof RLP-encoded proof to parse.\n   * @return _parsed Proof parsed into easily accessible structs.\n   */\n  function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\n    RLPReader.RLPItem[] memory nodes = RLPReader.readList(_proof);\n    TrieNode[] memory proof = new TrieNode[](nodes.length);\n\n    uint256 len = nodes.length;\n    for (uint256 i = 0; i < len; ) {\n      bytes memory encoded = RLPReader.readBytes(nodes[i]);\n      proof[i] = TrieNode({encoded: encoded, decoded: RLPReader.readList(encoded)});\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return proof;\n  }\n\n  /**\n   * @notice Picks out the ID for a node. Node ID is referred to as the\n   * \"hash\" within the specification, but nodes < 32 bytes are not actually\n   * hashed.\n   * @param _node Node to pull an ID for.\n   * @return _nodeID ID for the node, depending on the size of its contents.\n   */\n  function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\n    bytes memory nodeID;\n\n    if (_node.length < 32) {\n      // Nodes smaller than 32 bytes are RLP encoded.\n      nodeID = RLPReader.readRawBytes(_node);\n    } else {\n      // Nodes 32 bytes or larger are hashed.\n      nodeID = RLPReader.readBytes(_node);\n    }\n\n    return BytesUtils.toBytes32(nodeID);\n  }\n\n  /**\n   * @notice Gets the path for a leaf or extension node.\n   * @param _node Node to get a path for.\n   * @return _path Node path, converted to an array of nibbles.\n   */\n  function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\n    return BytesUtils.toNibbles(RLPReader.readBytes(_node.decoded[0]));\n  }\n\n  /**\n   * @notice Gets the path for a node.\n   * @param _node Node to get a value for.\n   * @return _value Node value, as hex bytes.\n   */\n  function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\n    return RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n  }\n\n  /**\n   * @notice Utility; determines the number of nibbles shared between two\n   * nibble arrays.\n   * @param _a First nibble array.\n   * @param _b Second nibble array.\n   * @return _shared Number of shared nibbles.\n   */\n  function _getSharedNibbleLength(bytes memory _a, bytes memory _b) private pure returns (uint256 _shared) {\n    uint256 i = 0;\n    while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\n      i++;\n    }\n    return i;\n  }\n}\n"
    },
    "contracts/messaging/connectors/optimism/lib/BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title BytesUtils\n *\n * @dev modified from: https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts/contracts/libraries/utils/Lib_BytesUtils.sol\n */\nlibrary BytesUtils {\n  /**********************\n   * Internal Functions *\n   **********************/\n\n  function slice(\n    bytes memory _bytes,\n    uint256 _start,\n    uint256 _length\n  ) internal pure returns (bytes memory) {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_start + _length >= _start, \"slice_overflow\");\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n    bytes memory tempBytes;\n\n    assembly {\n      switch iszero(_length)\n      case 0 {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n        tempBytes := mload(0x40)\n\n        // The first word of the slice result is potentially a partial\n        // word read from the original array. To read it, we calculate\n        // the length of that partial word and start copying that many\n        // bytes into the array. The first word we copy will start with\n        // data we don't care about, but the last `lengthmod` bytes will\n        // land at the beginning of the contents of the new array. When\n        // we're done copying, we overwrite the full first word with\n        // the actual length of the slice.\n        let lengthmod := and(_length, 31)\n\n        // The multiplication in the next line is necessary\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\n        // the following copy loop was copying the origin's length\n        // and then ending prematurely not copying everything it should.\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n        let end := add(mc, _length)\n\n        for {\n          // The multiplication in the next line has the same exact purpose\n          // as the one above.\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n        } lt(mc, end) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          mstore(mc, mload(cc))\n        }\n\n        mstore(tempBytes, _length)\n\n        //update free-memory pointer\n        //allocating the array padded to 32 bytes like the compiler does now\n        mstore(0x40, and(add(mc, 31), not(31)))\n      }\n      //if we want a zero-length slice let's just return a zero-length array\n      default {\n        tempBytes := mload(0x40)\n\n        //zero out the 32 bytes slice we are about to return\n        //we need to do it because Solidity does not garbage collect\n        mstore(tempBytes, 0)\n\n        mstore(0x40, add(tempBytes, 0x20))\n      }\n    }\n\n    return tempBytes;\n  }\n\n  function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n    if (_start >= _bytes.length) {\n      return bytes(\"\");\n    }\n\n    return slice(_bytes, _start, _bytes.length - _start);\n  }\n\n  function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\n    if (_bytes.length < 32) {\n      bytes32 ret;\n      assembly {\n        ret := mload(add(_bytes, 32))\n      }\n      return ret;\n    }\n\n    return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n  }\n\n  function toUint256(bytes memory _bytes) internal pure returns (uint256) {\n    return uint256(toBytes32(_bytes));\n  }\n\n  function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n    bytes memory nibbles = new bytes(_bytes.length * 2);\n\n    uint256 len = _bytes.length;\n    for (uint256 i = 0; i < len; ) {\n      nibbles[i * 2] = _bytes[i] >> 4;\n      nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return nibbles;\n  }\n\n  function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n    bytes memory ret = new bytes(_bytes.length / 2);\n\n    uint256 len = ret.length;\n    for (uint256 i = 0; i < len; ) {\n      ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return ret;\n  }\n\n  function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n    return keccak256(_bytes) == keccak256(_other);\n  }\n}\n"
    },
    "contracts/messaging/connectors/polygon/PolygonHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\n\nimport {FxBaseRootTunnel} from \"./tunnel/FxBaseRootTunnel.sol\";\n\nimport {HubConnector} from \"../HubConnector.sol\";\n\ncontract PolygonHubConnector is HubConnector, FxBaseRootTunnel {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    address _checkPointManager\n  )\n    HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector)\n    FxBaseRootTunnel(_checkPointManager, _amb)\n  {}\n\n  // ============ Private fns ============\n\n  function _verifySender(address _expected) internal view override returns (bool) {\n    // NOTE: always return false on polygon\n    return false;\n  }\n\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    _sendMessageToChild(_data);\n  }\n\n  function _processMessageFromChild(bytes memory message) internal override {\n    // NOTE: crosschain sender is not directly exposed by the child message\n\n    // do not need any additional sender or origin checks here since the proof contains inclusion proofs of the snapshots\n\n    // get the data (should be the aggregate root)\n    require(message.length == 32, \"!length\");\n    // update the root on the root manager\n    IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, bytes32(message));\n\n    emit MessageProcessed(message, msg.sender);\n  }\n\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\n  // `_processMessageFromChild` flow.\n\n  function _setMirrorConnector(address _mirrorConnector) internal override {\n    // NOTE: FxBaseRootTunnel has the following code in their `setFxChildTunnel`:\n    // ```\n    // require(fxChildTunnel == address(0x0), \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\");\n    // ```\n    // Which means this function will revert if updating the `mirrorConnector`. In that case, in\n    // changes  the\n    // hub connector should also be redeployed\n    super._setMirrorConnector(_mirrorConnector);\n\n    setFxChildTunnel(_mirrorConnector);\n  }\n}\n"
    },
    "contracts/messaging/connectors/polygon/tunnel/FxBaseRootTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/fx-portal/contracts/blob/main/contracts/tunnel/FxBaseRootTunnel.sol\npragma solidity 0.8.17;\n\nimport {RLPReader} from \"../lib/RLPReader.sol\";\nimport {MerklePatriciaProof} from \"../lib/MerklePatriciaProof.sol\";\nimport {Merkle} from \"../lib/Merkle.sol\";\nimport \"../lib/ExitPayloadReader.sol\";\n\ninterface IFxStateSender {\n  function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\ncontract ICheckpointManager {\n  struct HeaderBlock {\n    bytes32 root;\n    uint256 start;\n    uint256 end;\n    uint256 createdAt;\n    address proposer;\n  }\n\n  /**\n   * @notice mapping of checkpoint header numbers to block details\n   * @dev These checkpoints are submited by plasma contracts\n   */\n  mapping(uint256 => HeaderBlock) public headerBlocks;\n}\n\nabstract contract FxBaseRootTunnel {\n  using RLPReader for RLPReader.RLPItem;\n  using Merkle for bytes32;\n  using ExitPayloadReader for bytes;\n  using ExitPayloadReader for ExitPayloadReader.ExitPayload;\n  using ExitPayloadReader for ExitPayloadReader.Log;\n  using ExitPayloadReader for ExitPayloadReader.LogTopics;\n  using ExitPayloadReader for ExitPayloadReader.Receipt;\n\n  // keccak256(MessageSent(bytes))\n  bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\n\n  // state sender contract\n  IFxStateSender public fxRoot;\n  // root chain manager\n  ICheckpointManager public checkpointManager;\n  // child tunnel contract which receives and sends messages\n  address public fxChildTunnel;\n\n  // storage to avoid duplicate exits\n  mapping(bytes32 => bool) public processedExits;\n\n  constructor(address _checkpointManager, address _fxRoot) {\n    checkpointManager = ICheckpointManager(_checkpointManager);\n    fxRoot = IFxStateSender(_fxRoot);\n  }\n\n  // set fxChildTunnel if not set already\n  function setFxChildTunnel(address _fxChildTunnel) internal virtual {\n    require(fxChildTunnel == address(0x0), \"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\");\n    fxChildTunnel = _fxChildTunnel;\n  }\n\n  /**\n   * @notice Send bytes message to Child Tunnel\n   * @param message bytes message that will be sent to Child Tunnel\n   * some message examples -\n   *   abi.encode(tokenId);\n   *   abi.encode(tokenId, tokenMetadata);\n   *   abi.encode(messageType, messageData);\n   */\n  function _sendMessageToChild(bytes memory message) internal {\n    fxRoot.sendMessageToChild(fxChildTunnel, message);\n  }\n\n  function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\n    ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();\n\n    bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\n    uint256 blockNumber = payload.getBlockNumber();\n    // checking if exit has already been processed\n    // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\n    bytes32 exitHash = keccak256(\n      abi.encodePacked(\n        blockNumber,\n        // first 2 nibbles are dropped while generating nibble array\n        // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\n        // so converting to nibble array and then hashing it\n        MerklePatriciaProof._getNibbleArray(branchMaskBytes),\n        payload.getReceiptLogIndex()\n      )\n    );\n    require(processedExits[exitHash] == false, \"FxRootTunnel: EXIT_ALREADY_PROCESSED\");\n    processedExits[exitHash] = true;\n\n    ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\n    ExitPayloadReader.Log memory log = receipt.getLog();\n\n    // check child tunnel\n    require(fxChildTunnel == log.getEmitter(), \"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\");\n\n    bytes32 receiptRoot = payload.getReceiptRoot();\n    // verify receipt inclusion\n    require(\n      MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),\n      \"FxRootTunnel: INVALID_RECEIPT_PROOF\"\n    );\n\n    // verify checkpoint inclusion\n    _checkBlockMembershipInCheckpoint(\n      blockNumber,\n      payload.getBlockTime(),\n      payload.getTxRoot(),\n      receiptRoot,\n      payload.getHeaderNumber(),\n      payload.getBlockProof()\n    );\n\n    ExitPayloadReader.LogTopics memory topics = log.getTopics();\n\n    require(\n      bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\n      \"FxRootTunnel: INVALID_SIGNATURE\"\n    );\n\n    // received message data\n    bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\n    return message;\n  }\n\n  function _checkBlockMembershipInCheckpoint(\n    uint256 blockNumber,\n    uint256 blockTime,\n    bytes32 txRoot,\n    bytes32 receiptRoot,\n    uint256 headerNumber,\n    bytes memory blockProof\n  ) private view returns (uint256) {\n    (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);\n\n    require(\n      keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\n        blockNumber - startBlock,\n        headerRoot,\n        blockProof\n      ),\n      \"FxRootTunnel: INVALID_HEADER\"\n    );\n    return createdAt;\n  }\n\n  /**\n   * @notice receive message from  L2 to L1, validated by proof\n   * @dev This function verifies if the transaction actually happened on child chain\n   *\n   * @param inputData RLP encoded data of the reference tx containing following list of fields\n   *  0 - headerNumber - Checkpoint header block number containing the reference tx\n   *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\n   *  2 - blockNumber - Block number containing the reference tx on child chain\n   *  3 - blockTime - Reference tx block time\n   *  4 - txRoot - Transactions root of block\n   *  5 - receiptRoot - Receipts root of block\n   *  6 - receipt - Receipt of the reference transaction\n   *  7 - receiptProof - Merkle proof of the reference receipt\n   *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\n   *  9 - receiptLogIndex - Log Index to read from the receipt\n   */\n  function receiveMessage(bytes memory inputData) public virtual {\n    bytes memory message = _validateAndExtractMessage(inputData);\n    _processMessageFromChild(message);\n  }\n\n  /**\n   * @notice Process message received from Child Tunnel\n   * @dev function needs to be implemented to handle message as per requirement\n   * This is called by onStateReceive function.\n   * Since it is called via a system call, any event will not be emitted during its execution.\n   * @param message bytes message that was sent from Child Tunnel\n   */\n  function _processMessageFromChild(bytes memory message) internal virtual;\n}\n"
    },
    "contracts/messaging/connectors/polygon/lib/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/fx-portal/contracts/blob/main/contracts/lib/RLPReader.sol\npragma solidity 0.8.17;\n\nlibrary RLPReader {\n  uint8 constant STRING_SHORT_START = 0x80;\n  uint8 constant STRING_LONG_START = 0xb8;\n  uint8 constant LIST_SHORT_START = 0xc0;\n  uint8 constant LIST_LONG_START = 0xf8;\n  uint8 constant WORD_SIZE = 32;\n\n  struct RLPItem {\n    uint256 len;\n    uint256 memPtr;\n  }\n\n  struct Iterator {\n    RLPItem item; // Item that's being iterated over.\n    uint256 nextPtr; // Position of the next item in the list.\n  }\n\n  /*\n   * @dev Returns the next element in the iteration. Reverts if it has not next element.\n   * @param self The iterator.\n   * @return The next element in the iteration.\n   */\n  function next(Iterator memory self) internal pure returns (RLPItem memory) {\n    require(hasNext(self));\n\n    uint256 ptr = self.nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    self.nextPtr = ptr + itemLength;\n\n    return RLPItem(itemLength, ptr);\n  }\n\n  /*\n   * @dev Returns true if the iteration has more elements.\n   * @param self The iterator.\n   * @return true if the iteration has more elements.\n   */\n  function hasNext(Iterator memory self) internal pure returns (bool) {\n    RLPItem memory item = self.item;\n    return self.nextPtr < item.memPtr + item.len;\n  }\n\n  /*\n   * @param item RLP encoded bytes\n   */\n  function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n    uint256 memPtr;\n    assembly {\n      memPtr := add(item, 0x20)\n    }\n\n    return RLPItem(item.length, memPtr);\n  }\n\n  /*\n   * @dev Create an iterator. Reverts if item is not a list.\n   * @param self The RLP item.\n   * @return An 'Iterator' over the item.\n   */\n  function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n    require(isList(self));\n\n    uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n    return Iterator(self, ptr);\n  }\n\n  /*\n   * @param item RLP encoded bytes\n   */\n  function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n    return item.len;\n  }\n\n  /*\n   * @param item RLP encoded bytes\n   */\n  function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n    return item.len - _payloadOffset(item.memPtr);\n  }\n\n  /*\n   * @param item RLP encoded list in bytes\n   */\n  function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n    require(isList(item));\n\n    uint256 items = numItems(item);\n    RLPItem[] memory result = new RLPItem[](items);\n\n    uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n    uint256 dataLen;\n    for (uint256 i = 0; i < items; ) {\n      dataLen = _itemLength(memPtr);\n      result[i] = RLPItem(dataLen, memPtr);\n      memPtr = memPtr + dataLen;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    return result;\n  }\n\n  // @return indicator whether encoded payload is a list. negate this function call for isData.\n  function isList(RLPItem memory item) internal pure returns (bool) {\n    if (item.len == 0) return false;\n\n    uint8 byte0;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < LIST_SHORT_START) return false;\n    return true;\n  }\n\n  /*\n   * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n   * @return keccak256 hash of RLP encoded bytes.\n   */\n  function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n    uint256 ptr = item.memPtr;\n    uint256 len = item.len;\n    bytes32 result;\n    assembly {\n      result := keccak256(ptr, len)\n    }\n    return result;\n  }\n\n  function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n    uint256 offset = _payloadOffset(item.memPtr);\n    uint256 memPtr = item.memPtr + offset;\n    uint256 len = item.len - offset; // data length\n    return (memPtr, len);\n  }\n\n  /*\n   * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n   * @return keccak256 hash of the item payload.\n   */\n  function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\n    bytes32 result;\n    assembly {\n      result := keccak256(memPtr, len)\n    }\n    return result;\n  }\n\n  /** RLPItem conversions into data types **/\n\n  // @returns raw rlp encoding in bytes\n  function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n    bytes memory result = new bytes(item.len);\n    if (result.length == 0) return result;\n\n    uint256 ptr;\n    assembly {\n      ptr := add(0x20, result)\n    }\n\n    copy(item.memPtr, ptr, item.len);\n    return result;\n  }\n\n  // any non-zero byte is considered true\n  function toBoolean(RLPItem memory item) internal pure returns (bool) {\n    require(item.len == 1);\n    uint256 result;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      result := byte(0, mload(memPtr))\n    }\n\n    return result == 0 ? false : true;\n  }\n\n  function toAddress(RLPItem memory item) internal pure returns (address) {\n    // 1 byte for the length prefix\n    require(item.len == 21);\n\n    return address(uint160(toUint(item)));\n  }\n\n  function toUint(RLPItem memory item) internal pure returns (uint256) {\n    require(item.len > 0 && item.len < 33 + 1);\n\n    uint256 offset = _payloadOffset(item.memPtr);\n    uint256 len = item.len - offset;\n\n    uint256 result;\n    uint256 memPtr = item.memPtr + offset;\n    assembly {\n      result := mload(memPtr)\n\n      // shfit to the correct location if neccesary\n      if lt(len, 32) {\n        result := div(result, exp(256, sub(32, len)))\n      }\n    }\n\n    return result;\n  }\n\n  // enforces 32 byte length\n  function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n    // one byte prefix\n    require(item.len == 33);\n\n    uint256 result;\n    uint256 memPtr = item.memPtr + 1;\n    assembly {\n      result := mload(memPtr)\n    }\n\n    return result;\n  }\n\n  function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n    require(item.len > 0);\n\n    uint256 offset = _payloadOffset(item.memPtr);\n    uint256 len = item.len - offset; // data length\n    bytes memory result = new bytes(len);\n\n    uint256 destPtr;\n    assembly {\n      destPtr := add(0x20, result)\n    }\n\n    copy(item.memPtr + offset, destPtr, len);\n    return result;\n  }\n\n  /*\n   * Private Helpers\n   */\n\n  // @return number of payload items inside an encoded list.\n  function numItems(RLPItem memory item) private pure returns (uint256) {\n    if (item.len == 0) return 0;\n\n    uint256 count = 0;\n    uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n    uint256 endPtr = item.memPtr + item.len;\n    while (currPtr < endPtr) {\n      currPtr = currPtr + _itemLength(currPtr); // skip over an item\n      count++;\n    }\n\n    return count;\n  }\n\n  // @return entire rlp item byte length\n  function _itemLength(uint256 memPtr) private pure returns (uint256) {\n    uint256 itemLen;\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) itemLen = 1;\n    else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n    else if (byte0 < LIST_SHORT_START) {\n      assembly {\n        let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n        memPtr := add(memPtr, 1) // skip over the first byte\n        /* 32 byte word size */\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    } else if (byte0 < LIST_LONG_START) {\n      itemLen = byte0 - LIST_SHORT_START + 1;\n    } else {\n      assembly {\n        let byteLen := sub(byte0, 0xf7)\n        memPtr := add(memPtr, 1)\n\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    }\n\n    return itemLen;\n  }\n\n  // @return number of bytes until the data\n  function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) return 0;\n    else if (byte0 < STRING_LONG_START || (byte0 > LIST_SHORT_START - 1 && byte0 < LIST_LONG_START)) return 1;\n    else if (byte0 < LIST_SHORT_START)\n      // being explicit\n      return byte0 - (STRING_LONG_START - 1) + 1;\n    else return byte0 - (LIST_LONG_START - 1) + 1;\n  }\n\n  /*\n   * @param src Pointer to source\n   * @param dest Pointer to destination\n   * @param len Amount of memory to copy from the source\n   */\n  function copy(\n    uint256 src,\n    uint256 dest,\n    uint256 len\n  ) private pure {\n    if (len == 0) return;\n\n    // copy as many word sizes as possible\n    for (; len > WORD_SIZE - 1; len -= WORD_SIZE) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n\n      src += WORD_SIZE;\n      dest += WORD_SIZE;\n    }\n\n    if (len == 0) return;\n\n    // left over bytes. Mask is used to remove unwanted bytes from the word\n    uint256 mask = 256**(WORD_SIZE - len) - 1;\n\n    assembly {\n      let srcpart := and(mload(src), not(mask)) // zero out src\n      let destpart := and(mload(dest), mask) // retrieve the bytes\n      mstore(dest, or(destpart, srcpart))\n    }\n  }\n}\n"
    },
    "contracts/messaging/connectors/polygon/lib/MerklePatriciaProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/fx-portal/contracts/blob/main/contracts/lib/MerklePatriciaProof.sol\npragma solidity 0.8.17;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary MerklePatriciaProof {\n  /*\n   * @dev Verifies a merkle patricia proof.\n   * @param value The terminating value in the trie.\n   * @param encodedPath The path in the trie leading to value.\n   * @param rlpParentNodes The rlp encoded stack of nodes.\n   * @param root The root hash of the trie.\n   * @return The boolean validity of the proof.\n   */\n  function verify(\n    bytes memory value,\n    bytes memory encodedPath,\n    bytes memory rlpParentNodes,\n    bytes32 root\n  ) internal pure returns (bool) {\n    RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\n    RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\n\n    bytes memory currentNode;\n    RLPReader.RLPItem[] memory currentNodeList;\n\n    bytes32 nodeKey = root;\n    uint256 pathPtr = 0;\n\n    bytes memory path = _getNibbleArray(encodedPath);\n    if (path.length == 0) {\n      return false;\n    }\n\n    uint256 len = parentNodes.length;\n    for (uint256 i = 0; i < len; ) {\n      if (pathPtr > path.length) {\n        return false;\n      }\n\n      currentNode = RLPReader.toRlpBytes(parentNodes[i]);\n      if (nodeKey != keccak256(currentNode)) {\n        return false;\n      }\n      currentNodeList = RLPReader.toList(parentNodes[i]);\n\n      if (currentNodeList.length == 17) {\n        if (pathPtr == path.length) {\n          if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n\n        uint8 nextPathNibble = uint8(path[pathPtr]);\n        if (nextPathNibble > 16) {\n          return false;\n        }\n        nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\n        pathPtr += 1;\n      } else if (currentNodeList.length == 2) {\n        uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\n        if (pathPtr + traversed == path.length) {\n          //leaf node\n          if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n\n        //extension node\n        if (traversed == 0) {\n          return false;\n        }\n\n        pathPtr += traversed;\n        nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\n      } else {\n        return false;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _nibblesToTraverse(\n    bytes memory encodedPartialPath,\n    bytes memory path,\n    uint256 pathPtr\n  ) private pure returns (uint256) {\n    uint256 len = 0;\n    // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n    // and slicedPath have elements that are each one hex character (1 nibble)\n    bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n    bytes memory slicedPath = new bytes(partialPath.length);\n\n    // pathPtr counts nibbles in path\n    // partialPath.length is a number of nibbles\n    uint256 _len = pathPtr + partialPath.length;\n    for (uint256 i = pathPtr; i < _len; ) {\n      bytes1 pathNibble = path[i];\n      slicedPath[i - pathPtr] = pathNibble;\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    if (keccak256(partialPath) == keccak256(slicedPath)) {\n      len = partialPath.length;\n    } else {\n      len = 0;\n    }\n    return len;\n  }\n\n  // bytes b must be hp encoded\n  function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\n    bytes memory nibbles = \"\";\n    if (b.length > 0) {\n      uint8 offset;\n      uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\n      if (hpNibble == 1 || hpNibble == 3) {\n        nibbles = new bytes(b.length * 2 - 1);\n        bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\n        nibbles[0] = oddNibble;\n        offset = 1;\n      } else {\n        nibbles = new bytes(b.length * 2 - 2);\n        offset = 0;\n      }\n\n      uint256 len = nibbles.length;\n      for (uint256 i = offset; i < len; ) {\n        nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\n\n        unchecked {\n          ++i;\n        }\n      }\n    }\n    return nibbles;\n  }\n\n  function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\n    return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\n  }\n}\n"
    },
    "contracts/messaging/connectors/polygon/lib/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/fx-portal/contracts/blob/main/contracts/lib/Merkle.sol\npragma solidity 0.8.17;\n\nlibrary Merkle {\n  function checkMembership(\n    bytes32 leaf,\n    uint256 index,\n    bytes32 rootHash,\n    bytes memory proof\n  ) internal pure returns (bool) {\n    require(proof.length % 32 == 0, \"Invalid proof length\");\n    uint256 proofHeight = proof.length / 32;\n    // Proof of size n means, height of the tree is n+1.\n    // In a tree of height n+1, max #leafs possible is 2 ^ n\n    require(index < 2**proofHeight, \"Leaf index is too big\");\n\n    bytes32 proofElement;\n    bytes32 computedHash = leaf;\n    uint256 len = proof.length + 1;\n    for (uint256 i = 32; i < len; ) {\n      assembly {\n        proofElement := mload(add(proof, i))\n      }\n\n      if (index % 2 == 0) {\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n      } else {\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n      }\n\n      index = index / 2;\n\n      unchecked {\n        i += 32;\n      }\n    }\n    return computedHash == rootHash;\n  }\n}\n"
    },
    "contracts/messaging/connectors/polygon/lib/ExitPayloadReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/fx-portal/contracts/blob/main/contracts/lib/ExitPayloadReader.sol\npragma solidity 0.8.17;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary ExitPayloadReader {\n  using RLPReader for bytes;\n  using RLPReader for RLPReader.RLPItem;\n\n  uint8 constant WORD_SIZE = 32;\n\n  struct ExitPayload {\n    RLPReader.RLPItem[] data;\n  }\n\n  struct Receipt {\n    RLPReader.RLPItem[] data;\n    bytes raw;\n    uint256 logIndex;\n  }\n\n  struct Log {\n    RLPReader.RLPItem data;\n    RLPReader.RLPItem[] list;\n  }\n\n  struct LogTopics {\n    RLPReader.RLPItem[] data;\n  }\n\n  // copy paste of private copy() from RLPReader to avoid changing of existing contracts\n  function copy(\n    uint256 src,\n    uint256 dest,\n    uint256 len\n  ) private pure {\n    if (len == 0) return;\n\n    // copy as many word sizes as possible\n    for (; len > WORD_SIZE - 1; len -= WORD_SIZE) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n\n      src += WORD_SIZE;\n      dest += WORD_SIZE;\n    }\n\n    if (len == 0) return;\n\n    // left over bytes. Mask is used to remove unwanted bytes from the word\n    uint256 mask = 256**(WORD_SIZE - len) - 1;\n    assembly {\n      let srcpart := and(mload(src), not(mask)) // zero out src\n      let destpart := and(mload(dest), mask) // retrieve the bytes\n      mstore(dest, or(destpart, srcpart))\n    }\n  }\n\n  function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {\n    RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\n\n    return ExitPayload(payloadData);\n  }\n\n  function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {\n    return payload.data[0].toUint();\n  }\n\n  function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n    return payload.data[1].toBytes();\n  }\n\n  function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {\n    return payload.data[2].toUint();\n  }\n\n  function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {\n    return payload.data[3].toUint();\n  }\n\n  function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n    return bytes32(payload.data[4].toUint());\n  }\n\n  function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n    return bytes32(payload.data[5].toUint());\n  }\n\n  function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {\n    receipt.raw = payload.data[6].toBytes();\n    RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\n\n    if (receiptItem.isList()) {\n      // legacy tx\n      receipt.data = receiptItem.toList();\n    } else {\n      // pop first byte before parsting receipt\n      bytes memory typedBytes = receipt.raw;\n      bytes memory result = new bytes(typedBytes.length - 1);\n      uint256 srcPtr;\n      uint256 destPtr;\n      assembly {\n        srcPtr := add(33, typedBytes)\n        destPtr := add(0x20, result)\n      }\n\n      copy(srcPtr, destPtr, result.length);\n      receipt.data = result.toRlpItem().toList();\n    }\n\n    receipt.logIndex = getReceiptLogIndex(payload);\n    return receipt;\n  }\n\n  function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n    return payload.data[7].toBytes();\n  }\n\n  function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {\n    return payload.data[8].toBytes();\n  }\n\n  function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {\n    return payload.data[8].toUint();\n  }\n\n  function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {\n    return payload.data[9].toUint();\n  }\n\n  // Receipt methods\n  function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {\n    return receipt.raw;\n  }\n\n  function getLog(Receipt memory receipt) internal pure returns (Log memory) {\n    RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\n    return Log(logData, logData.toList());\n  }\n\n  // Log methods\n  function getEmitter(Log memory log) internal pure returns (address) {\n    return RLPReader.toAddress(log.list[0]);\n  }\n\n  function getTopics(Log memory log) internal pure returns (LogTopics memory) {\n    return LogTopics(log.list[1].toList());\n  }\n\n  function getData(Log memory log) internal pure returns (bytes memory) {\n    return log.list[2].toBytes();\n  }\n\n  function toRlpBytes(Log memory log) internal pure returns (bytes memory) {\n    return log.data.toRlpBytes();\n  }\n\n  // LogTopics methods\n  function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {\n    return topics.data[index];\n  }\n}\n"
    },
    "contracts/messaging/connectors/multichain/MultichainHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\n\nimport {HubConnector, Connector} from \"../HubConnector.sol\";\n\nimport {BaseMultichain} from \"./BaseMultichain.sol\";\n\ncontract MultichainHubConnector is HubConnector, BaseMultichain {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _mirrorChainId,\n    uint256 _gasCap\n  )\n    HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector)\n    BaseMultichain(_amb, _mirrorChainId, _gasCap)\n  {}\n\n  // ============ Private fns ============\n  /**\n   * @dev Handles an incoming `outboundRoot`\n   */\n  function _processMessage(bytes memory _data) internal override(Connector, BaseMultichain) {\n    // enforce this came from connector on l2\n    require(_verifySender(mirrorConnector), \"!l2Connector\");\n    // get the data (should be the outbound root)\n    require(_data.length == 32, \"!length\");\n    // set the outbound root for BSC domain\n    IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, bytes32(_data));\n  }\n\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    _sendMessage(AMB, mirrorConnector, _data, _encodedData);\n  }\n\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _verifySender(AMB, _expected);\n  }\n}\n"
    },
    "contracts/messaging/connectors/multichain/BaseMultichain.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Multichain} from \"../../interfaces/ambs/Multichain.sol\";\n\nimport {GasCap} from \"../GasCap.sol\";\n\nabstract contract BaseMultichain is GasCap {\n  // ============ Internal Storage ============\n  address internal immutable EXECUTOR; // Is != amb, used only to retrieve sender context\n\n  // Mirror chain id\n  uint256 internal immutable MIRROR_CHAIN_ID;\n\n  // ============ Constructor ============\n  constructor(\n    address _amb,\n    uint256 _mirrorChainId,\n    uint256 _gasCap // max fee on destination chain\n  ) GasCap(_gasCap) {\n    // sanity checks\n    require(_mirrorChainId != 0, \"!mirrorChainId\");\n\n    // set immutable propertioes\n    EXECUTOR = Multichain(_amb).executor();\n    require(EXECUTOR != address(0), \"!executor\");\n    MIRROR_CHAIN_ID = _mirrorChainId;\n  }\n\n  // ============ Public Fns ============\n  function anyExecute(bytes memory _data) external returns (bool success, bytes memory result) {\n    _processMessage(_data);\n  }\n\n  // ============ Private fns ============\n  /**\n   * @notice This function is used by the AMBs to handle incoming messages. Should store the latest\n   * root generated on the l2 domain.\n   */\n  function _processMessage(bytes memory _data) internal virtual;\n\n  /**\n   * @dev Sends `outboundRoot` to root manager on the mirror chain\n   */\n  function _sendMessage(\n    address _amb,\n    address _mirrorConnector,\n    bytes memory _data,\n    bytes memory _encodedData\n  ) internal {\n    // Should always be sending a merkle root\n    require(_data.length == 32, \"!data length\");\n\n    // Should not include any gas info\n    require(_encodedData.length == 0, \"!data length\");\n\n    // Get the max fee supplied\n    uint256 supplied = _getGas(msg.value); // fee paid on origin chain, up to cap\n    // NOTE: fee will always be <= msg.value\n\n    // Get the min fees\n    uint256 required = Multichain(_amb).calcSrcFees(\n      \"\", // app id\n      MIRROR_CHAIN_ID, // destination chain\n      32 // data length: selector + root\n    );\n    // Should have at least the min fees\n    require(required < supplied + 1, \"!fees\");\n\n    Multichain(_amb).anyCall{value: supplied}(\n      _mirrorConnector, // Target contract on destination\n      _data, // Call data for interaction\n      address(0), // fallback address on origin chain\n      MIRROR_CHAIN_ID,\n      2 // fees paid on source chain\n    );\n  }\n\n  function _verifySender(address _amb, address _expected) internal view returns (bool) {\n    require(msg.sender == _amb, \"!bridge\");\n\n    (address from, uint256 fromChainId, ) = Multichain(EXECUTOR).context();\n    return from == _expected && fromChainId == MIRROR_CHAIN_ID;\n  }\n}\n"
    },
    "contracts/messaging/interfaces/ambs/Multichain.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @dev interface to interact with multicall (prev anyswap) anycall proxy\n *     see https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/AnyswapV6CallProxy.sol\n */\ninterface Multichain {\n  function anyCall(\n    address _to,\n    bytes calldata _data,\n    address _fallback,\n    uint256 _toChainID,\n    uint256 _flags\n  ) external payable;\n\n  function context()\n    external\n    view\n    returns (\n      address from,\n      uint256 fromChainID,\n      uint256 nonce\n    );\n\n  function executor() external view returns (address executor);\n\n  function calcSrcFees(\n    string calldata _appID,\n    uint256 _toChainID,\n    uint256 _dataLength\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/messaging/connectors/multichain/MultichainSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {SpokeConnector, ProposedOwnable} from \"../SpokeConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\nimport {BaseMultichain} from \"./BaseMultichain.sol\";\n\ncontract MultichainSpokeConnector is SpokeConnector, BaseMultichain {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager,\n    uint256 _mirrorChainId,\n    uint256 _gasCap\n  )\n    SpokeConnector(\n      _domain,\n      _mirrorDomain,\n      _amb,\n      _rootManager,\n      _mirrorConnector,\n      _processGas,\n      _reserveGas,\n      _delayBlocks,\n      _merkle,\n      _watcherManager\n    )\n    BaseMultichain(_amb, _mirrorChainId, _gasCap)\n  {}\n\n  // ============ Admin fns ============\n\n  /**\n   * @notice Should not be able to renounce ownership\n   */\n  function renounceOwnership() public virtual override(SpokeConnector, ProposedOwnable) onlyOwner {}\n\n  // ============ Private fns ============\n  /**\n   * @dev Handles an incoming `aggregateRoot`\n   * NOTE: Could store latest root sent and prove aggregate root\n   */\n  function _processMessage(bytes memory _data) internal override(Connector, BaseMultichain) {\n    // enforce this came from connector on l1\n    require(_verifySender(mirrorConnector), \"!mirrorConnector\");\n    // sanity check: data length\n    require(_data.length == 32, \"!length\");\n    // set the aggregate root for BSC + access control\n    receiveAggregateRoot(bytes32(_data));\n  }\n\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    _sendMessage(AMB, mirrorConnector, _data, _encodedData);\n  }\n\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _verifySender(AMB, _expected);\n  }\n}\n"
    },
    "contracts/messaging/connectors/mainnet/MainnetSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {IHubConnector} from \"../../interfaces/IHubConnector.sol\";\n\nimport {SpokeConnector} from \"../SpokeConnector.sol\";\n\ncontract MainnetSpokeConnector is SpokeConnector, IHubConnector {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager\n  )\n    SpokeConnector(\n      _domain,\n      _mirrorDomain,\n      _amb,\n      _rootManager,\n      _mirrorConnector,\n      _processGas,\n      _reserveGas,\n      _delayBlocks,\n      _merkle,\n      _watcherManager\n    )\n  {}\n\n  // ============ Public fns ============\n  /**\n   * @notice Sends a message over the amb\n   * @dev This is called by the root manager *only* on mainnet to propagate the aggregate root\n   * @dev Get 'Base constructor arguments given twice' when trying to inherit\n   */\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable onlyRootManager {\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    _sendMessage(_data, bytes(\"\"));\n    emit MessageSent(_data, bytes(\"\"), msg.sender);\n  }\n\n  // ============ Private fns ============\n  /**\n   * @dev Asserts the sender of a cross domain message. On mainnet all senders should be this\n   */\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return msg.sender == _expected;\n  }\n\n  /**\n   * @dev There are two times messages get \"sent\" from this connector:\n   * 1. `RootManager` calls `sendMessage` during `propagate`\n   * 2. Relayers call `send`, which calls `_sendMessage` to set the outbound root\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    // get the data (should be either the outbound or aggregate root, depending on sender)\n    require(_data.length == 32, \"!length\");\n    if (msg.sender == ROOT_MANAGER) {\n      // update the aggregate root\n      receiveAggregateRoot(bytes32(_data));\n      return;\n    }\n    // otherwise is relayer, update the outbound root on the root manager\n    IRootManager(ROOT_MANAGER).aggregate(DOMAIN, bytes32(_data));\n  }\n\n  /**\n   * @dev The `RootManager` calls `.sendMessage` on all connectors, there is nothing on mainnet\n   * that would be processing \"inbound messages\", so do nothing in this function\n   */\n  function _processMessage(bytes memory _data) internal override {}\n}\n"
    },
    "contracts/messaging/interfaces/IHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IConnector} from \"./IConnector.sol\";\n\ninterface IHubConnector is IConnector {\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable;\n}\n"
    },
    "contracts/shared/upgrade/UpgradeBeaconController.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// ============ Internal Imports ============\nimport {ProposedOwnable} from \"../ProposedOwnable.sol\";\n\nimport {UpgradeBeacon} from \"./UpgradeBeacon.sol\";\n\n// ============ External Imports ============\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradeBeaconController\n * @notice Set as the controller of UpgradeBeacon contract(s),\n * capable of changing their stored implementation address.\n * @dev This implementation is a minimal version inspired by 0age's implementation:\n * https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/upgradeability/DharmaUpgradeBeaconController.sol\n *\n * @dev Do *NOT* remove ownership unless all UpgradeBeacons registered with this controller\n * are willing to lose upgradeability.\n */\ncontract UpgradeBeaconController is ProposedOwnable {\n  // ============ Events ============\n\n  event BeaconUpgraded(address indexed beacon, address implementation);\n\n  // ============ Constructor ============\n  constructor() {\n    _setOwner(msg.sender);\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Modify the implementation stored in the UpgradeBeacon,\n   * which will upgrade the implementation used by all\n   * Proxy contracts using that UpgradeBeacon\n   * @param _beacon Address of the UpgradeBeacon which will be updated\n   * @param _implementation Address of the Implementation contract to upgrade the Beacon to\n   */\n  function upgrade(address _beacon, address _implementation) external onlyOwner {\n    // Require that the beacon is a contract\n    require(Address.isContract(_beacon), \"beacon !contract\");\n    // Call into beacon and supply address of new implementation to update it.\n    (bool _success, ) = _beacon.call(abi.encode(_implementation));\n    // Revert with message on failure (i.e. if the beacon is somehow incorrect).\n    if (!_success) {\n      assembly {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n    emit BeaconUpgraded(_beacon, _implementation);\n  }\n}\n"
    },
    "contracts/shared/upgrade/UpgradeBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// ============ External Imports ============\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradeBeacon\n * @notice Stores the address of an implementation contract\n * and allows a controller to upgrade the implementation address\n * @dev This implementation combines the gas savings of having no function selectors\n * found in 0age's implementation:\n * https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/proxies/smart-wallet/UpgradeBeaconProxyV1.sol\n * With the added niceties of a safety check that each implementation is a contract\n * and an Upgrade event emitted each time the implementation is changed\n * found in OpenZeppelin's implementation:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol\n */\ncontract UpgradeBeacon {\n  // ============ Immutables ============\n\n  // The controller is capable of modifying the implementation address\n  address private immutable controller;\n\n  // ============ Private Storage Variables ============\n\n  // The implementation address is held in storage slot zero.\n  address private implementation;\n\n  // ============ Events ============\n\n  // Upgrade event is emitted each time the implementation address is set\n  // (including deployment)\n  event Upgrade(address indexed implementation);\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Validate the initial implementation and store it.\n   * Store the controller immutably.\n   * @param _initialImplementation Address of the initial implementation contract\n   * @param _controller Address of the controller who can upgrade the implementation\n   */\n  constructor(address _initialImplementation, address _controller) payable {\n    _setImplementation(_initialImplementation);\n    controller = _controller;\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice For all callers except the controller, return the current implementation address.\n   * If called by the Controller, update the implementation address\n   * to the address passed in the calldata.\n   * Note: this requires inline assembly because Solidity fallback functions\n   * do not natively take arguments or return values.\n   */\n  fallback() external payable {\n    if (msg.sender != controller) {\n      // if not called by the controller,\n      // load implementation address from storage slot zero\n      // and return it.\n      assembly {\n        mstore(0, sload(0))\n        return(0, 32)\n      }\n    } else {\n      // if called by the controller,\n      // load new implementation address from the first word of the calldata\n      address _newImplementation;\n      assembly {\n        _newImplementation := calldataload(0)\n      }\n      // set the new implementation\n      _setImplementation(_newImplementation);\n    }\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Perform checks on the new implementation address\n   * then upgrade the stored implementation.\n   * @param _newImplementation Address of the new implementation contract which will replace the old one\n   */\n  function _setImplementation(address _newImplementation) private {\n    // Require that the new implementation is different from the current one\n    require(implementation != _newImplementation, \"!upgrade\");\n    // Require that the new implementation is a contract\n    require(Address.isContract(_newImplementation), \"implementation !contract\");\n    // set the new implementation\n    implementation = _newImplementation;\n    emit Upgrade(_newImplementation);\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/messaging/RootManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {ProposedOwnable} from \"../shared/ProposedOwnable.sol\";\n\nimport {IRootManager} from \"./interfaces/IRootManager.sol\";\nimport {IHubConnector} from \"./interfaces/IHubConnector.sol\";\nimport {QueueLib} from \"./libraries/Queue.sol\";\nimport {DomainIndexer} from \"./libraries/DomainIndexer.sol\";\n\nimport {MerkleTreeManager} from \"./MerkleTreeManager.sol\";\nimport {WatcherClient} from \"./WatcherClient.sol\";\n\n/**\n * @notice This contract exists at cluster hubs, and aggregates all transfer roots from messaging\n * spokes into a single merkle tree. Regularly broadcasts the root of the aggregator tree back out\n * to all the messaging spokes.\n */\ncontract RootManager is ProposedOwnable, IRootManager, WatcherClient, DomainIndexer {\n  // ============ Libraries ============\n\n  using QueueLib for QueueLib.Queue;\n\n  // ============ Events ============\n\n  event DelayBlocksUpdated(uint256 previous, uint256 updated);\n\n  event RootReceived(uint32 domain, bytes32 receivedRoot, uint256 queueIndex);\n\n  event RootsAggregated(bytes32 aggregateRoot, uint256 count, bytes32[] aggregatedMessageRoots);\n\n  event RootPropagated(bytes32 aggregateRoot, uint256 count, bytes32 domainsHash);\n\n  event RootDiscarded(bytes32 fraudulentRoot);\n\n  event ConnectorAdded(uint32 domain, address connector, uint32[] domains, address[] connectors);\n\n  event ConnectorRemoved(uint32 domain, address connector, uint32[] domains, address[] connectors, address caller);\n\n  event PropagateFailed(uint32 domain, address connector);\n\n  // ============ Properties ============\n\n  /**\n   * @notice Maximum number of values to dequeue from the queue in one sitting (one call of `propagate`\n   * or `dequeue`). Used to cap gas requirements.\n   */\n  uint128 public constant DEQUEUE_MAX = 100;\n\n  /**\n   * @notice Number of blocks to delay the processing of a message to allow for watchers to verify\n   * the validity and pause if necessary.\n   */\n  uint256 public delayBlocks;\n\n  /**\n   * @notice Queue used for management of verification for inbound roots from spoke chains. Once\n   * the verification period elapses, the inbound messages can be aggregated into the merkle tree\n   * for propagation to spoke chains.\n   * @dev Watchers should be able to watch this queue for fraudulent messages and pause this contract\n   * if fraud is detected.\n   */\n  QueueLib.Queue public pendingInboundRoots;\n\n  /**\n   * @notice The last aggregate root we propagated to spoke chains. Used to prevent sending redundant\n   * aggregate roots in `propagate`.\n   */\n  bytes32 public lastPropagatedRoot;\n\n  /**\n   * @notice MerkleTreeManager contract instance. Will hold the active tree of aggregated inbound roots.\n   * The root of this tree will be distributed crosschain to all spoke domains.\n   */\n  MerkleTreeManager public immutable MERKLE;\n\n  // ============ Modifiers ============\n\n  modifier onlyConnector(uint32 _domain) {\n    require(getConnectorForDomain(_domain) == msg.sender, \"!connector\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new RootManager instance.\n   * @param _delayBlocks The delay for the validation period for incoming messages in blocks.\n   * @param _merkle The address of the MerkleTreeManager on this domain.\n   * @param _watcherManager The address of the WatcherManager on this domain.\n   */\n  constructor(\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager\n  ) ProposedOwnable() WatcherClient(_watcherManager) {\n    _setOwner(msg.sender);\n\n    require(_merkle != address(0), \"!zero merkle\");\n    MERKLE = MerkleTreeManager(_merkle);\n\n    delayBlocks = _delayBlocks;\n\n    // Initialize pending inbound root queue.\n    pendingInboundRoots.initialize();\n  }\n\n  // ================ Getters ================\n\n  function getPendingInboundRootsCount() public view returns (uint256) {\n    return pendingInboundRoots.length();\n  }\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Set the `delayBlocks`, the period in blocks over which an incoming message\n   * is verified.\n   */\n  function setDelayBlocks(uint256 _delayBlocks) public onlyOwner {\n    require(_delayBlocks != delayBlocks, \"!delayBlocks\");\n    emit DelayBlocksUpdated(_delayBlocks, delayBlocks);\n    delayBlocks = _delayBlocks;\n  }\n\n  /**\n   * @notice Add a new supported domain and corresponding hub connector to the system. This new domain\n   * will receive the propagated aggregate root.\n   * @dev Only owner can add a new connector. Address should be the connector on L1.\n   * @dev Cannot add address(0) to avoid duplicated domain in array and reduce gas fee while propagating.\n   *\n   * @param _domain The target spoke domain of the given connector.\n   * @param _connector Address of the hub connector.\n   */\n  function addConnector(uint32 _domain, address _connector) external onlyOwner {\n    addDomain(_domain, _connector);\n    emit ConnectorAdded(_domain, _connector, domains, connectors);\n  }\n\n  /**\n   * @notice Remove support for a connector and respective domain. That connector/domain will no longer\n   * receive updates for the latest aggregate root.\n   * @dev Only watcher can remove a connector.\n   * TODO: Could add a metatx-able `removeConnectorWithSig` if we want to use relayers?\n   *\n   * @param _domain The spoke domain of the target connector we want to remove.\n   */\n  function removeConnector(uint32 _domain) public onlyWatcher {\n    address _connector = removeDomain(_domain);\n    emit ConnectorRemoved(_domain, _connector, domains, connectors, msg.sender);\n  }\n\n  /**\n   * @notice Removes (effectively blocklists) a given (fraudulent) root from the queue of pending\n   * inbound roots.\n   * @dev The given root does NOT have to currently be in the queue. It isn't removed from the queue\n   * directly, but instead is filtered out when dequeuing is done for the sake of aggregation.\n   * @dev Can only be called by the owner when the protocol is paused.\n   *\n   * @param _root The root to be discarded.\n   */\n  function discardRoot(bytes32 _root) public onlyOwner whenPaused {\n    pendingInboundRoots.remove(_root);\n    emit RootDiscarded(_root);\n  }\n\n  /**\n   * @notice Remove ability to renounce ownership\n   * @dev Renounce ownership should be impossible as long as watchers can freely remove connectors\n   * and only the owner can add them back\n   */\n  function renounceOwnership() public virtual override(ProposedOwnable, WatcherClient) onlyOwner {}\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice This is called by relayers to take the current aggregate tree root and propagate it to all\n   * spoke domains (via their respective hub connectors).\n   * @dev Should be called by relayers at a regular interval.\n   *\n   * @param _connectors Array of connectors: should match exactly the array of `connectors` in storage;\n   * used here to reduce gas costs, and keep them static regardless of number of supported domains.\n   * @param _fees Array of fees in native token for an AMB if required\n   * @param _encodedData Array of encodedData: extra params for each AMB if required\n   */\n  function propagate(\n    address[] calldata _connectors,\n    uint256[] calldata _fees,\n    bytes[] memory _encodedData\n  ) external payable whenNotPaused {\n    validateConnectors(_connectors);\n\n    uint256 _numDomains = _connectors.length;\n    // Sanity check: fees and encodedData lengths matches connectors length.\n    require(_fees.length == _numDomains && _encodedData.length == _numDomains, \"invalid lengths\");\n\n    // Dequeue verified roots from the queue and insert into the tree.\n    (bytes32 _aggregateRoot, uint256 _count) = dequeue();\n\n    // Sanity check: make sure we are not propagating a redundant aggregate root.\n    require(_aggregateRoot != lastPropagatedRoot, \"redundant root\");\n    lastPropagatedRoot = _aggregateRoot;\n\n    uint256 sum = msg.value;\n    for (uint32 i; i < _numDomains; ) {\n      // Try to send the message with appropriate encoded data and fees\n      // Continue on revert, but emit an event\n      try\n        IHubConnector(_connectors[i]).sendMessage{value: _fees[i]}(abi.encodePacked(_aggregateRoot), _encodedData[i])\n      {\n        // NOTE: This will ensure there is sufficient msg.value for all fees before calling `sendMessage`\n        // This will revert as soon as there are insufficient fees for call i, even if call n > i has\n        // sufficient budget, this function will revert\n        sum -= _fees[i];\n      } catch {\n        emit PropagateFailed(domains[i], _connectors[i]);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit RootPropagated(_aggregateRoot, _count, domainsHash);\n  }\n\n  /**\n   * @notice Accept an inbound root coming from a given domain's hub connector, enqueuing this incoming\n   * root into the current queue as it awaits the verification period.\n   * @dev The aggregate tree's root, which will include this inbound root, will be propagated to all spoke\n   * domains (via `propagate`) on a regular basis assuming the verification period is surpassed without\n   * dispute.\n   *\n   * @param _domain The source domain of the given root.\n   * @param _inbound The inbound root coming from the given domain.\n   */\n  function aggregate(uint32 _domain, bytes32 _inbound) external whenNotPaused onlyConnector(_domain) {\n    uint128 lastIndex = pendingInboundRoots.enqueue(_inbound);\n    emit RootReceived(_domain, _inbound, lastIndex);\n  }\n\n  /**\n   * @notice Dequeue verified inbound roots and insert them into the aggregator tree.\n   * @dev Will dequeue a fixed maximum amount of roots to prevent out of gas errors. As such, this\n   * method is public and separate from `propagate` so we can curtail an overloaded queue as needed.\n   * @dev Reverts if no verified inbound roots are found.\n   *\n   * @return bytes32 The new aggregate root.\n   * @return uint256 The updated count (number of leaves).\n   */\n  function dequeue() public whenNotPaused returns (bytes32, uint256) {\n    // Get all of the verified roots from the queue.\n    bytes32[] memory _verifiedInboundRoots = pendingInboundRoots.dequeueVerified(delayBlocks, DEQUEUE_MAX);\n\n    // If there's nothing dequeued, just return the root and count.\n    if (_verifiedInboundRoots.length == 0) {\n      return MERKLE.rootAndCount();\n    }\n\n    // Insert the leaves into the aggregator tree (method will also calculate and return the current\n    // aggregate root and count).\n    (bytes32 _aggregateRoot, uint256 _count) = MERKLE.insert(_verifiedInboundRoots);\n\n    emit RootsAggregated(_aggregateRoot, _count, _verifiedInboundRoots);\n\n    return (_aggregateRoot, _count);\n  }\n}\n"
    },
    "contracts/messaging/libraries/Queue.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title QueueLib\n * @notice Library containing queue struct and operations for queue used by RootManager and SpokeConnector\n * for handling the verification period. Tracks both message data itself and the block that the message was\n * committed to the queue.\n **/\nlibrary QueueLib {\n  /**\n   * @notice Queue struct\n   * @dev Internally keeps track of the `first` and `last` elements through\n   * indices and a mapping of indices to enqueued elements.\n   **/\n  struct Queue {\n    uint128 first;\n    uint128 last;\n    // Message data (roots) that have been received.\n    mapping(uint256 => bytes32) data;\n    // The block that the message data was committed.\n    mapping(uint256 => uint256) commitBlock;\n    // A reverse mapping of all entries that have been \"removed\" by value; behaves like a blocklist.\n    // NOTE: Removed values can still be pushed to the queue, but will be ignored/skipped when dequeuing.\n    mapping(bytes32 => bool) removed;\n  }\n\n  /**\n   * @notice Initializes the queue\n   * @dev Empty state denoted by queue.first > queue.last. Queue initialized with\n   * queue.first = 1 and queue.last = 0.\n   **/\n  function initialize(Queue storage queue) internal {\n    queue.first = 1;\n    delete queue.last;\n  }\n\n  /**\n   * @notice Enqueues a single new element and records block number that the item was enqueued\n   * (i.e. current block).\n   * @param item New element to be enqueued.\n   * @return last Index of newly enqueued element.\n   **/\n  function enqueue(Queue storage queue, bytes32 item) internal returns (uint128 last) {\n    // Commit block is the block we are committing this item to the queue.\n    uint256 commitBlock = block.number;\n    // Increment `last` position.\n    last = ++queue.last;\n    // Add the item and record block number.\n    queue.data[last] = item;\n    queue.commitBlock[last] = commitBlock;\n  }\n\n  /**\n   * @notice Dequeues element at front of queue if it exists AND it's surpassed the given\n   * verification period (i.e. has been sitting in the queue for enough blocks).\n   * @param queue QueueStorage struct from contract.\n   * @param delay The required delay that must have been surpassed in order to merit dequeuing\n   * the element.\n   * @param max The maximum number of elements we are allowed to dequeue in this call.\n   * @return item Dequeued element IFF delay period has been surpassed; otherwise, empty bytes32.\n   **/\n  function dequeueVerified(\n    Queue storage queue,\n    uint256 delay,\n    uint128 max\n  ) internal returns (bytes32[] memory) {\n    uint128 first = queue.first;\n    uint128 last = queue.last;\n\n    // If queue is empty, short-circuit here.\n    if (last < first) {\n      return new bytes32[](0);\n    }\n\n    // Input sanity checks.\n    require(first != 0, \"queue !init'd\");\n    require(max > 0, \"!acceptable max\");\n\n    {\n      // If we would otherwise be searching beyond the maximum amount we are allowed to dequeue in this\n      // call, reduce `last` to artificially shrink the available queue within the scope of this method.\n      uint128 highestAllowed = first + max - 1;\n      if (last > highestAllowed) {\n        last = highestAllowed;\n      }\n    }\n\n    // Commit block must be below this block to be considered verified.\n    // NOTE: It's assumed that block number is a higher value than delay (i.e. delay is reasonable).\n    uint256 highestAcceptableCommitBlock = block.number - delay;\n\n    // To determine the last item index in the queue we want to return, iterate backwards until we\n    // find a `commitBlock` that has surpassed the delay period.\n    // TODO: The most efficient way to determine the split index here should be using a binary search.\n    bool containsVerified;\n    // NOTE: `first <= last` rephrased here to `!(first > last)` as it's a cheaper condition.\n    while (!(first > last)) {\n      uint256 commitBlock = queue.commitBlock[last];\n      // NOTE: Same as `commitBlock <= highestAcceptableCommitBlock`.\n      if (!(commitBlock > highestAcceptableCommitBlock)) {\n        containsVerified = true;\n        break;\n      }\n      unchecked {\n        --last;\n      }\n    }\n    // IFF no verified items were found, then we can return an empty array.\n    if (!containsVerified) {\n      return new bytes32[](0);\n    }\n\n    bytes32[] memory items = new bytes32[](last + 1 - first);\n    uint256 index; // Cursor for index in the batch of `items`.\n    uint256 removedCount; // If any items have been removed, we filter them here.\n    // NOTE: `first <= last` rephrased here to `!(first > last)` as it's a cheaper condition.\n    while (!(first > last)) {\n      bytes32 item = queue.data[first];\n      // Check to see if the item has been removed before appending it to the array.\n      if (!queue.removed[item]) {\n        items[index] = item;\n        unchecked {\n          ++index;\n        }\n      } else {\n        // The item was removed. We do NOT increment the index (we will re-use this position).\n        unchecked {\n          ++removedCount;\n        }\n      }\n\n      // Delete the item and the commitBlock.\n      // NOTE: We do NOT delete the entry from `queue.removed`, as it's a reverse lookup and we want to\n      // block that value permanently (e.g. if there's multiple of the same bad value in the queue).\n      delete queue.data[first];\n      delete queue.commitBlock[first];\n\n      unchecked {\n        ++first;\n      }\n    }\n\n    // Update the value for `first` in our queue object since we've dequeued a number of elements.\n    queue.first = first;\n\n    if (removedCount == 0) {\n      return items;\n    } else {\n      // If some items were removed, there will be a number of trailing 0 values we need to truncate\n      // from the array. Create a new array with all of the items up until these empty values.\n      bytes32[] memory amendedItems = new bytes32[](index); // The last `index` is the new length.\n      for (uint256 i; i < index; ) {\n        amendedItems[i] = items[i];\n        unchecked {\n          ++i;\n        }\n      }\n      return amendedItems;\n    }\n  }\n\n  /**\n   * @notice Sets a certain value to be ignored (skipped) when dequeuing.\n   */\n  function remove(Queue storage queue, bytes32 item) internal {\n    require(!queue.removed[item], \"already removed\");\n    queue.removed[item] = true;\n  }\n\n  /**\n   * @notice Check whether the queue is empty.\n   * @param queue QueueStorage struct from contract.\n   * @return bool True if queue is empty and false if otherwise.\n   */\n  function isEmpty(Queue storage queue) internal view returns (bool) {\n    return queue.last < queue.first;\n  }\n\n  /**\n   * @notice Returns number of elements in queue.\n   * @param queue QueueStorage struct from contract.\n   */\n  function length(Queue storage queue) internal view returns (uint256) {\n    uint128 last = queue.last;\n    uint128 first = queue.first;\n    // Cannot underflow unless state is corrupted.\n    return _length(last, first);\n  }\n\n  /**\n   * @notice Returns number of elements between `last` and `first` (used internally).\n   * @param last The last element index.\n   * @param first The first element index.\n   */\n  function _length(uint128 last, uint128 first) internal pure returns (uint256) {\n    return uint256(last + 1 - first);\n  }\n}\n"
    },
    "contracts/messaging/libraries/DomainIndexer.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice This abstract contract was written to ensure domain and connector mutex is scalable for the\n * purposes of messaging layer operations. In particular, it aims to reduce gas costs to be relatively\n * static regardless of the number of domains kept in storage by enabling callers of `RootManager.propagate`\n * to supply the `domains` and `connectors` arrays as params, and check the hashes of those params against\n * those we keep in storage.\n */\nabstract contract DomainIndexer {\n  // ============ Events ============\n\n  event DomainAdded(uint32 domain, address connector);\n  event DomainRemoved(uint32 domain);\n\n  // ============ Properties ============\n\n  /**\n   * @notice The absolute maximum number of domains that we should support. Domain and connector arrays\n   * are naturally unbounded, but the gas cost of reading these arrays in `updateHashes()` is bounded by\n   * the block's gas limit.\n   *\n   * If we want to set a hard ceiling for gas costs for the `updateHashes()` method at approx. 500K gas,\n   * with an average SLOAD cost of 900 gas per domain (1 uint32, 1 address):\n   *       500K / 900 = ~555 domains\n   *\n   * Realistically, the cap on the number of domains will likely exist in other places, but we cap it\n   * here as a last resort.\n   */\n  uint256 public constant MAX_DOMAINS = 500;\n\n  /**\n   * @notice Domains array tracks currently subscribed domains to this hub aggregator.\n   * We should distribute the aggregate root to all of these domains in the `propagate` method.\n   * @dev Whenever this domains array is updated, the connectors array should also be updated.\n   */\n  uint32[] public domains;\n\n  /**\n   * @notice A \"quick reference\" hash used in the `propagate` method below to validate that the provided\n   * array of domains matches the one we have in storage.\n   * @dev This hash should be re-calculated whenever the domains array is updated.\n   */\n  bytes32 public domainsHash;\n\n  /**\n   * @notice Tracks the addresses of the hub connector contracts corresponding to subscribed spoke domains.\n   * The index of any given connector in this array should match the index of that connector's target spoke\n   * domain in the `domains` array above.\n   * @dev This should be updated whenever the domains array is updated.\n   */\n  address[] public connectors;\n\n  /**\n   * @notice A \"quick reference\" hash used in the `propagate` method below to validate that the provided\n   * array of connectors matches the one we have in storage.\n   * @dev This hash should be re-calculated whenever the connectors array is updated.\n   */\n  bytes32 public connectorsHash;\n\n  /**\n   * @notice Shortcut to reverse lookup the index by domain. We index starting at one so the zero value can\n   * be considered invalid (see fn: `isDomainSupported`).\n   * @dev This should be updated whenever the domains array is updated.\n   */\n  mapping(uint32 => uint256) private domainToIndexPlusOne;\n\n  // ============ Getters ============\n\n  /**\n   * @notice Convenience shortcut for supported domains. Used to sanity check adding new domains.\n   * @param _domain Domain to check.\n   */\n  function isDomainSupported(uint32 _domain) public view returns (bool) {\n    return domainToIndexPlusOne[_domain] != 0;\n  }\n\n  /**\n   * @notice Gets the index of a given domain in the domains and connectors arrays.\n   * @dev Reverts if domain is not supported.\n   * @param _domain The domain for which to get the index value.\n   */\n  function getDomainIndex(uint32 _domain) public view returns (uint256) {\n    uint256 index = domainToIndexPlusOne[_domain];\n    require(index != 0, \"!supported\");\n    return index - 1;\n  }\n\n  /**\n   * @notice Gets the corresponding hub connector address for a given spoke domain.\n   * @dev Inefficient, should only be used by caller if they have no index reference.\n   * @param _domain The domain for which to get the hub connector address.\n   */\n  function getConnectorForDomain(uint32 _domain) public view returns (address) {\n    return connectors[getDomainIndex(_domain)];\n  }\n\n  /**\n   * @notice Validate given domains and connectors arrays are correct (i.e. they mirror what is\n   * currently saved in storage).\n   * @dev Reverts if domains or connectors do not match, including ordering.\n   * @param _domains The given domains array to check.\n   * @param _connectors The given connectors array to check.\n   */\n  function validateDomains(uint32[] calldata _domains, address[] calldata _connectors) public view {\n    // Sanity check: arguments are same length.\n    require(_domains.length == _connectors.length, \"!matching length\");\n    // Validate that given domains match the current array in storage.\n    require(keccak256(abi.encode(_domains)) == domainsHash, \"!domains\");\n    // Validate that given connectors match the current array in storage.\n    require(keccak256(abi.encode(_connectors)) == connectorsHash, \"!connectors\");\n  }\n\n  /**\n   * @notice Validate given connectors array is correct (i.e. it mirrors what is\n   * currently saved in storage).\n   * @dev Reverts if domains or connectors do not match, including ordering.\n   * @param _connectors The given connectors array to check.\n   */\n  function validateConnectors(address[] calldata _connectors) public view {\n    // Validate that given connectors match the current array in storage.\n    require(keccak256(abi.encode(_connectors)) == connectorsHash, \"!connectors\");\n  }\n\n  // ============ Helper Functions ============\n\n  /**\n   * @notice Handles all mutex for adding support for a given domain.\n   * @param _domain Domain for which we are adding support.\n   * @param _connector Corresponding hub connector address belonging to given domain.\n   */\n  function addDomain(uint32 _domain, address _connector) internal {\n    // Sanity check: domain does not already exist.\n    require(!isDomainSupported(_domain), \"exists\");\n    // Sanity check: connector is reasonable.\n    require(_connector != address(0), \"!connector\");\n    // Sanity check: Under maximum.\n    require(domains.length < MAX_DOMAINS, \"DomainIndexer at capacity\");\n\n    // Push domain and connector to respective arrays.\n    domains.push(_domain);\n    connectors.push(_connector);\n    // Set reverse lookup.\n    uint256 _indexPlusOne = domains.length;\n    domainToIndexPlusOne[_domain] = _indexPlusOne;\n\n    // Update the hashes for the given arrays.\n    updateHashes();\n\n    emit DomainAdded(_domain, _connector);\n  }\n\n  /**\n   * @notice Handles all mutex for removing support for a given domain.\n   * @param _domain Domain we are removing.\n   * @return address of the hub connector for the domain we removed.\n   */\n  function removeDomain(uint32 _domain) internal returns (address) {\n    uint256 _index = getDomainIndex(_domain);\n    // Get the connector at the given index.\n    address _connector = connectors[_index];\n    // Sanity check: connector exists.\n    require(_connector != address(0), \"connector !exists\");\n\n    // Shortcut: is the index the last index in the domains/connectors arrays?\n    // IFF not, we'll need to swap the target with the current last so we can pop().\n    uint256 _lastIndex = domains.length - 1;\n    if (_index < _lastIndex) {\n      // If the target index for removal is not the last index, we'll need to move the last index\n      // item to the target index's place so we can conveniently pop the last item.\n      // Replace domain in domains array with the domain in the final index.\n      domains[_index] = domains[_lastIndex];\n      connectors[_index] = connectors[_lastIndex];\n    }\n\n    // Pop the last item in the arrays.\n    domains.pop();\n    connectors.pop();\n    // Erase reverse lookup.\n    delete domainToIndexPlusOne[_domain];\n\n    // Update the hashes for the given arrays.\n    updateHashes();\n\n    emit DomainRemoved(_domain);\n\n    return _connector;\n  }\n\n  /**\n   * @notice Calculate the new hashes for the domains and connectors arrays and update storage refs.\n   * @dev Used for the Connector update functions `addConnector`, `removeConnector`.\n   */\n  function updateHashes() internal {\n    uint32[] memory _domains = domains;\n    address[] memory _connectors = connectors;\n    domainsHash = keccak256(abi.encode(_domains));\n    connectorsHash = keccak256(abi.encode(_connectors));\n  }\n}\n"
    },
    "contracts/core/connext/libraries/SwapUtilsExternal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {LPToken} from \"../helpers/LPToken.sol\";\n\nimport {MathUtils} from \"./MathUtils.sol\";\nimport {AssetLogic} from \"./AssetLogic.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * @title SwapUtilsExternal library\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\n * Admin functions should be protected within contracts using this library.\n */\nlibrary SwapUtilsExternal {\n  using SafeERC20 for IERC20;\n  using MathUtils for uint256;\n\n  /*** EVENTS ***/\n\n  event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\n  event AddLiquidity(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(uint256 newAdminFee);\n  event NewSwapFee(uint256 newSwapFee);\n\n  event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n  event StopRampA(uint256 currentA, uint256 time);\n\n  struct Swap {\n    // variables around the ramp management of A,\n    // the amplification coefficient * n ** (n - 1)\n    // see Curve stableswap paper for details\n    uint256 initialA;\n    uint256 futureA;\n    uint256 initialATime;\n    uint256 futureATime;\n    // fee calculation\n    uint256 swapFee;\n    uint256 adminFee;\n    LPToken lpToken;\n    // contract references for all tokens being pooled\n    IERC20[] pooledTokens;\n    // multipliers for each pooled token's precision to get to Constants.POOL_PRECISION_DECIMALS\n    // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n    // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\n    uint256[] tokenPrecisionMultipliers;\n    // the pool balance of each token, in the token's precision\n    // the contract's actual token balance might differ\n    uint256[] balances;\n    // the admin fee balance of each token, in the token's precision\n    uint256[] adminFees;\n  }\n\n  // Struct storing variables used in calculations in the\n  // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n  struct CalculateWithdrawOneTokenDYInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 newY;\n    uint256 feePerToken;\n    uint256 preciseA;\n  }\n\n  // Struct storing variables used in calculations in the\n  // {add,remove}Liquidity functions to avoid stack too deep errors\n  struct ManageLiquidityInfo {\n    uint256 d0;\n    uint256 d1;\n    uint256 d2;\n    uint256 preciseA;\n    LPToken lpToken;\n    uint256 totalSupply;\n    uint256[] balances;\n    uint256[] multipliers;\n  }\n\n  /*** VIEW & PURE FUNCTIONS ***/\n  /**\n   * @notice Return A, the amplification coefficient * n ** (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return A parameter\n   */\n  function getA(Swap storage self) external view returns (uint256) {\n    return _getAPrecise(self) / Constants.A_PRECISION;\n  }\n\n  /**\n   * @notice Return A in its raw precision\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return A parameter in its raw precision form\n   */\n  function getAPrecise(Swap storage self) external view returns (uint256) {\n    return _getAPrecise(self);\n  }\n\n  /**\n   * @notice Return A in its raw precision\n   * @dev See the StableSwap paper for details\n   * @param self Swap struct to read from\n   * @return currentA A parameter in its raw precision form\n   */\n  function _getAPrecise(Swap storage self) internal view returns (uint256 currentA) {\n    uint256 t1 = self.futureATime; // time when ramp is finished\n    currentA = self.futureA; // final A value when ramp is finished\n    uint256 a0 = self.initialA; // initial A value when ramp is started\n\n    if (a0 != currentA && block.timestamp < t1) {\n      uint256 t0 = self.initialATime; // time when ramp is started\n      assembly {\n        currentA := div(add(mul(a0, sub(t1, timestamp())), mul(currentA, sub(timestamp(), t0))), sub(t1, t0))\n      }\n    }\n  }\n\n  /**\n   * @notice Calculate the dy, the amount of selected token that user receives and\n   * the fee of withdrawing in one token\n   * @param tokenAmount the amount to withdraw in the pool's precision\n   * @param tokenIndex which token will be withdrawn\n   * @param self Swap struct to read from\n   * @return the amount of token user will receive\n   */\n  function calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256) {\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\n      self,\n      tokenAmount,\n      tokenIndex,\n      self.lpToken.totalSupply()\n    );\n    return availableTokenAmount;\n  }\n\n  function _calculateWithdrawOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 totalSupply\n  ) private view returns (uint256, uint256) {\n    uint256 dy;\n    uint256 newY;\n    uint256 currentY;\n\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\n\n    // dy_0 (without fees)\n    // dy, dy_0 - dy\n\n    uint256 dySwapFee = (currentY - newY) / self.tokenPrecisionMultipliers[tokenIndex] - dy;\n\n    return (dy, dySwapFee);\n  }\n\n  /**\n   * @notice Calculate the dy of withdrawing in one token\n   * @param self Swap struct to read from\n   * @param tokenIndex which token will be withdrawn\n   * @param tokenAmount the amount to withdraw in the pools precision\n   * @return the d and the new y after withdrawing one token\n   */\n  function calculateWithdrawOneTokenDY(\n    Swap storage self,\n    uint8 tokenIndex,\n    uint256 tokenAmount,\n    uint256 totalSupply\n  )\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    // Get the current D, then solve the stableswap invariant\n    // y_i for D - tokenAmount\n    uint256[] memory xp = _xp(self);\n\n    require(tokenIndex < xp.length, \"index out of range\");\n\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n    v.preciseA = _getAPrecise(self);\n    v.d0 = getD(xp, v.preciseA);\n    v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\n\n    require(tokenAmount <= xp[tokenIndex], \"exceeds available\");\n\n    v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\n\n    uint256[] memory xpReduced = new uint256[](xp.length);\n\n    v.feePerToken = _feePerToken(self.swapFee, xp.length);\n\n    uint256 len = xp.length;\n    for (uint256 i; i < len; ) {\n      uint256 xpi = xp[i];\n      // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\n      // else dxExpected = xp[i] - (xp[i] * d1 / d0)\n      // xpReduced[i] -= dxExpected * fee / Constants.FEE_DENOMINATOR\n      xpReduced[i] =\n        xpi -\n        ((((i == tokenIndex) ? ((xpi * v.d1) / v.d0 - v.newY) : (xpi - (xpi * v.d1) / v.d0)) * v.feePerToken) /\n          Constants.FEE_DENOMINATOR);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    uint256 dy = xpReduced[tokenIndex] - getYD(v.preciseA, tokenIndex, xpReduced, v.d1);\n    dy = (dy - 1) / (self.tokenPrecisionMultipliers[tokenIndex]);\n\n    return (dy, v.newY, xp[tokenIndex]);\n  }\n\n  /**\n   * @notice Calculate the price of a token in the pool with given\n   * precision-adjusted balances and a particular D.\n   *\n   * @dev This is accomplished via solving the invariant iteratively.\n   * See the StableSwap paper and Curve.fi implementation for further details.\n   *\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n   * x_1**2 + b*x_1 = c\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\n   *\n   * @param a the amplification coefficient * n ** (n - 1). See the StableSwap paper for details.\n   * @param tokenIndex Index of token we are calculating for.\n   * @param xp a precision-adjusted set of pool balances. Array should be\n   * the same cardinality as the pool.\n   * @param d the stableswap invariant\n   * @return the price of the token, in the same precision as in xp\n   */\n  function getYD(\n    uint256 a,\n    uint8 tokenIndex,\n    uint256[] memory xp,\n    uint256 d\n  ) public pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndex < numTokens, \"Token not found\");\n\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = a * numTokens;\n\n    for (uint256 i; i < numTokens; ) {\n      if (i != tokenIndex) {\n        s += xp[i];\n        c = (c * d) / (xp[i] * numTokens);\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // c = c * D * D * D * ... overflow!\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    c = (c * d * Constants.A_PRECISION) / (nA * numTokens);\n\n    uint256 b = s + ((d * Constants.A_PRECISION) / nA);\n    uint256 yPrev;\n    uint256 y = d;\n    for (uint256 i; i < Constants.MAX_LOOP_LIMIT; ) {\n      yPrev = y;\n      y = ((y * y) + c) / ((y * 2) + b - d);\n      if (y.within1(yPrev)) {\n        return y;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n   * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\n   * as the pool.\n   * @param a the amplification coefficient * n ** (n - 1) in Constants.A_PRECISION.\n   * See the StableSwap paper for details\n   * @return the invariant, at the precision of the pool\n   */\n  function getD(uint256[] memory xp, uint256 a) public pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    uint256 s;\n    for (uint256 i; i < numTokens; ) {\n      s += xp[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n    if (s == 0) {\n      return 0;\n    }\n\n    uint256 prevD;\n    uint256 d = s;\n    uint256 nA = a * numTokens;\n\n    for (uint256 i; i < Constants.MAX_LOOP_LIMIT; ) {\n      uint256 dP = d;\n      for (uint256 j; j < numTokens; ) {\n        dP = (dP * d) / (xp[j] * numTokens);\n        // If we were to protect the division loss we would have to keep the denominator separate\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\n        // dP = dP * D * D * D * ... overflow!\n\n        unchecked {\n          ++j;\n        }\n      }\n      prevD = d;\n      d =\n        (((nA * s) / Constants.A_PRECISION + dP * numTokens) * d) /\n        ((((nA - Constants.A_PRECISION) * d) / Constants.A_PRECISION + (numTokens + 1) * dP));\n      if (d.within1(prevD)) {\n        return d;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n    // function which does not rely on D.\n    revert(\"D does not converge\");\n  }\n\n  /**\n   * @notice Given a set of balances and precision multipliers, return the\n   * precision-adjusted balances.\n   *\n   * @param balances an array of token balances, in their native precisions.\n   * These should generally correspond with pooled tokens.\n   *\n   * @param precisionMultipliers an array of multipliers, corresponding to\n   * the amounts in the balances array. When multiplied together they\n   * should yield amounts at the pool's precision.\n   *\n   * @return an array of amounts \"scaled\" to the pool's precision\n   */\n  function _xp(uint256[] memory balances, uint256[] memory precisionMultipliers)\n    internal\n    pure\n    returns (uint256[] memory)\n  {\n    uint256 numTokens = balances.length;\n    require(numTokens == precisionMultipliers.length, \"mismatch multipliers\");\n    uint256[] memory xp = new uint256[](numTokens);\n    for (uint256 i; i < numTokens; ) {\n      xp[i] = balances[i] * precisionMultipliers[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n    return xp;\n  }\n\n  /**\n   * @notice Return the precision-adjusted balances of all tokens in the pool\n   * @param self Swap struct to read from\n   * @return the pool balances \"scaled\" to the pool's precision, allowing\n   * them to be more easily compared.\n   */\n  function _xp(Swap storage self) internal view returns (uint256[] memory) {\n    return _xp(self.balances, self.tokenPrecisionMultipliers);\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param self Swap struct to read from\n   * @return the virtual price, scaled to precision of Constants.POOL_PRECISION_DECIMALS\n   */\n  function getVirtualPrice(Swap storage self) external view returns (uint256) {\n    uint256 d = getD(_xp(self), _getAPrecise(self));\n    LPToken lpToken = self.lpToken;\n    uint256 supply = lpToken.totalSupply();\n    if (supply != 0) {\n      return (d * (10**uint256(Constants.POOL_PRECISION_DECIMALS))) / supply;\n    }\n    return 0;\n  }\n\n  /**\n   * @notice Calculate the new balances of the tokens given the indexes of the token\n   * that is swapped from (FROM) and the token that is swapped to (TO).\n   * This function is used as a helper function to calculate how much TO token\n   * the user should receive on swap.\n   *\n   * @param preciseA precise form of amplification coefficient\n   * @param tokenIndexFrom index of FROM token\n   * @param tokenIndexTo index of TO token\n   * @param x the new total amount of FROM token\n   * @param xp balances of the tokens in the pool\n   * @return the amount of TO token that should remain in the pool\n   */\n  function getY(\n    uint256 preciseA,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 x,\n    uint256[] memory xp\n  ) public pure returns (uint256) {\n    uint256 numTokens = xp.length;\n    require(tokenIndexFrom != tokenIndexTo, \"compare token to itself\");\n    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"token not found\");\n\n    uint256 d = getD(xp, preciseA);\n    uint256 c = d;\n    uint256 s;\n    uint256 nA = numTokens * preciseA;\n\n    uint256 _x;\n    for (uint256 i; i < numTokens; ) {\n      if (i == tokenIndexFrom) {\n        _x = x;\n      } else if (i != tokenIndexTo) {\n        _x = xp[i];\n      } else {\n        unchecked {\n          ++i;\n        }\n        continue;\n      }\n      s += _x;\n      c = (c * d) / (_x * numTokens);\n      // If we were to protect the division loss we would have to keep the denominator separate\n      // and divide at the end. However this leads to overflow with large numTokens or/and D.\n      // c = c * D * D * D * ... overflow!\n\n      unchecked {\n        ++i;\n      }\n    }\n    c = (c * d * Constants.A_PRECISION) / (nA * numTokens);\n    uint256 b = s + ((d * Constants.A_PRECISION) / nA);\n    uint256 yPrev;\n    uint256 y = d;\n\n    // iterative approximation\n    for (uint256 i; i < Constants.MAX_LOOP_LIMIT; ) {\n      yPrev = y;\n      y = ((y * y) + c) / ((y * 2) + b - d);\n      if (y.within1(yPrev)) {\n        return y;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    revert(\"Approximation did not converge\");\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get\n   */\n  function calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256 dy) {\n    (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\n  }\n\n  /**\n   * @notice Externally calculates a swap between two tokens.\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy.\n   * @return dx the number of tokens the user have to transfer + fee\n   */\n  function calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy\n  ) external view returns (uint256 dx) {\n    (dx, ) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, self.balances);\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dy the number of tokens the user will get in the token's precision. ex WBTC -> 8\n   * @return dyFee the associated fee in multiplied precision (Constants.POOL_PRECISION_DECIMALS)\n   */\n  function _calculateSwap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256[] memory balances\n  ) internal view returns (uint256 dy, uint256 dyFee) {\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"index out of range\");\n    uint256 x = dx * multipliers[tokenIndexFrom] + xp[tokenIndexFrom];\n    uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\n    dy = xp[tokenIndexTo] - y - 1;\n    dyFee = (dy * self.swapFee) / Constants.FEE_DENOMINATOR;\n    dy = (dy - dyFee) / multipliers[tokenIndexTo];\n  }\n\n  /**\n   * @notice Internally calculates a swap between two tokens.\n   *\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\n   * using the token contracts.\n   *\n   * @param self Swap struct to read from\n   * @param tokenIndexFrom the token to sell\n   * @param tokenIndexTo the token to buy\n   * @param dy the number of tokens to buy. If the token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @return dx the number of tokens the user have to deposit in the token's precision. ex WBTC -> 8\n   * @return dxFee the associated fee in multiplied precision (Constants.POOL_PRECISION_DECIMALS)\n   */\n  function _calculateSwapInv(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256[] memory balances\n  ) internal view returns (uint256 dx, uint256 dxFee) {\n    require(tokenIndexFrom != tokenIndexTo, \"compare token to itself\");\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n    uint256[] memory xp = _xp(balances, multipliers);\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"index out of range\");\n\n    uint256 a = _getAPrecise(self);\n    uint256 d0 = getD(xp, a);\n\n    xp[tokenIndexTo] = xp[tokenIndexTo] - (dy * multipliers[tokenIndexTo]);\n    uint256 x = getYD(a, tokenIndexFrom, xp, d0);\n    dx = x - xp[tokenIndexFrom] + 1;\n    dxFee = (dx * self.swapFee) / Constants.FEE_DENOMINATOR;\n    dx = (dx + dxFee) / multipliers[tokenIndexFrom];\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of\n   * LP tokens\n   *\n   * @param amount the amount of LP tokens that would to be burned on\n   * withdrawal\n   * @return array of amounts of tokens user will receive\n   */\n  function calculateRemoveLiquidity(Swap storage self, uint256 amount) external view returns (uint256[] memory) {\n    return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\n  }\n\n  function _calculateRemoveLiquidity(\n    uint256[] memory balances,\n    uint256 amount,\n    uint256 totalSupply\n  ) internal pure returns (uint256[] memory) {\n    require(amount <= totalSupply, \"exceed total supply\");\n\n    uint256 numBalances = balances.length;\n    uint256[] memory amounts = new uint256[](numBalances);\n\n    for (uint256 i; i < numBalances; ) {\n      amounts[i] = (balances[i] * amount) / totalSupply;\n\n      unchecked {\n        ++i;\n      }\n    }\n    return amounts;\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param self Swap struct to read from\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return if deposit was true, total amount of lp token that will be minted and if\n   * deposit was false, total amount of lp token that will be burned\n   */\n  function calculateTokenAmount(\n    Swap storage self,\n    uint256[] calldata amounts,\n    bool deposit\n  ) external view returns (uint256) {\n    uint256 a = _getAPrecise(self);\n    uint256[] memory balances = self.balances;\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\n\n    uint256 numBalances = balances.length;\n    uint256 d0 = getD(_xp(balances, multipliers), a);\n    for (uint256 i; i < numBalances; ) {\n      if (deposit) {\n        balances[i] = balances[i] + amounts[i];\n      } else {\n        balances[i] = balances[i] - amounts[i];\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n    uint256 d1 = getD(_xp(balances, multipliers), a);\n    uint256 totalSupply = self.lpToken.totalSupply();\n\n    if (deposit) {\n      return ((d1 - d0) * totalSupply) / d0;\n    } else {\n      return ((d0 - d1) * totalSupply) / d0;\n    }\n  }\n\n  /**\n   * @notice return accumulated amount of admin fees of the token with given index\n   * @param self Swap struct to read from\n   * @param index Index of the pooled token\n   * @return admin balance in the token's precision\n   */\n  function getAdminBalance(Swap storage self, uint256 index) external view returns (uint256) {\n    require(index < self.pooledTokens.length, \"index out of range\");\n    return self.adminFees[index];\n  }\n\n  /**\n   * @notice internal helper function to calculate fee per token multiplier used in\n   * swap fee calculations\n   * @param swapFee swap fee for the tokens\n   * @param numTokens number of tokens pooled\n   */\n  function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\n    return (swapFee * numTokens) / ((numTokens - 1) * 4);\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @return amount of token user received on swap\n   */\n  function swap(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) external returns (uint256) {\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"swap more than you own\");\n      // Reverts for fee on transfer\n      AssetLogic.handleIncomingAsset(address(tokenFrom), dx);\n    }\n\n    uint256 dy;\n    uint256 dyFee;\n    uint256[] memory balances = self.balances;\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\n    require(dy >= minDy, \"dy < minDy\");\n\n    uint256 dyAdminFee = (dyFee * self.adminFee) /\n      Constants.FEE_DENOMINATOR /\n      self.tokenPrecisionMultipliers[tokenIndexTo];\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\n    if (dyAdminFee != 0) {\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo] + dyAdminFee;\n    }\n\n    AssetLogic.handleOutgoingAsset(address(self.pooledTokens[tokenIndexTo]), msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dy;\n  }\n\n  /**\n   * @notice swap two tokens in the pool\n   * @param self Swap struct to read from and write to\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dy the amount of tokens the user wants to buy\n   * @param maxDx the max amount the user would like to send.\n   * @return amount of token user have to transfer on swap\n   */\n  function swapOut(\n    Swap storage self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy,\n    uint256 maxDx\n  ) external returns (uint256) {\n    require(dy <= self.balances[tokenIndexTo], \">pool balance\");\n\n    uint256 dx;\n    uint256 dxFee;\n    uint256[] memory balances = self.balances;\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\n    require(dx <= maxDx, \"dx > maxDx\");\n\n    uint256 dxAdminFee = (dxFee * self.adminFee) /\n      Constants.FEE_DENOMINATOR /\n      self.tokenPrecisionMultipliers[tokenIndexFrom];\n\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx - dxAdminFee;\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy;\n    if (dxAdminFee != 0) {\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom] + dxAdminFee;\n    }\n\n    {\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\n      require(dx <= tokenFrom.balanceOf(msg.sender), \"more than you own\");\n      // Reverts for fee on transfer\n      AssetLogic.handleIncomingAsset(address(tokenFrom), dx);\n    }\n\n    AssetLogic.handleOutgoingAsset(address(self.pooledTokens[tokenIndexTo]), msg.sender, dy);\n\n    emit TokenSwap(msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\n\n    return dx;\n  }\n\n  /**\n   * @notice Add liquidity to the pool\n   * @param self Swap struct to read from and write to\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n   * @return amount of LP token user received\n   */\n  function addLiquidity(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 minToMint\n  ) external returns (uint256) {\n    uint256 numTokens = self.pooledTokens.length;\n    require(amounts.length == numTokens, \"mismatch pooled tokens\");\n\n    // current state\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n    if (v.totalSupply != 0) {\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n    }\n\n    uint256[] memory newBalances = new uint256[](numTokens);\n\n    for (uint256 i; i < numTokens; ) {\n      require(v.totalSupply != 0 || amounts[i] != 0, \"!supply all tokens\");\n\n      // Transfer tokens first to see if a fee was charged on transfer\n      if (amounts[i] != 0) {\n        IERC20 token = self.pooledTokens[i];\n        // Reverts if fee on transfer\n        AssetLogic.handleIncomingAsset(address(token), amounts[i]);\n      }\n\n      newBalances[i] = v.balances[i] + amounts[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // invariant after change\n    v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    require(v.d1 > v.d0, \"D should increase\");\n\n    // updated to reflect fees and calculate the user's LP tokens\n    v.d2 = v.d1;\n    uint256[] memory fees = new uint256[](numTokens);\n\n    if (v.totalSupply != 0) {\n      uint256 feePerToken = _feePerToken(self.swapFee, numTokens);\n      for (uint256 i; i < numTokens; ) {\n        uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n        fees[i] = (feePerToken * (idealBalance.difference(newBalances[i]))) / Constants.FEE_DENOMINATOR;\n        uint256 adminFee = (fees[i] * self.adminFee) / Constants.FEE_DENOMINATOR;\n        self.balances[i] = newBalances[i] - adminFee;\n        self.adminFees[i] = self.adminFees[i] + adminFee;\n        newBalances[i] = newBalances[i] - fees[i];\n\n        unchecked {\n          ++i;\n        }\n      }\n      v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\n    } else {\n      // the initial depositor doesn't pay fees\n      self.balances = newBalances;\n    }\n\n    uint256 toMint;\n    if (v.totalSupply == 0) {\n      toMint = v.d1;\n    } else {\n      toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\n    }\n\n    require(toMint >= minToMint, \"mint < min\");\n\n    // mint the user's LP tokens\n    v.lpToken.mint(msg.sender, toMint);\n\n    emit AddLiquidity(msg.sender, amounts, fees, v.d1, v.totalSupply + toMint);\n\n    return toMint;\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param self Swap struct to read from and write to\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   * acceptable for this burn. Useful as a front-running mitigation\n   * @return amounts of tokens the user received\n   */\n  function removeLiquidity(\n    Swap storage self,\n    uint256 amount,\n    uint256[] calldata minAmounts\n  ) external returns (uint256[] memory) {\n    LPToken lpToken = self.lpToken;\n    require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    uint256 numTokens = self.pooledTokens.length;\n    require(minAmounts.length == numTokens, \"mismatch poolTokens\");\n\n    uint256[] memory balances = self.balances;\n    uint256 totalSupply = lpToken.totalSupply();\n\n    uint256[] memory amounts = _calculateRemoveLiquidity(balances, amount, totalSupply);\n\n    uint256 numAmounts = amounts.length;\n    for (uint256 i; i < numAmounts; ) {\n      require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n      self.balances[i] = balances[i] - amounts[i];\n      AssetLogic.handleOutgoingAsset(address(self.pooledTokens[i]), msg.sender, amounts[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    lpToken.burnFrom(msg.sender, amount);\n\n    emit RemoveLiquidity(msg.sender, amounts, totalSupply - amount);\n\n    return amounts;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token.\n   * @param self Swap struct to read from and write to\n   * @param tokenAmount the amount of the lp tokens to burn\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @return amount chosen token that user received\n   */\n  function removeLiquidityOneToken(\n    Swap storage self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount\n  ) external returns (uint256) {\n    LPToken lpToken = self.lpToken;\n\n    require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n    uint256 numTokens = self.pooledTokens.length;\n    require(tokenIndex < numTokens, \"not found\");\n\n    uint256 totalSupply = lpToken.totalSupply();\n\n    (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(self, tokenAmount, tokenIndex, totalSupply);\n\n    require(dy >= minAmount, \"dy < minAmount\");\n\n    uint256 adminFee = (dyFee * self.adminFee) / Constants.FEE_DENOMINATOR;\n    self.balances[tokenIndex] = self.balances[tokenIndex] - (dy + adminFee);\n    if (adminFee != 0) {\n      self.adminFees[tokenIndex] = self.adminFees[tokenIndex] + adminFee;\n    }\n    lpToken.burnFrom(msg.sender, tokenAmount);\n    AssetLogic.handleOutgoingAsset(address(self.pooledTokens[tokenIndex]), msg.sender, dy);\n\n    emit RemoveLiquidityOne(msg.sender, tokenAmount, totalSupply, tokenIndex, dy);\n\n    return dy;\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances.\n   *\n   * @param self Swap struct to read from and write to\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @return actual amount of LP tokens burned in the withdrawal\n   */\n  function removeLiquidityImbalance(\n    Swap storage self,\n    uint256[] memory amounts,\n    uint256 maxBurnAmount\n  ) external returns (uint256) {\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\n      0,\n      0,\n      0,\n      _getAPrecise(self),\n      self.lpToken,\n      0,\n      self.balances,\n      self.tokenPrecisionMultipliers\n    );\n    v.totalSupply = v.lpToken.totalSupply();\n\n    uint256 numTokens = self.pooledTokens.length;\n    uint256 numAmounts = amounts.length;\n    require(numAmounts == numTokens, \"mismatch pool tokens\");\n\n    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\");\n\n    uint256 feePerToken = _feePerToken(self.swapFee, numTokens);\n    uint256[] memory fees = new uint256[](numTokens);\n    {\n      uint256[] memory balances1 = new uint256[](numTokens);\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n      for (uint256 i; i < numTokens; ) {\n        require(v.balances[i] >= amounts[i], \"withdraw more than available\");\n\n        unchecked {\n          balances1[i] = v.balances[i] - amounts[i];\n          ++i;\n        }\n      }\n      v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n      for (uint256 i; i < numTokens; ) {\n        {\n          uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\n          uint256 difference = idealBalance.difference(balances1[i]);\n          fees[i] = (feePerToken * difference) / Constants.FEE_DENOMINATOR;\n        }\n        uint256 adminFee = (fees[i] * self.adminFee) / Constants.FEE_DENOMINATOR;\n        self.balances[i] = balances1[i] - adminFee;\n        self.adminFees[i] = self.adminFees[i] + adminFee;\n        balances1[i] = balances1[i] - fees[i];\n\n        unchecked {\n          ++i;\n        }\n      }\n\n      v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n    }\n    uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\n    require(tokenAmount != 0, \"!zero amount\");\n    tokenAmount = tokenAmount + 1;\n\n    require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n    v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n    for (uint256 i; i < numTokens; ) {\n      AssetLogic.handleOutgoingAsset(address(self.pooledTokens[i]), msg.sender, amounts[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit RemoveLiquidityImbalance(msg.sender, amounts, fees, v.d1, v.totalSupply - tokenAmount);\n\n    return tokenAmount;\n  }\n\n  /**\n   * @notice withdraw all admin fees to a given address\n   * @param self Swap struct to withdraw fees from\n   * @param to Address to send the fees to\n   */\n  function withdrawAdminFees(Swap storage self, address to) external {\n    uint256 numTokens = self.pooledTokens.length;\n    for (uint256 i; i < numTokens; ) {\n      IERC20 token = self.pooledTokens[i];\n      uint256 balance = self.adminFees[i];\n      if (balance != 0) {\n        delete self.adminFees[i];\n        AssetLogic.handleOutgoingAsset(address(token), to, balance);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @notice Sets the admin fee\n   * @dev adminFee cannot be higher than 100% of the swap fee\n   * @param self Swap struct to update\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setAdminFee(Swap storage self, uint256 newAdminFee) external {\n    require(newAdminFee < Constants.MAX_ADMIN_FEE + 1, \"too high\");\n    self.adminFee = newAdminFee;\n\n    emit NewAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice update the swap fee\n   * @dev fee cannot be higher than 1% of each swap\n   * @param self Swap struct to update\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(Swap storage self, uint256 newSwapFee) external {\n    require(newSwapFee < Constants.MAX_SWAP_FEE + 1, \"too high\");\n    self.swapFee = newSwapFee;\n\n    emit NewSwapFee(newSwapFee);\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param self Swap struct to update\n   * @param futureA_ the new A to ramp towards\n   * @param futureTime_ timestamp when the new A should be reached\n   */\n  function rampA(\n    Swap storage self,\n    uint256 futureA_,\n    uint256 futureTime_\n  ) external {\n    require(block.timestamp >= self.initialATime + Constants.MIN_RAMP_DELAY, \"Wait 1 day before starting ramp\");\n    require(futureTime_ >= block.timestamp + Constants.MIN_RAMP_TIME, \"Insufficient ramp time\");\n    require(futureA_ != 0 && futureA_ < Constants.MAX_A, \"futureA_ must be > 0 and < Constants.MAX_A\");\n\n    uint256 initialAPrecise = _getAPrecise(self);\n    uint256 futureAPrecise = futureA_ * Constants.A_PRECISION;\n\n    if (futureAPrecise < initialAPrecise) {\n      require(futureAPrecise * Constants.MAX_A_CHANGE >= initialAPrecise, \"futureA_ is too small\");\n    } else {\n      require(futureAPrecise <= initialAPrecise * Constants.MAX_A_CHANGE, \"futureA_ is too large\");\n    }\n\n    self.initialA = initialAPrecise;\n    self.futureA = futureAPrecise;\n    self.initialATime = block.timestamp;\n    self.futureATime = futureTime_;\n\n    emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\n  }\n\n  /**\n   * @notice Stops ramping A immediately. Once this function is called, rampA()\n   * cannot be called for another 24 hours\n   * @param self Swap struct to update\n   */\n  function stopRampA(Swap storage self) external {\n    require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n\n    uint256 currentA = _getAPrecise(self);\n    self.initialA = currentA;\n    self.futureA = currentA;\n    self.initialATime = block.timestamp;\n    self.futureATime = block.timestamp;\n\n    emit StopRampA(currentA, block.timestamp);\n  }\n}\n"
    },
    "contracts/core/connext/helpers/OZERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// This is modified from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"\n// Modifications were made to allow the name, hashed name, and cached\n// domain separator to be internal\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * Implements ERC20 Permit extension allowing approvals to be made via\n * signatures, as defined in https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20\n * allowance (see {IERC20-allowance}) by presenting a message signed by the\n * account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n *\n * @dev Cannot use default ERC20/ERC20Permit implementation as there is no way to update\n * the name (set to private).\n *\n * Cannot use default EIP712 implementation as the _HASHED_NAME may change.\n * These functions use the same implementation, with easier storage access.\n */\ncontract ERC20 is IERC20Metadata, IERC20Permit {\n  // See ERC20\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string internal _name; // made internal, need access\n  string internal _symbol; // made internal, need access\n  uint8 internal _decimals; // made internal, need access\n\n  // See ERC20Permit\n  using Counters for Counters.Counter;\n\n  mapping(address => Counters.Counter) private _nonces;\n\n  // See EIP712\n  // Immutables used in EIP 712 structured data hashing & signing\n  // https://eips.ethereum.org/EIPS/eip-712\n  bytes32 private constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 internal constant _TYPE_HASH =\n    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n  // made internal, need access\n\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  bytes32 internal _CACHED_DOMAIN_SEPARATOR; // made internal, may change\n  uint256 private immutable _CACHED_CHAIN_ID;\n  address private immutable _CACHED_THIS;\n\n  bytes32 internal _HASHED_NAME; // made internal, may change\n  bytes32 internal immutable _HASHED_VERSION; // made internal, need access\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter,\n   * and setting `version` to `\"1\"`.\n   *\n   * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n   */\n  constructor(\n    uint8 decimals_,\n    string memory name_,\n    string memory symbol_,\n    string memory version_\n  ) {\n    // ERC20\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n\n    // EIP712\n    bytes32 hashedName = keccak256(bytes(name_));\n    bytes32 hashedVersion = keccak256(bytes(version_));\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = block.chainid;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);\n    _CACHED_THIS = address(this);\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address _owner, address _spender) public view virtual override returns (uint256) {\n    return _allowances[_owner][_spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `_sender` and `recipient` cannot be the zero address.\n   * - `_sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``_sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) public virtual override returns (bool) {\n    _spendAllowance(_sender, msg.sender, _amount);\n    _transfer(_sender, _recipient, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   */\n  function increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool) {\n    _approve(msg.sender, _spender, _allowances[msg.sender][_spender] + _addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_spender` cannot be the zero address.\n   * - `_spender` must have allowance for the caller of at least\n   * `_subtractedValue`.\n   */\n  function decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool) {\n    uint256 currentAllowance = allowance(msg.sender, _spender);\n    require(currentAllowance >= _subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n      _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves tokens `amount` from `_sender` to `_recipient`.\n   *\n   * This is internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `_sender` cannot be the zero address.\n   * - `_recipient` cannot be the zero address.\n   * - `_sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address _sender,\n    address _recipient,\n    uint256 _amount\n  ) internal virtual {\n    require(_sender != address(0), \"ERC20: transfer from the zero address\");\n    require(_recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(_sender, _recipient, _amount);\n\n    uint256 fromBalance = _balances[_sender];\n    require(fromBalance >= _amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[_sender] = fromBalance - _amount;\n      // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n      // decrementing then incrementing.\n      _balances[_recipient] += _amount;\n    }\n\n    emit Transfer(_sender, _recipient, _amount);\n\n    _afterTokenTransfer(_sender, _recipient, _amount);\n  }\n\n  /** @dev Creates `_amount` tokens and assigns them to `_account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   */\n  function _mint(address _account, uint256 _amount) internal virtual {\n    require(_account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), _account, _amount);\n\n    _totalSupply += _amount;\n    unchecked {\n      // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n      _balances[_account] += _amount;\n    }\n    emit Transfer(address(0), _account, _amount);\n\n    _afterTokenTransfer(address(0), _account, _amount);\n  }\n\n  /**\n   * @dev Destroys `_amount` tokens from `_account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `_account` cannot be the zero address.\n   * - `_account` must have at least `_amount` tokens.\n   */\n  function _burn(address _account, uint256 _amount) internal virtual {\n    require(_account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(_account, address(0), _amount);\n\n    uint256 accountBalance = _balances[_account];\n    require(accountBalance >= _amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[_account] = accountBalance - _amount;\n      // Overflow not possible: amount <= accountBalance <= totalSupply\n      _totalSupply -= _amount;\n    }\n\n    emit Transfer(_account, address(0), _amount);\n\n    _afterTokenTransfer(_account, address(0), _amount);\n  }\n\n  /**\n   * @dev Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `_owner` cannot be the zero address.\n   * - `_spender` cannot be the zero address.\n   */\n  function _approve(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal virtual {\n    require(_owner != address(0), \"ERC20: approve from the zero address\");\n    require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[_owner][_spender] = _amount;\n    emit Approval(_owner, _spender, _amount);\n  }\n\n  /**\n   * @dev Updates `_owner` s allowance for `_spender` based on spent `_amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(\n    address _owner,\n    address _spender,\n    uint256 _amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(_owner, _spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= _amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(_owner, _spender, currentAllowance - _amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `_from` and `_to` are both non-zero, `_amount` of ``_from``'s tokens\n   * will be to transferred to `_to`.\n   * - when `_from` is zero, `_amount` tokens will be minted for `_to`.\n   * - when `_to` is zero, `_amount` of ``_from``'s tokens will be burned.\n   * - `_from` and `_to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal virtual {}\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n   * @notice Sets approval from owner to spender to value\n   * as long as deadline has not passed\n   * by submitting a valid signature from owner\n   * Uses EIP 712 structured data hashing & signing\n   * https://eips.ethereum.org/EIPS/eip-712\n   * @param _owner The account setting approval & signing the message\n   * @param _spender The account receiving approval to spend owner's tokens\n   * @param _value The amount to set approval for\n   * @param _deadline The timestamp before which the signature must be submitted\n   * @param _v ECDSA signature v\n   * @param _r ECDSA signature r\n   * @param _s ECDSA signature s\n   */\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public virtual override {\n    require(block.timestamp <= _deadline, \"ERC20Permit: expired deadline\");\n\n    bytes32 _structHash = keccak256(\n      abi.encode(_PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n    );\n\n    bytes32 _hash = _hashTypedDataV4(_structHash);\n\n    address _signer = ECDSA.recover(_hash, _v, _r, _s);\n    require(_signer == _owner, \"ERC20Permit: invalid signature\");\n\n    _approve(_owner, _spender, _value);\n  }\n\n  /**\n   * @dev See {IERC20Permit-nonces}.\n   */\n  function nonces(address _owner) public view virtual override returns (uint256) {\n    return _nonces[_owner].current();\n  }\n\n  /**\n   * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n   * This is ALWAYS calculated at runtime because the token name is mutable, not constant.\n   */\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   * @dev See {EIP712._buildDomainSeparator}\n   */\n  function _useNonce(address _owner) internal virtual returns (uint256 current) {\n    Counters.Counter storage nonce = _nonces[_owner];\n    current = nonce.current();\n    nonce.increment();\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   * @dev See {EIP712._buildDomainSeparator}\n   */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  /**\n   * @dev See {EIP712._buildDomainSeparator}. Made internal to allow usage in parent class.\n   */\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) internal view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for this domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {ERC20} from \"../core/connext/helpers/OZERC20.sol\";\nimport {IERC20Metadata, IERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport {IBridgeToken} from \"../core/connext/interfaces/IBridgeToken.sol\";\n\n/**\n * @notice This token is ONLY useful for testing\n * @dev Anybody can mint as many tokens as they like\n * @dev Anybody can burn anyone else's tokens\n */\ncontract TestERC20 is ERC20, IBridgeToken {\n  constructor(string memory _name, string memory _symbol) ERC20(18, _name, _symbol, \"1\") {\n    _mint(msg.sender, 1000000 ether);\n  }\n\n  // ============ Bridge functions ===============\n  function setDetails(string calldata _newName, string calldata _newSymbol) external override {\n    // Does nothing, in practice will update the details to match the hash in message\n    // not the autodeployed results\n    _name = _newName;\n    _symbol = _newSymbol;\n  }\n\n  // ============ Token functions ===============\n  function balanceOf(address account) public view override(ERC20, IERC20) returns (uint256) {\n    return ERC20.balanceOf(account);\n  }\n\n  function mint(address account, uint256 amount) external {\n    _mint(account, amount);\n  }\n\n  function burn(address account, uint256 amount) external {\n    _burn(account, amount);\n  }\n\n  function symbol() public view override(ERC20, IERC20Metadata) returns (string memory) {\n    return ERC20.symbol();\n  }\n\n  function name() public view override(ERC20, IERC20Metadata) returns (string memory) {\n    return ERC20.name();\n  }\n\n  function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {\n    return ERC20.decimals();\n  }\n}\n"
    },
    "contracts/core/connext/interfaces/IBridgeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IBridgeToken is IERC20Metadata {\n  function burn(address _from, uint256 _amnt) external;\n\n  function mint(address _to, uint256 _amnt) external;\n\n  function setDetails(string calldata _name, string calldata _symbol) external;\n}\n"
    },
    "contracts/core/connext/libraries/BridgeMessage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// ============ External Imports ============\nimport {TypedMemView} from \"../../../shared/libraries/TypedMemView.sol\";\nimport {TokenId} from \"./TokenId.sol\";\n\nlibrary BridgeMessage {\n  // ============ Libraries ============\n\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // ============ Enums ============\n\n  // WARNING: do NOT re-write the numbers / order\n  // of message types in an upgrade;\n  // will cause in-flight messages to be mis-interpreted\n  // The Types enum it defines the types of `views` that we use in BridgeMessage. A view\n  // points to a specific part of the memory and can slice bytes out of it. When we give a `type` to a view,\n  // we define the structure of the data it points to, so that we can do easy runtime assertions without\n  // having to fetch the whole data from memory and check for ourselves. In BridgeMessage.sol\n  // the types of `data` we can have are defined in this enum and may belong to different taxonomies.\n  // For example, a `Message` includes a `TokenId` and an Action (a `Transfer`).\n  // The Message is a different TYPE of data than a TokenId or Transfer, as TokenId and Transfer live inside\n  // the message. For that reason, we define them as different data types and we add them to the same enum\n  // for ease of use.\n  enum Types {\n    Invalid, // 0\n    TokenId, // 1\n    Message, // 2\n    Transfer // 3\n  }\n\n  // ============ Constants ============\n\n  uint256 private constant TOKEN_ID_LEN = 36; // 4 bytes domain + 32 bytes id\n  uint256 private constant IDENTIFIER_LEN = 1;\n  uint256 private constant TRANSFER_LEN = 65; // 1 byte identifier + 32 bytes amount + 32 bytes transfer id\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Asserts a message is of type `_t`\n   * @param _view The message\n   * @param _t The expected type\n   */\n  modifier typeAssert(bytes29 _view, Types _t) {\n    _view.assertType(uint40(_t));\n    _;\n  }\n\n  // ============ Internal Functions ============\n\n  /**\n   * @notice Checks that Action is valid type\n   * @param _action The action\n   * @return TRUE if action is valid\n   */\n  function isValidAction(bytes29 _action) internal pure returns (bool) {\n    return isTransfer(_action);\n  }\n\n  /**\n   * @notice Checks that view is a valid message length\n   * @param _view The bytes string\n   * @return TRUE if message is valid\n   */\n  function isValidMessageLength(bytes29 _view) internal pure returns (bool) {\n    uint256 _len = _view.len();\n    return _len == TOKEN_ID_LEN + TRANSFER_LEN;\n  }\n\n  /**\n   * @notice Formats an action message\n   * @param _tokenId The token ID\n   * @param _action The action\n   * @return The formatted message\n   */\n  function formatMessage(bytes29 _tokenId, bytes29 _action)\n    internal\n    view\n    typeAssert(_tokenId, Types.TokenId)\n    returns (bytes memory)\n  {\n    require(isValidAction(_action), \"!action\");\n    bytes29[] memory _views = new bytes29[](2);\n    _views[0] = _tokenId;\n    _views[1] = _action;\n    return TypedMemView.join(_views);\n  }\n\n  /**\n   * @notice Returns the type of the message\n   * @param _view The message\n   * @return The type of the message\n   */\n  function messageType(bytes29 _view) internal pure returns (Types) {\n    return Types(uint8(_view.typeOf()));\n  }\n\n  /**\n   * @notice Checks that the message is of the specified type\n   * @param _type the type to check for\n   * @param _action The message\n   * @return True if the message is of the specified type\n   */\n  function isType(bytes29 _action, Types _type) internal pure returns (bool) {\n    return actionType(_action) == uint8(_type) && messageType(_action) == _type;\n  }\n\n  /**\n   * @notice Checks that the message is of type Transfer\n   * @param _action The message\n   * @return True if the message is of type Transfer\n   */\n  function isTransfer(bytes29 _action) internal pure returns (bool) {\n    return isType(_action, Types.Transfer);\n  }\n\n  /**\n   * @notice Formats Transfer\n   * @param _amnt The transfer amount\n   * @param _transferId The unique identifier of the transfer\n   * @return\n   */\n  function formatTransfer(uint256 _amnt, bytes32 _transferId) internal pure returns (bytes29) {\n    return abi.encodePacked(Types.Transfer, _amnt, _transferId).ref(uint40(Types.Transfer));\n  }\n\n  /**\n   * @notice Serializes a Token ID struct\n   * @param _tokenId The token id struct\n   * @return The formatted Token ID\n   */\n  function formatTokenId(TokenId memory _tokenId) internal pure returns (bytes29) {\n    return formatTokenId(_tokenId.domain, _tokenId.id);\n  }\n\n  /**\n   * @notice Creates a serialized Token ID from components\n   * @param _domain The domain\n   * @param _id The ID\n   * @return The formatted Token ID\n   */\n  function formatTokenId(uint32 _domain, bytes32 _id) internal pure returns (bytes29) {\n    return abi.encodePacked(_domain, _id).ref(uint40(Types.TokenId));\n  }\n\n  /**\n   * @notice Retrieves the domain from a TokenID\n   * @param _tokenId The message\n   * @return The domain\n   */\n  function domain(bytes29 _tokenId) internal pure typeAssert(_tokenId, Types.TokenId) returns (uint32) {\n    return uint32(_tokenId.indexUint(0, 4));\n  }\n\n  /**\n   * @notice Retrieves the ID from a TokenID\n   * @param _tokenId The message\n   * @return The ID\n   */\n  function id(bytes29 _tokenId) internal pure typeAssert(_tokenId, Types.TokenId) returns (bytes32) {\n    // before = 4 bytes domain\n    return _tokenId.index(4, 32);\n  }\n\n  /**\n   * @notice Retrieves the EVM ID\n   * @param _tokenId The message\n   * @return The EVM ID\n   */\n  function evmId(bytes29 _tokenId) internal pure typeAssert(_tokenId, Types.TokenId) returns (address) {\n    // before = 4 bytes domain + 12 bytes empty to trim for address\n    return _tokenId.indexAddress(16);\n  }\n\n  /**\n   * @notice Retrieves the action identifier from message\n   * @param _message The action\n   * @return The message type\n   */\n  function msgType(bytes29 _message) internal pure returns (uint8) {\n    return uint8(_message.indexUint(TOKEN_ID_LEN, 1));\n  }\n\n  /**\n   * @notice Retrieves the identifier from action\n   * @param _action The action\n   * @return The action type\n   */\n  function actionType(bytes29 _action) internal pure returns (uint8) {\n    return uint8(_action.indexUint(0, 1));\n  }\n\n  /**\n   * @notice Retrieves the amount from a Transfer\n   * @param _transferAction The message\n   * @return The amount\n   */\n  function amnt(bytes29 _transferAction) internal pure returns (uint256) {\n    // before = 1 byte identifier = 1 bytes\n    return _transferAction.indexUint(1, 32);\n  }\n\n  /**\n   * @notice Retrieves the transfer id from a Transfer\n   * @param _transferAction The message\n   * @return The id\n   */\n  function transferId(bytes29 _transferAction) internal pure returns (bytes32) {\n    // before = 1 byte identifier + 32 bytes amount = 33 bytes\n    return _transferAction.index(33, 32);\n  }\n\n  /**\n   * @notice Retrieves the token ID from a Message\n   * @param _message The message\n   * @return The ID\n   */\n  function tokenId(bytes29 _message) internal pure typeAssert(_message, Types.Message) returns (bytes29) {\n    return _message.slice(0, TOKEN_ID_LEN, uint40(Types.TokenId));\n  }\n\n  /**\n   * @notice Retrieves the action data from a Message\n   * @param _message The message\n   * @return The action\n   */\n  function action(bytes29 _message) internal pure typeAssert(_message, Types.Message) returns (bytes29) {\n    uint256 _actionLen = _message.len() - TOKEN_ID_LEN;\n    uint40 _type = uint40(msgType(_message));\n    return _message.slice(TOKEN_ID_LEN, _actionLen, _type);\n  }\n\n  /**\n   * @notice Converts to a Message\n   * @param _message The message\n   * @return The newly typed message\n   */\n  function tryAsMessage(bytes29 _message) internal pure returns (bytes29) {\n    if (isValidMessageLength(_message)) {\n      return _message.castTo(uint40(Types.Message));\n    }\n    return TypedMemView.nullView();\n  }\n\n  /**\n   * @notice Asserts that the message is of type Message\n   * @param _view The message\n   * @return The message\n   */\n  function mustBeMessage(bytes29 _view) internal pure returns (bytes29) {\n    return tryAsMessage(_view).assertValid();\n  }\n}\n"
    },
    "contracts/core/connext/facets/SwapAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IERC20, Address, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {AmplificationUtils, SwapUtils} from \"../libraries/AmplificationUtils.sol\";\nimport {Constants} from \"../libraries/Constants.sol\";\n\nimport {LPToken} from \"../helpers/LPToken.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\n/**\n * @title SwapAdminFacet\n * @notice Contract module which exposes only-admin controls for the StableSwapFacet\n * contract.\n *\n * @dev This module is used through inheritance. It will make available the\n * modifier `onlyOwner`, which can be applied to your functions to restrict\n * their use to the owner.\n */\ncontract SwapAdminFacet is BaseConnextFacet {\n  using SafeERC20 for IERC20;\n  using SwapUtils for SwapUtils.Swap;\n  using AmplificationUtils for SwapUtils.Swap;\n\n  // ========== Custom Errors ===========\n  error SwapAdminFacet__initializeSwap_alreadyInitialized();\n  error SwapAdminFacet__initializeSwap_invalidPooledTokens();\n  error SwapAdminFacet__initializeSwap_decimalsMismatch();\n  error SwapAdminFacet__initializeSwap_duplicateTokens();\n  error SwapAdminFacet__initializeSwap_zeroTokenAddress();\n  error SwapAdminFacet__initializeSwap_tokenDecimalsExceedMax();\n  error SwapAdminFacet__initializeSwap_aExceedMax();\n  error SwapAdminFacet__initializeSwap_feeExceedMax();\n  error SwapAdminFacet__initializeSwap_adminFeeExceedMax();\n  error SwapAdminFacet__initializeSwap_failedInitLpTokenClone();\n  error SwapAdminFacet__updateLpTokenTarget_invalidNewAddress();\n  error SwapAdminFacet__removeSwap_notInitialized();\n  error SwapAdminFacet__removeSwap_notDisabledPool();\n  error SwapAdminFacet__removeSwap_delayNotElapsed();\n  error SwapAdminFacet__disableSwap_notInitialized();\n  error SwapAdminFacet__disableSwap_alreadyDisabled();\n\n  // ============ Properties ============\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when the owner calls `initializeSwap`\n   * @param key - Identifier for asset\n   * @param swap - The swap that was initialized\n   * @param caller - The caller of the function\n   */\n  event SwapInitialized(bytes32 indexed key, SwapUtils.Swap swap, address caller);\n\n  /**\n   * @notice Emitted when the owner calls `removeSwap`\n   * @param key - Identifier for asset\n   * @param caller - The caller of the function\n   */\n  event SwapRemoved(bytes32 indexed key, address caller);\n\n  /**\n   * @notice Emitted when the owner calls `disableSwap`\n   * @param key - Identifier for asset\n   * @param caller - The caller of the function\n   */\n  event SwapDisabled(bytes32 indexed key, address caller);\n\n  /**\n   * @notice Emitted when the owner withdraws admin fees\n   * @param key - Identifier for asset\n   * @param caller - The caller of the function\n   */\n  event AdminFeesWithdrawn(bytes32 indexed key, address caller);\n\n  /**\n   * @notice Emitted when the owner sets admin fees\n   * @param key - Identifier for asset\n   * @param newAdminFee - The updated fee\n   * @param caller - The caller of the function\n   */\n  event AdminFeesSet(bytes32 indexed key, uint256 newAdminFee, address caller);\n\n  /**\n   * @notice Emitted when the owner sets swap fees\n   * @param key - Identifier for asset\n   * @param newSwapFee - The updated fee\n   * @param caller - The caller of the function\n   */\n  event SwapFeesSet(bytes32 indexed key, uint256 newSwapFee, address caller);\n\n  /**\n   * @notice Emitted when the owner starts ramping up or down the A parameter\n   * @param key - Identifier for asset\n   * @param futureA - The final A value after ramp\n   * @param futureTime - The time A should reach the final value\n   * @param caller - The caller of the function\n   */\n  event RampAStarted(bytes32 indexed key, uint256 futureA, uint256 futureTime, address caller);\n\n  /**\n   * @notice Emitted when the owner stops ramping up or down the A parameter\n   * @param key - Identifier for asset\n   * @param caller - The caller of the function\n   */\n  event RampAStopped(bytes32 indexed key, address caller);\n\n  /**\n   * @notice Emitted when the owner update lpTokenTargetAddress\n   * @param oldAddress - The old lpTokenTargetAddress\n   * @param newAddress - Updated address\n   * @param caller - The caller of the function\n   */\n  event LPTokenTargetUpdated(address oldAddress, address newAddress, address caller);\n\n  // ============ External: Getters ============\n  /**\n   * @notice Returns the lp target token address\n   * @return address\n   */\n  function lpTokenTargetAddress() public view returns (address) {\n    return s.lpTokenTargetAddress;\n  }\n\n  /**\n   * @notice Return if the pool is disabled\n   * @param key Hash of the canonical id + domain\n   * @return disabled flag\n   */\n  function isDisabled(bytes32 key) external view returns (bool) {\n    return s.swapStorages[key].disabled;\n  }\n\n  /*** StableSwap ADMIN FUNCTIONS ***/\n  /**\n   * @notice Initializes this Swap contract with the given parameters.\n   * This will also clone a LPToken contract that represents users'\n   * LP positions. The owner of LPToken will be this contract - which means\n   * only this contract is allowed to mint/burn tokens.\n   *\n   * @dev The swap can only be updated after initialization via `rampA`. This means\n   * if this value is incorrectly set, it will take some time to reach the\n   * correct value.\n   *\n   * @param _key the hash of the canonical id and domain for token\n   * @param _pooledTokens an array of ERC20s this pool will accept.\n   * length of this array should be in 2 ~ 16\n   * @param decimals the decimals to use for each pooled token,\n   * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS(18)\n   * Only fixed decimal tokens are allowed.\n   * @param lpTokenName the long-form name of the token to be deployed\n   * @param lpTokenSymbol the short symbol for the token to be deployed\n   * @param _a the amplification coefficient * n ** (n - 1). See the\n   * StableSwap paper for details\n   * @param _fee default swap fee to be initialized with\n   * @param _adminFee default adminFee to be initialized with\n   */\n  function initializeSwap(\n    bytes32 _key,\n    IERC20[] memory _pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 _a,\n    uint256 _fee,\n    uint256 _adminFee\n  ) external onlyOwnerOrAdmin {\n    if (s.swapStorages[_key].pooledTokens.length != 0) revert SwapAdminFacet__initializeSwap_alreadyInitialized();\n\n    // Check _pooledTokens and precisions parameter\n    if (\n      _pooledTokens.length < Constants.MINIMUM_POOLED_TOKENS || _pooledTokens.length > Constants.MAXIMUM_POOLED_TOKENS\n    ) {\n      revert SwapAdminFacet__initializeSwap_invalidPooledTokens();\n    }\n\n    uint256 numPooledTokens = _pooledTokens.length;\n\n    if (numPooledTokens != decimals.length) revert SwapAdminFacet__initializeSwap_decimalsMismatch();\n\n    uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n    for (uint256 i; i < numPooledTokens; ) {\n      if (i != 0) {\n        // Check if index is already used. Check if 0th element is a duplicate.\n        if (s.tokenIndexes[_key][address(_pooledTokens[i])] != 0 || _pooledTokens[0] == _pooledTokens[i])\n          revert SwapAdminFacet__initializeSwap_duplicateTokens();\n      }\n      if (address(_pooledTokens[i]) == address(0)) revert SwapAdminFacet__initializeSwap_zeroTokenAddress();\n\n      if (decimals[i] > Constants.POOL_PRECISION_DECIMALS)\n        revert SwapAdminFacet__initializeSwap_tokenDecimalsExceedMax();\n\n      precisionMultipliers[i] = 10**uint256(Constants.POOL_PRECISION_DECIMALS - decimals[i]);\n      // NOTE: safe to cast to uint8 as the numPooledTokens is that type and the loop ceiling\n      s.tokenIndexes[_key][address(_pooledTokens[i])] = uint8(i);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // Check _a, _fee, _adminFee, _withdrawFee parameters\n    if (_a > Constants.MAX_A - 1) revert SwapAdminFacet__initializeSwap_aExceedMax();\n    if (_fee > Constants.MAX_SWAP_FEE - 1) revert SwapAdminFacet__initializeSwap_feeExceedMax();\n    if (_adminFee > Constants.MAX_ADMIN_FEE - 1) revert SwapAdminFacet__initializeSwap_adminFeeExceedMax();\n\n    // Initialize a LPToken contract\n    LPToken lpToken = LPToken(Clones.clone(s.lpTokenTargetAddress));\n    if (!lpToken.initialize(lpTokenName, lpTokenSymbol)) revert SwapAdminFacet__initializeSwap_failedInitLpTokenClone();\n\n    // Initialize swapStorage struct\n    SwapUtils.Swap memory entry = SwapUtils.Swap({\n      key: _key,\n      initialA: _a * Constants.A_PRECISION,\n      futureA: _a * Constants.A_PRECISION,\n      swapFee: _fee,\n      adminFee: _adminFee,\n      lpToken: lpToken,\n      pooledTokens: _pooledTokens,\n      tokenPrecisionMultipliers: precisionMultipliers,\n      balances: new uint256[](_pooledTokens.length),\n      adminFees: new uint256[](_pooledTokens.length),\n      initialATime: 0,\n      futureATime: 0,\n      disabled: false,\n      removeTime: 0\n    });\n    s.swapStorages[_key] = entry;\n    emit SwapInitialized(_key, entry, msg.sender);\n  }\n\n  /**\n   * @notice disable swap for key\n   *\n   * @param _key the hash of the canonical id and domain for token\n   */\n  function disableSwap(bytes32 _key) external onlyOwnerOrAdmin {\n    uint256 numPooledTokens = s.swapStorages[_key].pooledTokens.length;\n\n    if (numPooledTokens == 0) revert SwapAdminFacet__disableSwap_notInitialized();\n    if (s.swapStorages[_key].disabled) revert SwapAdminFacet__disableSwap_alreadyDisabled();\n\n    s.swapStorages[_key].disabled = true;\n    s.swapStorages[_key].removeTime = block.timestamp + Constants.REMOVE_DELAY;\n\n    emit SwapDisabled(_key, msg.sender);\n  }\n\n  /**\n   * @notice remove Swap Struct for key\n   *\n   * @param _key the hash of the canonical id and domain for token\n   */\n  function removeSwap(bytes32 _key) external onlyOwnerOrAdmin {\n    uint256 numPooledTokens = s.swapStorages[_key].pooledTokens.length;\n    if (numPooledTokens == 0) revert SwapAdminFacet__removeSwap_notInitialized();\n\n    if (!s.swapStorages[_key].disabled) revert SwapAdminFacet__removeSwap_notDisabledPool();\n    if (s.swapStorages[_key].removeTime > block.timestamp) revert SwapAdminFacet__removeSwap_delayNotElapsed();\n\n    for (uint256 i; i < numPooledTokens; ) {\n      IERC20 pooledToken = s.swapStorages[_key].pooledTokens[i];\n      if (s.swapStorages[_key].balances[i] > 0) {\n        // if there is not removed balance, transfer to admin wallet.\n        pooledToken.safeTransfer(msg.sender, s.swapStorages[_key].balances[i]);\n      }\n\n      delete s.tokenIndexes[_key][address(pooledToken)];\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    _withdrawAdminFees(_key, msg.sender);\n\n    delete s.swapStorages[_key];\n\n    emit SwapRemoved(_key, msg.sender);\n  }\n\n  /**\n   * @notice Withdraw all admin fees to the contract owner\n   * @param key Hash of the canonical domain and id\n   */\n  function withdrawSwapAdminFees(bytes32 key) external onlyOwnerOrAdmin nonReentrant {\n    _withdrawAdminFees(key, msg.sender);\n  }\n\n  /**\n   * @notice Withdraws all admin fees for pool at key to provided address and emits event\n   * @param _key Hash of the canonical domain and id\n   * @param _to Recipient of fees\n   */\n  function _withdrawAdminFees(bytes32 _key, address _to) internal {\n    s.swapStorages[_key].withdrawAdminFees(_to);\n    emit AdminFeesWithdrawn(_key, _to);\n  }\n\n  /**\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n   * @param key Hash of the canonical domain and id\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setSwapAdminFee(bytes32 key, uint256 newAdminFee) external onlyOwnerOrAdmin {\n    s.swapStorages[key].setAdminFee(newAdminFee);\n    emit AdminFeesSet(key, newAdminFee, msg.sender);\n  }\n\n  /**\n   * @notice Update the swap fee to be applied on swaps\n   * @param key Hash of the canonical domain and id\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(bytes32 key, uint256 newSwapFee) external onlyOwnerOrAdmin {\n    s.swapStorages[key].setSwapFee(newSwapFee);\n    emit SwapFeesSet(key, newSwapFee, msg.sender);\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param key Hash of the canonical domain and id\n   * @param futureA the new A to ramp towards\n   * @param futureTime timestamp when the new A should be reached\n   */\n  function rampA(\n    bytes32 key,\n    uint256 futureA,\n    uint256 futureTime\n  ) external onlyOwnerOrAdmin {\n    s.swapStorages[key].rampA(futureA, futureTime);\n    emit RampAStarted(key, futureA, futureTime, msg.sender);\n  }\n\n  /**\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n   * @param key Hash of the canonical domain and id\n   */\n  function stopRampA(bytes32 key) external onlyOwnerOrAdmin {\n    s.swapStorages[key].stopRampA();\n    emit RampAStopped(key, msg.sender);\n  }\n\n  /**\n   * @notice Update lpTokenTargetAddress\n   * @param newAddress New lpTokenTargetAddress\n   */\n  function updateLpTokenTarget(address newAddress) external onlyOwnerOrAdmin {\n    if (!Address.isContract(newAddress)) revert SwapAdminFacet__updateLpTokenTarget_invalidNewAddress();\n    emit LPTokenTargetUpdated(s.lpTokenTargetAddress, newAddress, msg.sender);\n    s.lpTokenTargetAddress = newAddress;\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/core/connext/helpers/StableSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {SwapUtilsExternal as SwapUtils} from \"../libraries/SwapUtilsExternal.sol\";\nimport {Constants} from \"../libraries/Constants.sol\";\n\nimport {OwnerPausableUpgradeable} from \"./OwnerPausableUpgradeable.sol\";\nimport {LPToken} from \"./LPToken.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\n * deployment size.\n */\ncontract StableSwap is IStableSwap, OwnerPausableUpgradeable, ReentrancyGuardUpgradeable {\n  using SwapUtils for SwapUtils.Swap;\n\n  // ============ Events ============\n  event SwapInitialized(SwapUtils.Swap swap, address caller);\n\n  // ============ Storage ============\n\n  // Struct storing data responsible for automatic market maker functionalities. In order to\n  // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\n  SwapUtils.Swap public swapStorage;\n\n  // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\n  // getTokenIndex function also relies on this mapping to retrieve token index.\n  mapping(address => uint8) private tokenIndexes;\n\n  // ============ Initializers ============\n\n  /**\n   * @notice Initializes this Swap contract with the given parameters.\n   * This will also clone a LPToken contract that represents users'\n   * LP positions. The owner of LPToken will be this contract - which means\n   * only this contract is allowed to mint/burn tokens.\n   *\n   * @param _pooledTokens an array of ERC20s this pool will accept\n   * @param decimals the decimals to use for each pooled token,\n   * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\n   * @param lpTokenName the long-form name of the token to be deployed\n   * @param lpTokenSymbol the short symbol for the token to be deployed\n   * @param _a the amplification coefficient * n ** (n - 1). See the\n   * StableSwap paper for details\n   * @param _fee default swap fee to be initialized with\n   * @param _adminFee default adminFee to be initialized with\n   * @param lpTokenTargetAddress the address of an existing LPToken contract to use as a target\n   */\n  function initialize(\n    IERC20[] memory _pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 _a,\n    uint256 _fee,\n    uint256 _adminFee,\n    address lpTokenTargetAddress\n  ) public override initializer {\n    __OwnerPausable_init();\n    __ReentrancyGuard_init();\n\n    uint256 numPooledTokens = _pooledTokens.length;\n\n    // Check _pooledTokens and precisions parameter\n    require(numPooledTokens > Constants.MINIMUM_POOLED_TOKENS - 1, \"_pooledTokens.length insufficient\");\n    require(numPooledTokens < Constants.MAXIMUM_POOLED_TOKENS + 1, \"_pooledTokens.length too large\");\n    require(numPooledTokens == decimals.length, \"_pooledTokens decimals mismatch\");\n\n    uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n    for (uint256 i = 0; i < numPooledTokens; ) {\n      if (i != 0) {\n        // Check if index is already used. Check if 0th element is a duplicate.\n        require(\n          tokenIndexes[address(_pooledTokens[i])] == 0 && _pooledTokens[0] != _pooledTokens[i],\n          \"Duplicate tokens\"\n        );\n      }\n      require(address(_pooledTokens[i]) != address(0), \"The 0 address isn't an ERC-20\");\n      require(decimals[i] < Constants.POOL_PRECISION_DECIMALS + 1, \"Token decimals exceeds max\");\n      precisionMultipliers[i] = 10**uint256(Constants.POOL_PRECISION_DECIMALS - decimals[i]);\n      tokenIndexes[address(_pooledTokens[i])] = uint8(i);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // Check _a, _fee, _adminFee, _withdrawFee parameters\n    require(_a < Constants.MAX_A, \"_a exceeds maximum\");\n    require(_fee < Constants.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n    require(_adminFee < Constants.MAX_ADMIN_FEE, \"_adminFee exceeds maximum\");\n\n    // Initialize a LPToken contract\n    LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n    require(lpToken.initialize(lpTokenName, lpTokenSymbol), \"could not init lpToken clone\");\n\n    // Initialize swapStorage struct\n    swapStorage.lpToken = lpToken;\n    swapStorage.pooledTokens = _pooledTokens;\n    swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n    swapStorage.balances = new uint256[](numPooledTokens);\n    swapStorage.adminFees = new uint256[](numPooledTokens);\n    swapStorage.initialA = _a * Constants.A_PRECISION;\n    swapStorage.futureA = _a * Constants.A_PRECISION;\n    // swapStorage.initialATime = 0;\n    // swapStorage.futureATime = 0;\n    swapStorage.swapFee = _fee;\n    swapStorage.adminFee = _adminFee;\n\n    emit SwapInitialized(swapStorage, msg.sender);\n  }\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Modifier to check deadline against current timestamp\n   * @param deadline latest timestamp to accept this transaction\n   */\n  modifier deadlineCheck(uint256 deadline) {\n    require(block.timestamp <= deadline, \"Deadline not met\");\n    _;\n  }\n\n  // ============ View functions ============\n\n  /**\n   * @notice Return A, the amplification coefficient * n ** (n - 1)\n   * @dev See the StableSwap paper for details\n   * @return A parameter\n   */\n  function getA() external view override returns (uint256) {\n    return swapStorage.getA();\n  }\n\n  /**\n   * @notice Return A in its raw precision form\n   * @dev See the StableSwap paper for details\n   * @return A parameter in its raw precision form\n   */\n  function getAPrecise() external view returns (uint256) {\n    return swapStorage.getAPrecise();\n  }\n\n  /**\n   * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n   * @param index the index of the token\n   * @return address of the token at given index\n   */\n  function getToken(uint8 index) public view override returns (IERC20) {\n    require(index < swapStorage.pooledTokens.length, \"Out of range\");\n    return swapStorage.pooledTokens[index];\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getTokenIndex(address tokenAddress) public view override returns (uint8) {\n    uint8 index = tokenIndexes[tokenAddress];\n    require(address(getToken(index)) == tokenAddress, \"Token does not exist\");\n    return index;\n  }\n\n  /**\n   * @notice Return current balance of the pooled token at given index\n   * @param index the index of the token\n   * @return current balance of the pooled token at given index with token's native precision\n   */\n  function getTokenBalance(uint8 index) external view override returns (uint256) {\n    require(index < swapStorage.pooledTokens.length, \"Index out of range\");\n    return swapStorage.balances[index];\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n   */\n  function getVirtualPrice() external view override returns (uint256) {\n    return swapStorage.getVirtualPrice();\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell. If the token charges\n   * a fee on transfers, use the amount that gets transferred after the fee.\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view override returns (uint256) {\n    return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dy the amount of tokens the user wants to buy\n   * @return amount of tokens the user have to transfer\n   */\n  function calculateSwapOut(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dy\n  ) external view override returns (uint256) {\n    return swapStorage.calculateSwapInv(tokenIndexFrom, tokenIndexTo, dy);\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountIn the amount of tokens the user wants to swap from\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwapFromAddress(\n    address assetIn,\n    address assetOut,\n    uint256 amountIn\n  ) external view override returns (uint256) {\n    uint8 tokenIndexFrom = getTokenIndex(assetIn);\n    uint8 tokenIndexTo = getTokenIndex(assetOut);\n    return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn);\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountOut the amount of tokens the user wants to swap to\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwapOutFromAddress(\n    address assetIn,\n    address assetOut,\n    uint256 amountOut\n  ) external view override returns (uint256) {\n    uint8 tokenIndexFrom = getTokenIndex(assetIn);\n    uint8 tokenIndexTo = getTokenIndex(assetOut);\n    return swapStorage.calculateSwapInv(tokenIndexFrom, tokenIndexTo, amountOut);\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return token amount the user will receive\n   */\n  function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view override returns (uint256) {\n    return swapStorage.calculateTokenAmount(amounts, deposit);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of LP tokens\n   * @param amount the amount of LP tokens that would be burned on withdrawal\n   * @return array of token balances that the user will receive\n   */\n  function calculateRemoveLiquidity(uint256 amount) external view override returns (uint256[] memory) {\n    return swapStorage.calculateRemoveLiquidity(amount);\n  }\n\n  /**\n   * @notice Calculate the amount of underlying token available to withdraw\n   * when withdrawing via only single token\n   * @param tokenAmount the amount of LP token to burn\n   * @param tokenIndex index of which token will be withdrawn\n   * @return availableTokenAmount calculated amount of underlying token\n   * available to withdraw\n   */\n  function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\n    external\n    view\n    override\n    returns (uint256 availableTokenAmount)\n  {\n    return swapStorage.calculateWithdrawOneToken(tokenAmount, tokenIndex);\n  }\n\n  /**\n   * @notice This function reads the accumulated amount of admin fees of the token with given index\n   * @param index Index of the pooled token\n   * @return admin's token balance in the token's precision\n   */\n  function getAdminBalance(uint256 index) external view returns (uint256) {\n    return swapStorage.getAdminBalance(index);\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param tokenIndexFrom the token the user wants to swap from\n   * @param tokenIndexTo the token the user wants to swap to\n   * @param dx the amount of tokens the user wants to swap from\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @param deadline latest timestamp to accept this transaction\n   */\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountIn the amount of tokens the user wants to swap from\n   * @param minAmountOut the min amount of tokens the user wants to swap to\n   */\n  function swapExact(\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external payable override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    uint8 tokenIndexFrom = getTokenIndex(assetIn);\n    uint8 tokenIndexTo = getTokenIndex(assetOut);\n    return swapStorage.swap(tokenIndexFrom, tokenIndexTo, amountIn, minAmountOut);\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountOut the amount of tokens the user wants to swap to\n   * @param maxAmountIn the max amount of tokens the user wants to swap from\n   */\n  function swapExactOut(\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external payable override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    uint8 tokenIndexFrom = getTokenIndex(assetIn);\n    uint8 tokenIndexTo = getTokenIndex(assetOut);\n    return swapStorage.swapOut(tokenIndexFrom, tokenIndexTo, amountOut, maxAmountIn);\n  }\n\n  /**\n   * @notice Add liquidity to the pool with the given amounts of tokens\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP token user minted and received\n   */\n  function addLiquidity(\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    return swapStorage.addLiquidity(amounts, minToMint);\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   *        acceptable for this burn. Useful as a front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amounts of tokens user received\n   */\n  function removeLiquidity(\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256[] memory) {\n    return swapStorage.removeLiquidity(amount, minAmounts);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param tokenAmount the amount of the token you want to receive\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of chosen token user received\n   */\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    return swapStorage.removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP tokens burned\n   */\n  function removeLiquidityImbalance(\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external override nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\n    return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Withdraw all admin fees to the contract owner\n   */\n  function withdrawAdminFees() external nonReentrant onlyOwner {\n    swapStorage.withdrawAdminFees(owner());\n  }\n\n  /**\n   * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n   * @param newAdminFee new admin fee to be applied on future transactions\n   */\n  function setAdminFee(uint256 newAdminFee) external onlyOwner {\n    swapStorage.setAdminFee(newAdminFee);\n  }\n\n  /**\n   * @notice Update the swap fee to be applied on swaps\n   * @param newSwapFee new swap fee to be applied on future transactions\n   */\n  function setSwapFee(uint256 newSwapFee) external onlyOwner {\n    swapStorage.setSwapFee(newSwapFee);\n  }\n\n  /**\n   * @notice Start ramping up or down A parameter towards given futureA and futureTime\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\n   * the limit range.\n   * @param futureA the new A to ramp towards\n   * @param futureTime timestamp when the new A should be reached\n   */\n  function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\n    swapStorage.rampA(futureA, futureTime);\n  }\n\n  /**\n   * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n   */\n  function stopRampA() external onlyOwner {\n    swapStorage.stopRampA();\n  }\n\n  // ============ Upgrade Gap ============\n  uint256[48] private __GAP; // gap for upgrade safety\n}\n"
    },
    "contracts/core/connext/helpers/OwnerPausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @title OwnerPausable\n * @notice An ownable contract allows the owner to pause and unpause the\n * contract without a delay.\n * @dev Only methods using the provided modifiers will be paused.\n */\nabstract contract OwnerPausableUpgradeable is OwnableUpgradeable, PausableUpgradeable {\n  // ============ Initializer ============\n\n  function __OwnerPausable_init() internal onlyInitializing {\n    __Context_init_unchained();\n    __Ownable_init_unchained();\n    __Pausable_init_unchained();\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Pause the contract. Revert if already paused.\n   */\n  function pause() external onlyOwner {\n    PausableUpgradeable._pause();\n  }\n\n  /**\n   * @notice Unpause the contract. Revert if already unpaused.\n   */\n  function unpause() external onlyOwner {\n    PausableUpgradeable._unpause();\n  }\n\n  // ============ Upgrade Gap ============\n  uint256[50] private __GAP; // gap for upgrade safety\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/core/connext/facets/StableSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {AmplificationUtils, SwapUtils} from \"../libraries/AmplificationUtils.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\n/**\n * @title Swap - A StableSwap implementation in solidity.\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\n * Users can burn pool tokens and withdraw their share of token(s).\n *\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\n * distributed to the LPs.\n *\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\n * stops the ratio of the tokens in the pool from changing.\n *\n * Users can always withdraw their tokens via multi-asset withdraws.\n *\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of contract readability.\n */\ncontract StableSwapFacet is BaseConnextFacet {\n  using SwapUtils for SwapUtils.Swap;\n  using AmplificationUtils for SwapUtils.Swap;\n\n  // ========== Custom Errors ===========\n  error StableSwapFacet__deadlineCheck_deadlineNotMet();\n  error StableSwapFacet__getSwapToken_outOfRange();\n  error StableSwapFacet__getSwapTokenIndex_notExist();\n  error StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n\n  // ============ Properties ============\n\n  // ============ Events ============\n  event TokenSwap(\n    bytes32 indexed key,\n    address indexed buyer,\n    uint256 tokensSold,\n    uint256 tokensBought,\n    uint128 soldId,\n    uint128 boughtId\n  );\n  event AddLiquidity(\n    bytes32 indexed key,\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event RemoveLiquidity(bytes32 indexed key, address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\n  event RemoveLiquidityOne(\n    bytes32 indexed key,\n    address indexed provider,\n    uint256 lpTokenAmount,\n    uint256 lpTokenSupply,\n    uint256 boughtId,\n    uint256 tokensBought\n  );\n  event RemoveLiquidityImbalance(\n    bytes32 indexed key,\n    address indexed provider,\n    uint256[] tokenAmounts,\n    uint256[] fees,\n    uint256 invariant,\n    uint256 lpTokenSupply\n  );\n  event NewAdminFee(bytes32 indexed key, uint256 newAdminFee);\n  event NewSwapFee(bytes32 indexed key, uint256 newSwapFee);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Modifier to check deadline against current timestamp\n   * @param deadline latest timestamp to accept this transaction\n   */\n  modifier deadlineCheck(uint256 deadline) {\n    if (block.timestamp > deadline) revert StableSwapFacet__deadlineCheck_deadlineNotMet();\n    _;\n  }\n\n  // ============ View Functions ============\n  /**\n   * @notice Return Stable swap storage\n   * @param key Hash of the canonical id + domain\n   * @return SwapUtils.Swap\n   */\n  function getSwapStorage(bytes32 key) external view returns (SwapUtils.Swap memory) {\n    return s.swapStorages[key];\n  }\n\n  /**\n   * @notice Return LP token for canonical Id\n   * @param key Hash of the canonical id + domain\n   * @return LPToken\n   */\n  function getSwapLPToken(bytes32 key) external view returns (address) {\n    return address(s.swapStorages[key].lpToken);\n  }\n\n  /**\n   * @notice Return A, the amplification coefficient * n ** (n - 1)\n   * @dev See the StableSwap paper for details\n   * @param key Hash of the canonical id + domain\n   * @return A parameter\n   */\n  function getSwapA(bytes32 key) external view returns (uint256) {\n    return s.swapStorages[key].getA();\n  }\n\n  /**\n   * @notice Return A in its raw precision form\n   * @dev See the StableSwap paper for details\n   * @param key Hash of the canonical id + domain\n   * @return A parameter in its raw precision form\n   */\n  function getSwapAPrecise(bytes32 key) external view returns (uint256) {\n    return s.swapStorages[key].getAPrecise();\n  }\n\n  /**\n   * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\n   * @param key Hash of the canonical id + domain\n   * @param index the index of the token\n   * @return address of the token at given index\n   */\n  function getSwapToken(bytes32 key, uint8 index) public view returns (IERC20) {\n    if (index >= s.swapStorages[key].pooledTokens.length) revert StableSwapFacet__getSwapToken_outOfRange();\n    return s.swapStorages[key].pooledTokens[index];\n  }\n\n  /**\n   * @notice Return the index of the given token address. Reverts if no matching\n   * token is found.\n   * @param key Hash of the canonical id + domain\n   * @param tokenAddress address of the token\n   * @return the index of the given token address\n   */\n  function getSwapTokenIndex(bytes32 key, address tokenAddress) public view returns (uint8) {\n    uint8 index = s.tokenIndexes[key][tokenAddress];\n    if (address(getSwapToken(key, index)) != tokenAddress) revert StableSwapFacet__getSwapTokenIndex_notExist();\n    return index;\n  }\n\n  /**\n   * @notice Return current balance of the pooled token at given index\n   * @param key Hash of the canonical id + domain\n   * @param index the index of the token\n   * @return current balance of the pooled token at given index with token's native precision\n   */\n  function getSwapTokenBalance(bytes32 key, uint8 index) external view returns (uint256) {\n    if (index >= s.swapStorages[key].balances.length) revert StableSwapFacet__getSwapTokenBalance_indexOutOfRange();\n    return s.swapStorages[key].balances[index];\n  }\n\n  /**\n   * @notice Get the virtual price, to help calculate profit\n   * @param key Hash of the canonical id + domain\n   * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\n   */\n  function getSwapVirtualPrice(bytes32 key) external view returns (uint256) {\n    return s.swapStorages[key].getVirtualPrice();\n  }\n\n  /**\n   * @notice Calculate amount of tokens you receive on swap\n   * @param key Hash of the canonical id + domain\n   * @param tokenIndexFrom the token the user wants to sell\n   * @param tokenIndexTo the token the user wants to buy\n   * @param dx the amount of tokens the user wants to sell. If the token charges\n   * a fee on transfers, use the amount that gets transferred after the fee.\n   * @return amount of tokens the user will receive\n   */\n  function calculateSwap(\n    bytes32 key,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256) {\n    return s.swapStorages[key].calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\n  }\n\n  /**\n   * @notice A simple method to calculate prices from deposits or\n   * withdrawals, excluding fees but including slippage. This is\n   * helpful as an input into the various \"min\" parameters on calls\n   * to fight front-running\n   *\n   * @dev This shouldn't be used outside frontends for user estimates.\n   *\n   * @param key Hash of the canonical id + domain\n   * @param amounts an array of token amounts to deposit or withdrawal,\n   * corresponding to pooledTokens. The amount should be in each\n   * pooled token's native precision. If a token charges a fee on transfers,\n   * use the amount that gets transferred after the fee.\n   * @param deposit whether this is a deposit or a withdrawal\n   * @return token amount the user will receive\n   */\n  function calculateSwapTokenAmount(\n    bytes32 key,\n    uint256[] calldata amounts,\n    bool deposit\n  ) external view returns (uint256) {\n    return s.swapStorages[key].calculateTokenAmount(amounts, deposit);\n  }\n\n  /**\n   * @notice A simple method to calculate amount of each underlying\n   * tokens that is returned upon burning given amount of LP tokens\n   * @param key Hash of the canonical id + domain\n   * @param amount the amount of LP tokens that would be burned on withdrawal\n   * @return array of token balances that the user will receive\n   */\n  function calculateRemoveSwapLiquidity(bytes32 key, uint256 amount) external view returns (uint256[] memory) {\n    return s.swapStorages[key].calculateRemoveLiquidity(amount);\n  }\n\n  /**\n   * @notice Calculate the amount of underlying token available to withdraw\n   * when withdrawing via only single token\n   * @param key Hash of the canonical id + domain\n   * @param tokenAmount the amount of LP token to burn\n   * @param tokenIndex index of which token will be withdrawn\n   * @return availableTokenAmount calculated amount of underlying token\n   * available to withdraw\n   */\n  function calculateRemoveSwapLiquidityOneToken(\n    bytes32 key,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount) {\n    return s.swapStorages[key].calculateWithdrawOneToken(tokenAmount, tokenIndex);\n  }\n\n  /**\n   * @notice This function reads the accumulated amount of admin fees of the token with given index\n   * @param key Hash of the canonical id + domain\n   * @param index Index of the pooled token\n   * @return admin's token balance in the token's precision\n   */\n  function getSwapAdminBalance(bytes32 key, uint256 index) external view returns (uint256) {\n    return s.swapStorages[key].getAdminBalance(index);\n  }\n\n  /*** STATE MODIFYING FUNCTIONS ***/\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param key Hash of the canonical id + domain\n   * @param tokenIndexFrom the token the user wants to swap from\n   * @param tokenIndexTo the token the user wants to swap to\n   * @param dx the amount of tokens the user wants to swap from\n   * @param minDy the min amount the user would like to receive, or revert.\n   * @param deadline latest timestamp to accept this transaction\n   */\n  function swap(\n    bytes32 key,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[key].swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param key Hash of the canonical id + domain\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountIn the amount of tokens the user wants to swap from\n   */\n  function swapExact(\n    bytes32 key,\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return\n      s.swapStorages[key].swap(\n        getSwapTokenIndex(key, assetIn),\n        getSwapTokenIndex(key, assetOut),\n        amountIn,\n        minAmountOut\n      );\n  }\n\n  /**\n   * @notice Swap two tokens using this pool\n   * @param key Hash of the canonical id + domain\n   * @param assetIn the token the user wants to swap from\n   * @param assetOut the token the user wants to swap to\n   * @param amountOut the amount of tokens the user wants to swap to\n   */\n  function swapExactOut(\n    bytes32 key,\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return\n      s.swapStorages[key].swapOut(\n        getSwapTokenIndex(key, assetIn),\n        getSwapTokenIndex(key, assetOut),\n        amountOut,\n        maxAmountIn\n      );\n  }\n\n  /**\n   * @notice Add liquidity to the pool with the given amounts of tokens\n   * @param key Hash of the canonical id + domain\n   * @param amounts the amounts of each token to add, in their native precision\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\n   * should mint, otherwise revert. Handy for front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP token user minted and received\n   */\n  function addSwapLiquidity(\n    bytes32 key,\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[key].addLiquidity(amounts, minToMint);\n  }\n\n  /**\n   * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @dev Liquidity can always be removed, even when the pool is paused.\n   * @param key Hash of the canonical id + domain\n   * @param amount the amount of LP tokens to burn\n   * @param minAmounts the minimum amounts of each token in the pool\n   *        acceptable for this burn. Useful as a front-running mitigation\n   * @param deadline latest timestamp to accept this transaction\n   * @return amounts of tokens user received\n   */\n  function removeSwapLiquidity(\n    bytes32 key,\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256[] memory) {\n    return s.swapStorages[key].removeLiquidity(amount, minAmounts);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param key Hash of the canonical id + domain\n   * @param tokenAmount the amount of the token you want to receive\n   * @param tokenIndex the index of the token you want to receive\n   * @param minAmount the minimum amount to withdraw, otherwise revert\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of chosen token user received\n   */\n  function removeSwapLiquidityOneToken(\n    bytes32 key,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[key].removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\n  }\n\n  /**\n   * @notice Remove liquidity from the pool, weighted differently than the\n   * pool's current balances. Withdraw fee that decays linearly\n   * over period of 4 weeks since last deposit will apply.\n   * @param key Hash of the canonical id + domain\n   * @param amounts how much of each token to withdraw\n   * @param maxBurnAmount the max LP token provider is willing to pay to\n   * remove liquidity. Useful as a front-running mitigation.\n   * @param deadline latest timestamp to accept this transaction\n   * @return amount of LP tokens burned\n   */\n  function removeSwapLiquidityImbalance(\n    bytes32 key,\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external nonReentrant deadlineCheck(deadline) whenNotPaused returns (uint256) {\n    return s.swapStorages[key].removeLiquidityImbalance(amounts, maxBurnAmount);\n  }\n}\n"
    },
    "contracts/core/connext/interfaces/IConnext.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ExecuteArgs, TransferInfo, DestinationTransferStatus} from \"../libraries/LibConnextStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {SwapUtils} from \"../libraries/SwapUtils.sol\";\nimport {TokenId} from \"../libraries/TokenId.sol\";\n\nimport {IStableSwap} from \"./IStableSwap.sol\";\n\nimport {IDiamondCut} from \"./IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"./IDiamondLoupe.sol\";\n\ninterface IConnext is IDiamondLoupe, IDiamondCut {\n  // TokenFacet\n  function canonicalToAdopted(bytes32 _key) external view returns (address);\n\n  function canonicalToAdopted(TokenId calldata _canonical) external view returns (address);\n\n  function adoptedToCanonical(address _adopted) external view returns (TokenId memory);\n\n  function canonicalToRepresentation(bytes32 _key) external view returns (address);\n\n  function canonicalToRepresentation(TokenId calldata _canonical) external view returns (address);\n\n  function representationToCanonical(address _adopted) external view returns (TokenId memory);\n\n  function getLocalAndAdoptedToken(bytes32 _id, uint32 _domain) external view returns (address, address);\n\n  function approvedAssets(bytes32 _key) external view returns (bool);\n\n  function approvedAssets(TokenId calldata _canonical) external view returns (bool);\n\n  function adoptedToLocalExternalPools(bytes32 _key) external view returns (IStableSwap);\n\n  function adoptedToLocalExternalPools(TokenId calldata _canonical) external view returns (IStableSwap);\n\n  function getTokenId(address _candidate) external view returns (TokenId memory);\n\n  function setupAsset(\n    TokenId calldata _canonical,\n    uint8 _canonicalDecimals,\n    string memory _representationName,\n    string memory _representationSymbol,\n    address _adoptedAssetId,\n    address _stableSwapPool,\n    uint256 _cap\n  ) external returns (address);\n\n  function setupAssetWithDeployedRepresentation(\n    TokenId calldata _canonical,\n    address _representation,\n    address _adoptedAssetId,\n    address _stableSwapPool\n  ) external returns (address);\n\n  function addStableSwapPool(TokenId calldata _canonical, address _stableSwapPool) external;\n\n  function updateLiquidityCap(TokenId calldata _canonical, uint256 _updated) external;\n\n  function removeAssetId(\n    bytes32 _key,\n    address _adoptedAssetId,\n    address _representation\n  ) external;\n\n  function removeAssetId(\n    TokenId calldata _canonical,\n    address _adoptedAssetId,\n    address _representation\n  ) external;\n\n  function updateDetails(\n    TokenId calldata _canonical,\n    string memory _name,\n    string memory _symbol\n  ) external;\n\n  // BaseConnextFacet\n\n  // BridgeFacet\n  function routedTransfers(bytes32 _transferId) external view returns (address[] memory);\n\n  function transferStatus(bytes32 _transferId) external view returns (DestinationTransferStatus);\n\n  function remote(uint32 _domain) external view returns (address);\n\n  function domain() external view returns (uint256);\n\n  function nonce() external view returns (uint256);\n\n  function approvedSequencers(address _sequencer) external view returns (bool);\n\n  function xAppConnectionManager() external view returns (address);\n\n  function addConnextion(uint32 _domain, address _connext) external;\n\n  function addSequencer(address _sequencer) external;\n\n  function removeSequencer(address _sequencer) external;\n\n  function xcall(\n    uint32 _destination,\n    address _to,\n    address _asset,\n    address _delegate,\n    uint256 _amount,\n    uint256 _slippage,\n    bytes calldata _callData\n  ) external payable returns (bytes32);\n\n  function xcallIntoLocal(\n    uint32 _destination,\n    address _to,\n    address _asset,\n    address _delegate,\n    uint256 _amount,\n    uint256 _slippage,\n    bytes calldata _callData\n  ) external payable returns (bytes32);\n\n  function execute(ExecuteArgs calldata _args) external returns (bytes32 transferId);\n\n  function forceUpdateSlippage(TransferInfo calldata _params, uint256 _slippage) external;\n\n  function forceReceiveLocal(TransferInfo calldata _params) external;\n\n  function bumpTransfer(bytes32 _transferId) external payable;\n\n  function setXAppConnectionManager(address _xAppConnectionManager) external;\n\n  function enrollRemoteRouter(uint32 _domain, bytes32 _router) external;\n\n  function enrollCustom(\n    uint32 _domain,\n    bytes32 _id,\n    address _custom\n  ) external;\n\n  // InboxFacet\n\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external;\n\n  // ProposedOwnableFacet\n\n  function owner() external view returns (address);\n\n  function routerAllowlistRemoved() external view returns (bool);\n\n  function proposed() external view returns (address);\n\n  function proposedTimestamp() external view returns (uint256);\n\n  function routerAllowlistTimestamp() external view returns (uint256);\n\n  function delay() external view returns (uint256);\n\n  function proposeRouterAllowlistRemoval() external;\n\n  function removeRouterAllowlist() external;\n\n  function proposeNewOwner(address newlyProposed) external;\n\n  function acceptProposedOwner() external;\n\n  function pause() external;\n\n  function unpause() external;\n\n  // RelayerFacet\n  function approvedRelayers(address _relayer) external view returns (bool);\n\n  function relayerFeeVault() external view returns (address);\n\n  function setRelayerFeeVault(address _relayerFeeVault) external;\n\n  function addRelayer(address _relayer) external;\n\n  function removeRelayer(address _relayer) external;\n\n  // RoutersFacet\n  function LIQUIDITY_FEE_NUMERATOR() external view returns (uint256);\n\n  function LIQUIDITY_FEE_DENOMINATOR() external view returns (uint256);\n\n  function getRouterApproval(address _router) external view returns (bool);\n\n  function getRouterRecipient(address _router) external view returns (address);\n\n  function getRouterOwner(address _router) external view returns (address);\n\n  function getProposedRouterOwner(address _router) external view returns (address);\n\n  function getProposedRouterOwnerTimestamp(address _router) external view returns (uint256);\n\n  function maxRoutersPerTransfer() external view returns (uint256);\n\n  function routerBalances(address _router, address _asset) external view returns (uint256);\n\n  function getRouterApprovalForPortal(address _router) external view returns (bool);\n\n  function approveRouter(address router) external;\n\n  function initializeRouter(address owner, address recipient) external;\n\n  function unapproveRouter(address router) external;\n\n  function setMaxRoutersPerTransfer(uint256 _newMaxRouters) external;\n\n  function setLiquidityFeeNumerator(uint256 _numerator) external;\n\n  function approveRouterForPortal(address _router) external;\n\n  function unapproveRouterForPortal(address _router) external;\n\n  function setRouterRecipient(address router, address recipient) external;\n\n  function proposeRouterOwner(address router, address proposed) external;\n\n  function acceptProposedRouterOwner(address router) external;\n\n  function addRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address _router\n  ) external payable;\n\n  function addRouterLiquidity(uint256 _amount, address _local) external payable;\n\n  function removeRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address payable _to,\n    address _router\n  ) external;\n\n  function removeRouterLiquidity(\n    uint256 _amount,\n    address _local,\n    address payable _to\n  ) external;\n\n  // PortalFacet\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256);\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256);\n\n  function aavePool() external view returns (address);\n\n  function aavePortalFee() external view returns (uint256);\n\n  function setAavePool(address _aavePool) external;\n\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external;\n\n  function repayAavePortal(\n    TransferInfo calldata _params,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn\n  ) external;\n\n  function repayAavePortalFor(\n    TransferInfo calldata _params,\n    uint256 _backingAmount,\n    uint256 _feeAmount\n  ) external;\n\n  // StableSwapFacet\n  function getSwapStorage(bytes32 canonicalId) external view returns (SwapUtils.Swap memory);\n\n  function getSwapLPToken(bytes32 canonicalId) external view returns (address);\n\n  function getSwapA(bytes32 canonicalId) external view returns (uint256);\n\n  function getSwapAPrecise(bytes32 canonicalId) external view returns (uint256);\n\n  function getSwapToken(bytes32 canonicalId, uint8 index) external view returns (IERC20);\n\n  function getSwapTokenIndex(bytes32 canonicalId, address tokenAddress) external view returns (uint8);\n\n  function getSwapTokenBalance(bytes32 canonicalId, uint8 index) external view returns (uint256);\n\n  function getSwapVirtualPrice(bytes32 canonicalId) external view returns (uint256);\n\n  function calculateSwap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateSwapTokenAmount(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    bool deposit\n  ) external view returns (uint256);\n\n  function calculateRemoveSwapLiquidity(bytes32 canonicalId, uint256 amount) external view returns (uint256[] memory);\n\n  function calculateRemoveSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256);\n\n  function getSwapAdminBalance(bytes32 canonicalId, uint256 index) external view returns (uint256);\n\n  function swap(\n    bytes32 canonicalId,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function swapExact(\n    bytes32 canonicalId,\n    uint256 amountIn,\n    address assetIn,\n    address assetOut,\n    uint256 minAmountOut,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function swapExactOut(\n    bytes32 canonicalId,\n    uint256 amountOut,\n    address assetIn,\n    address assetOut,\n    uint256 maxAmountIn,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  function addSwapLiquidity(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeSwapLiquidity(\n    bytes32 canonicalId,\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function removeSwapLiquidityOneToken(\n    bytes32 canonicalId,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeSwapLiquidityImbalance(\n    bytes32 canonicalId,\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  // SwapAdminFacet\n\n  function initializeSwap(\n    bytes32 _canonicalId,\n    IERC20[] memory _pooledTokens,\n    uint8[] memory decimals,\n    string memory lpTokenName,\n    string memory lpTokenSymbol,\n    uint256 _a,\n    uint256 _fee,\n    uint256 _adminFee\n  ) external;\n\n  function withdrawSwapAdminFees(bytes32 canonicalId) external;\n\n  function setSwapAdminFee(bytes32 canonicalId, uint256 newAdminFee) external;\n\n  function setSwapFee(bytes32 canonicalId, uint256 newSwapFee) external;\n\n  function rampA(\n    bytes32 canonicalId,\n    uint256 futureA,\n    uint256 futureTime\n  ) external;\n\n  function stopRampA(bytes32 canonicalId) external;\n\n  function lpTokenTargetAddress() external view returns (address);\n\n  function updateLpTokenTarget(address newAddress) external;\n}\n"
    },
    "contracts/core/connext/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions.\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n  // Diamond Loupe Functions\n  ////////////////////////////////////////////////////////////////////\n  /// These functions are expected to be called frequently by tools.\n  //\n  // struct Facet {\n  //     address facetAddress;\n  //     bytes4[] functionSelectors;\n  // }\n\n  /// @notice Gets all facets and their selectors.\n  /// @return facets_ Facet\n  function facets() external view override returns (Facet[] memory facets_) {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    uint256 numFacets = ds.facetAddresses.length;\n    facets_ = new Facet[](numFacets);\n    for (uint256 i; i < numFacets; ) {\n      address facetAddress_ = ds.facetAddresses[i];\n      facets_[i].facetAddress = facetAddress_;\n      facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /// @notice Gets all the function selectors provided by a facet.\n  /// @param _facet The facet address.\n  /// @return facetFunctionSelectors_\n  function facetFunctionSelectors(address _facet)\n    external\n    view\n    override\n    returns (bytes4[] memory facetFunctionSelectors_)\n  {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n  }\n\n  /// @notice Get all the facet addresses used by a diamond.\n  /// @return facetAddresses_\n  function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    facetAddresses_ = ds.facetAddresses;\n  }\n\n  /// @notice Gets the facet that supports the given selector.\n  /// @dev If facet is not found return address(0).\n  /// @param _functionSelector The function selector.\n  /// @return facetAddress_ The facet address.\n  function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n  }\n\n  // This implements ERC-165.\n  function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n    return ds.supportedInterfaces[_interfaceId];\n  }\n}\n"
    },
    "contracts/core/connext/helpers/ConnextDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\n\ncontract ConnextDiamond {\n  struct Initialization {\n    address initContract;\n    bytes initData;\n  }\n\n  /// @notice This construct a diamond contract\n  /// @param _contractOwner the owner of the contract. With default DiamondCutFacet, this is the sole address allowed to make further cuts.\n  /// @param _diamondCut the list of facet to add\n  /// @param _initializations the list of initialization pair to execute. This allow to setup a contract with multiple level of independent initialization.\n  constructor(\n    address _contractOwner,\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    Initialization[] memory _initializations\n  ) payable {\n    if (_contractOwner != address(0)) {\n      LibDiamond.setContractOwner(_contractOwner);\n    }\n\n    LibDiamond.diamondCut(_diamondCut, address(0), \"\");\n\n    uint256 len = _initializations.length;\n    for (uint256 i = 0; i < len; ) {\n      LibDiamond.initializeDiamondCut(_initializations[i].initContract, _initializations[i].initData);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  // Find facet for function that is called and execute the\n  // function if a facet is found and return any value.\n  fallback() external payable {\n    LibDiamond.DiamondStorage storage ds;\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n    // get diamond storage\n    assembly {\n      ds.slot := position\n    }\n    // get facet from function selector\n    address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n    require(facet != address(0), \"Diamond: Function does not exist\");\n    // Execute external function from facet using delegatecall and return any value.\n    assembly {\n      // copy function selector and any arguments\n      calldatacopy(0, 0, calldatasize())\n      // execute function call using the facet\n      let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n      // get any return value\n      returndatacopy(0, 0, returndatasize())\n      // return any return value or error back to the caller\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  receive() external payable {}\n}\n"
    },
    "contracts/core/connext/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n  /// @notice Add/replace/remove any number of functions and optionally execute\n  ///         a function with delegatecall\n  /// @param _diamondCut Contains the facet addresses and function selectors\n  /// @param _init The address of the contract or facet to execute _calldata\n  /// @param _calldata A function call, including function selector and arguments\n  ///                  _calldata is executed with delegatecall on _init\n  function diamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external override {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.diamondCut(_diamondCut, _init, _calldata);\n  }\n\n  function proposeDiamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.proposeDiamondCut(_diamondCut, _init, _calldata);\n  }\n\n  function rescindDiamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external {\n    LibDiamond.enforceIsContractOwner();\n    LibDiamond.rescindDiamondCut(_diamondCut, _init, _calldata);\n  }\n\n  function getAcceptanceTime(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external view returns (uint256) {\n    return LibDiamond.acceptanceTime(keccak256(abi.encode(_diamondCut, _init, _calldata)));\n  }\n}\n"
    },
    "contracts/core/connext/facets/ProposedOwnableFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {Role} from \"../libraries/LibConnextStorage.sol\";\nimport {IProposedOwnable} from \"../../../shared/interfaces/IProposedOwnable.sol\";\n\n/**\n * @title ProposedOwnableFacet\n * @notice Contract module which provides a basic access control mechanism,\n * where there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed via a two step process:\n * 1. Call `proposeOwner`\n * 2. Wait out the delay period\n * 3. Call `acceptOwner`\n *\n * @dev This module is used through inheritance. It will make available the\n * modifier `onlyOwner`, which can be applied to your functions to restrict\n * their use to the owner.\n *\n * @dev The majority of this code was taken from the openzeppelin Ownable\n * contract\n *\n */\ncontract ProposedOwnableFacet is BaseConnextFacet, IProposedOwnable {\n  // ========== Custom Errors ===========\n  error ProposedOwnableFacet__delayElapsed_delayNotElapsed();\n  error ProposedOwnableFacet__proposeRouterAllowlistRemoval_noOwnershipChange();\n  error ProposedOwnableFacet__removeRouterAllowlist_noOwnershipChange();\n  error ProposedOwnableFacet__removeRouterAllowlist_noProposal();\n  error ProposedOwnableFacet__proposeAssetAllowlistRemoval_noOwnershipChange();\n  error ProposedOwnableFacet__removeAssetAllowlist_noOwnershipChange();\n  error ProposedOwnableFacet__removeAssetAllowlist_noProposal();\n  error ProposedOwnableFacet__proposeNewOwner_invalidProposal();\n  error ProposedOwnableFacet__proposeNewOwner_noOwnershipChange();\n  error ProposedOwnableFacet__acceptProposedOwner_noOwnershipChange();\n  error ProposedOwnableFacet__revokeRole_invalidInput();\n  error ProposedOwnableFacet__assignRoleRouter_invalidInput();\n  error ProposedOwnableFacet__assignRoleWatcher_invalidInput();\n  error ProposedOwnableFacet__assignRoleAdmin_invalidInput();\n\n  // ============ Events ============\n\n  event RouterAllowlistRemovalProposed(uint256 timestamp);\n\n  event RouterAllowlistRemoved(bool renounced);\n\n  event RevokeRole(address revokedAddress, Role revokedRole);\n\n  event AssignRoleRouter(address router);\n\n  event AssignRoleWatcher(address watcher);\n\n  event AssignRoleAdmin(address admin);\n\n  event Paused();\n\n  event Unpaused();\n\n  // ============ Modifier ============\n  /**\n   * @notice Reverts the call if the expected delay has not elapsed.\n   * @param start Timestamp marking the beginning of the delay period.\n   */\n  modifier delayElapsed(uint256 start) {\n    // Ensure delay has elapsed\n    if ((block.timestamp - start) <= delay()) revert ProposedOwnableFacet__delayElapsed_delayNotElapsed();\n    _;\n  }\n\n  // ============ External: Getters ============\n\n  /**\n   * @notice Returns the address of the current owner.\n   */\n  function owner() public view returns (address) {\n    return LibDiamond.contractOwner();\n  }\n\n  /**\n   * @notice Returns if the router allowlist is removed.\n   */\n  function routerAllowlistRemoved() public view returns (bool) {\n    return s._routerAllowlistRemoved;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposed() public view returns (address) {\n    return s._proposed;\n  }\n\n  /**\n   * @notice Returns the address of the proposed owner.\n   */\n  function proposedTimestamp() public view returns (uint256) {\n    return s._proposedOwnershipTimestamp;\n  }\n\n  /**\n   * @notice Returns the timestamp when router allowlist was last proposed to be removed\n   */\n  function routerAllowlistTimestamp() public view returns (uint256) {\n    return s._routerAllowlistTimestamp;\n  }\n\n  /**\n   * @notice Returns the delay period before a new owner can be accepted.\n   */\n  function delay() public view returns (uint256) {\n    return LibDiamond.acceptanceDelay();\n  }\n\n  /**\n   * @notice Returns the Role of the address\n   * @dev returns uint value of representing enum value of Role\n   * @param _role The address for which Role need to be queried\n   */\n  function queryRole(address _role) public view returns (Role) {\n    return s.roles[_role];\n  }\n\n  // ============ External ============\n\n  /**\n   * @notice Indicates if the ownership of the router allowlist has\n   * been renounced\n   */\n  function proposeRouterAllowlistRemoval() public onlyOwnerOrAdmin {\n    // Use contract as source of truth\n    // Will fail if all ownership is renounced by modifier\n    if (s._routerAllowlistRemoved) revert ProposedOwnableFacet__proposeRouterAllowlistRemoval_noOwnershipChange();\n\n    // Begin delay, emit event\n    _setRouterAllowlistTimestamp();\n  }\n\n  /**\n   * @notice Indicates if the ownership of the asset allowlist has\n   * been renounced\n   */\n  function removeRouterAllowlist() public onlyOwnerOrAdmin delayElapsed(s._routerAllowlistTimestamp) {\n    // Contract as sounce of truth\n    // Will fail if all ownership is renounced by modifier\n    if (s._routerAllowlistRemoved) revert ProposedOwnableFacet__removeRouterAllowlist_noOwnershipChange();\n\n    // Ensure there has been a proposal cycle started\n    if (s._routerAllowlistTimestamp == 0) revert ProposedOwnableFacet__removeRouterAllowlist_noProposal();\n\n    // Set renounced, emit event, reset timestamp to 0\n    _setRouterAllowlistRemoved(true);\n  }\n\n  /**\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\n   * newly proposed owner as step 1 in a 2-step process\n   */\n  function proposeNewOwner(address newlyProposed) public onlyOwner {\n    // Contract as source of truth\n    if (s._proposed == newlyProposed || newlyProposed == address(0))\n      revert ProposedOwnableFacet__proposeNewOwner_invalidProposal();\n\n    // Sanity check: reasonable proposal\n    if (owner() == newlyProposed) revert ProposedOwnableFacet__proposeNewOwner_noOwnershipChange();\n\n    _setProposed(newlyProposed);\n  }\n\n  /**\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the proposed owner.\n   */\n  function acceptProposedOwner() public onlyProposed delayElapsed(s._proposedOwnershipTimestamp) {\n    // Contract as source of truth\n    if (owner() == s._proposed) revert ProposedOwnableFacet__acceptProposedOwner_noOwnershipChange();\n\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\n    // the only time this would happen is if the _proposed was never\n    // set (will fail from modifier) or if the owner == _proposed (checked\n    // above)\n\n    // Emit event, set new owner, reset timestamp\n    _setOwner(s._proposed);\n  }\n\n  /**\n   * @notice Use to revoke the Role of an address to None\n   * Can only be called by Owner or Role.Admin\n   * @dev input address will be assingned default value i.e Role.None under mapping roles\n   * @param _revoke - The address to be revoked from it's Role\n   */\n  function revokeRole(address _revoke) public onlyOwnerOrAdmin {\n    // Use contract as source of truth\n    // Will fail if candidate isn't assinged any Role OR input address is addressZero\n    Role revokedRole = s.roles[_revoke];\n    if (revokedRole == Role.None || _revoke == address(0)) revert ProposedOwnableFacet__revokeRole_invalidInput();\n\n    s.roles[_revoke] = Role.None;\n    emit RevokeRole(_revoke, revokedRole);\n  }\n\n  /**\n   * @notice Use to assign an address Router role\n   * Address with Router has permission to add new router\n   * Can only be called by Owner or Role.RouterAdmin\n   * @dev requested address will be whitelisted as Role.RouterAdmin under mapping roles\n   * @param _router - The address to be assigned as Role.RouterAdmin under roles\n   */\n  function assignRoleRouterAdmin(address _router) public onlyOwnerOrAdmin {\n    // Use contract as source of truth\n    // Will fail if candidate is already added OR input address is addressZero\n    if (s.roles[_router] != Role.None || _router == address(0))\n      revert ProposedOwnableFacet__assignRoleRouter_invalidInput();\n\n    s.roles[_router] = Role.RouterAdmin;\n    emit AssignRoleRouter(_router);\n  }\n\n  /**\n   * @notice Use to assign an address Watcher role\n   * Address with Watcher role has permission to pause\n   * Can only be called by Owner or Role.Admin\n   * @dev requested address will be allowlisted as Role.Watcher under mapping roles\n   * @param _watcher - The address to be assigned as Role.Watcher under roles\n   */\n  function assignRoleWatcher(address _watcher) public onlyOwnerOrAdmin {\n    // Use contract as source of truth\n    // Will fail if candidate is already added OR input address is addressZero\n    if (s.roles[_watcher] != Role.None || _watcher == address(0))\n      revert ProposedOwnableFacet__assignRoleWatcher_invalidInput();\n\n    s.roles[_watcher] = Role.Watcher;\n    emit AssignRoleWatcher(_watcher);\n  }\n\n  /**\n   * @notice Use to assign an address Admin role\n   * Address with Admin role has permission to all else of Router & Watcher role\n   * Can only be called by Owner or Role.Admin\n   * @dev requested address will be allowlisted as Role.Admin under mapping roles\n   * @param _admin - The address to beassigned as Role.Admin under roles\n   */\n  function assignRoleAdmin(address _admin) public onlyOwnerOrAdmin {\n    // Use contract as source of truth\n    // Will fail if candidate is already added OR input address is addressZero\n    if (s.roles[_admin] != Role.None || _admin == address(0))\n      revert ProposedOwnableFacet__assignRoleAdmin_invalidInput();\n\n    s.roles[_admin] = Role.Admin;\n    emit AssignRoleAdmin(_admin);\n  }\n\n  function pause() public onlyOwnerOrWatcher {\n    s._paused = true;\n    emit Paused();\n  }\n\n  function unpause() public onlyOwnerOrAdmin {\n    delete s._paused;\n    emit Unpaused();\n  }\n\n  ////// INTERNAL //////\n\n  function _setRouterAllowlistTimestamp() private {\n    s._routerAllowlistTimestamp = block.timestamp;\n    emit RouterAllowlistRemovalProposed(block.timestamp);\n  }\n\n  function _setRouterAllowlistRemoved(bool value) private {\n    s._routerAllowlistRemoved = value;\n    delete s._routerAllowlistTimestamp;\n    emit RouterAllowlistRemoved(value);\n  }\n\n  function _setOwner(address newOwner) private {\n    delete s._proposedOwnershipTimestamp;\n    delete s._proposed;\n    LibDiamond.setContractOwner(newOwner);\n  }\n\n  function _setProposed(address newlyProposed) private {\n    s._proposedOwnershipTimestamp = block.timestamp;\n    s._proposed = newlyProposed;\n    emit OwnershipProposed(newlyProposed);\n  }\n}\n"
    },
    "contracts/core/connext/helpers/RelayerProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {GelatoRelayFeeCollector} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol\";\n\nimport {ProposedOwnable} from \"../../../shared/ProposedOwnable.sol\";\nimport {IConnext, ExecuteArgs} from \"../interfaces/IConnext.sol\";\n\ninterface ISpokeConnector {\n  struct Proof {\n    bytes message;\n    bytes32[32] path;\n    uint256 index;\n  }\n\n  function proveAndProcess(\n    Proof[] calldata _proofs,\n    bytes32 _aggregateRoot,\n    bytes32[32] calldata _aggregatePath,\n    uint256 _aggregateIndex\n  ) external;\n\n  function send(bytes memory _encodedData) external payable;\n}\n\n/**\n * @title RelayerProxy\n * @author Connext Labs, Inc.\n * @notice This is a temporary contract that wraps fast path functions in the Connext interface so that they can be called by\n * Gelato's legacy relayer network. The contract stores native assets and pays them to the relayer on function call.\n */\ncontract RelayerProxy is ProposedOwnable, ReentrancyGuard, GelatoRelayFeeCollector {\n  // ============ Properties ============\n  address public gelatoRelayer;\n  address public feeCollector;\n  IConnext public connext;\n  ISpokeConnector public spokeConnector;\n\n  mapping(address => bool) public allowedRelayer;\n\n  // ============ Modifier ============\n\n  modifier onlyRelayer() {\n    require(allowedRelayer[msg.sender], \"!relayer\");\n    _;\n  }\n\n  modifier definedAddress(address _input) {\n    require(_input != address(0), \"empty\");\n    _;\n  }\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when funds added to the contract\n   * @param amount The amount added\n   * @param balance The updated balance of the contract\n   */\n  event FundsReceived(uint256 amount, uint256 balance);\n\n  /**\n   * @notice Emitted when funds removed from the contract by admin\n   * @param amount The amount removed\n   * @param balance The updated balance of the contract\n   */\n  event FundsDeducted(uint256 amount, uint256 balance);\n\n  /**\n   * @notice Emitted when a new relayer is allowlisted by admin\n   * @param relayer Address of the added relayer\n   */\n  event RelayerAdded(address relayer);\n\n  /**\n   * @notice Emitted when a relayer is removed from allowlist by admin\n   * @param relayer Address of the removed relayer\n   */\n  event RelayerRemoved(address relayer);\n\n  /**\n   * @notice Emitted when Connext contract address is updated by admin\n   * @param updated New Connext address in the contract\n   * @param previous Old Connext address in the contract\n   */\n  event ConnextChanged(address updated, address previous);\n\n  /**\n   * @notice Emitted when SpokeConnector contract address is updated by admin\n   * @param updated New SpokeConnector address in the contract\n   * @param previous Old SpokeConnector address in the contract\n   */\n  event SpokeConnectorChanged(address updated, address previous);\n\n  /**\n   * @notice Emitted when GelatoRelayer address is updated by admin\n   * @param updated New GelatoRelayer address in the contract\n   * @param previous Old Gelatorelayer address in the contract\n   */\n  event GelatoRelayerChanged(address updated, address previous);\n\n  /**\n   * @notice Emitted when FeeCollectorChanged address is updated by admin\n   * @param updated New FeeCollectorChanged address in the contract\n   * @param previous Old FeeCollectorChanged address in the contract\n   */\n  event FeeCollectorChanged(address updated, address previous);\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new RelayerProxy instance.\n   * @param _connext The address of the Connext on this domain.\n   * @param _spokeConnector The address of the SpokeConnector on this domain.\n   * @param _gelatoRelayer The address of the Gelato relayer on this domain.\n   * @param _feeCollector The address of the Gelato Fee Collector on this domain.\n   */\n  constructor(\n    address _connext,\n    address _spokeConnector,\n    address _gelatoRelayer,\n    address _feeCollector\n  ) ProposedOwnable() {\n    _setOwner(msg.sender);\n    _setConnext(_connext);\n    _setSpokeConnector(_spokeConnector);\n    _setGelatoRelayer(_gelatoRelayer);\n    _setFeeCollector(_feeCollector);\n\n    _addRelayer(_gelatoRelayer);\n  }\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Adds a relayer address to the allowed relayers mapping.\n   *\n   * @param _relayer - Relayer address to add.\n   */\n  function addRelayer(address _relayer) external onlyOwner definedAddress(_relayer) {\n    _addRelayer(_relayer);\n  }\n\n  /**\n   * @notice Removes a relayer address from the allowed relayers mapping.\n   *\n   * @param _relayer - Relayer address to remove.\n   */\n  function removeRelayer(address _relayer) external onlyOwner definedAddress(_relayer) {\n    _removeRelayer(_relayer);\n  }\n\n  /**\n   * @notice Updates the Connext address on this contract.\n   *\n   * @param _connext - New Connext address.\n   */\n  function setConnext(address _connext) external onlyOwner definedAddress(_connext) {\n    _setConnext(_connext);\n  }\n\n  /**\n   * @notice Updates the SpokeConnector address on this contract.\n   *\n   * @param _spokeConnector - New SpokeConnector address.\n   */\n  function setSpokeConnector(address _spokeConnector) external onlyOwner definedAddress(_spokeConnector) {\n    _setSpokeConnector(_spokeConnector);\n  }\n\n  /**\n   * @notice Updates the Gelato relayer address on this contract.\n   *\n   * @param _gelatoRelayer - New Gelato relayer address.\n   */\n  function setGelatoRelayer(address _gelatoRelayer) external onlyOwner definedAddress(_gelatoRelayer) {\n    _setGelatoRelayer(_gelatoRelayer);\n  }\n\n  /**\n   * @notice Updates the Gelato Fee Collector address on this contract.\n   *\n   * @param _feeCollector - New Gelato Fee Collector address.\n   */\n  function setFeeCollector(address _feeCollector) external onlyOwner definedAddress(_feeCollector) {\n    _setFeeCollector(_feeCollector);\n  }\n\n  /**\n   * @notice Withdraws all funds stored on this contract to msg.sender.\n   */\n  function withdraw() external onlyOwner nonReentrant {\n    uint256 balance = address(this).balance;\n    Address.sendValue(payable(msg.sender), balance);\n    emit FundsDeducted(balance, address(this).balance);\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Wraps the call to execute() on Connext and pays either the caller or hardcoded relayer from this\n   * contract's balance for completing the transaction.\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @param _fee - Fee to be paid to relayer.\n   * @return transferId - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args, uint256 _fee)\n    external\n    onlyRelayer\n    nonReentrant\n    returns (bytes32 transferId)\n  {\n    transferId = connext.execute(_args);\n    transferRelayerFee(_fee);\n  }\n\n  /**\n   * @notice Wraps the call to proveAndProcess() on SpokeConnector and pays either the caller or hardcoded relayer\n   * from this contract's balance for completing the transaction.\n   *\n   * @param _proofs Batch of Proofs containing messages for proving/processing.\n   * @param _aggregateRoot The target aggregate root we want to prove inclusion for. This root must have\n   * already been delivered to this spoke connector contract and surpassed the validation period.\n   * @param _aggregatePath Merkle path of inclusion for the inbound root.\n   * @param _aggregateIndex Index of the inbound root in the aggregator's merkle tree in the hub.\n   * @param _fee - Fee to be paid to relayer.\n   */\n  function proveAndProcess(\n    ISpokeConnector.Proof[] calldata _proofs,\n    bytes32 _aggregateRoot,\n    bytes32[32] calldata _aggregatePath,\n    uint256 _aggregateIndex,\n    uint256 _fee\n  ) external onlyRelayer nonReentrant {\n    spokeConnector.proveAndProcess(_proofs, _aggregateRoot, _aggregatePath, _aggregateIndex);\n    transferRelayerFee(_fee);\n  }\n\n  /**\n   * @notice Wraps the call to send() on SpokeConnector and pays either the caller or hardcoded relayer from this\n   * contract's balance for completing the transaction.\n   *\n   * @param _encodedData - Data to be sent to Connext SpokeConnector\n   * @param _messageFee - Fee to be paid to the SpokeConnector for connected AMBs that require fees.\n   * @param _relayerFee - Fee to be paid to relayer.\n   */\n  function send(\n    bytes memory _encodedData,\n    uint256 _messageFee,\n    uint256 _relayerFee\n  ) external onlyRelayer nonReentrant {\n    spokeConnector.send{value: _messageFee}(_encodedData);\n    emit FundsDeducted(_messageFee, address(this).balance);\n    transferRelayerFee(_relayerFee);\n  }\n\n  receive() external payable {\n    emit FundsReceived(msg.value, address(this).balance);\n  }\n\n  // ============ Internal Functions ============\n\n  /**\n   * @notice helper function to transfer fees to either Gelato relayer via Fee Collector or to our\n   * backup relayer (msg.sender).\n   *\n   * @param _fee - Fee to be paid to relayer.\n   */\n  function transferRelayerFee(uint256 _fee) internal {\n    if (msg.sender == gelatoRelayer) {\n      Address.sendValue(payable(feeCollector), _fee);\n    } else {\n      Address.sendValue(payable(msg.sender), _fee);\n    }\n    emit FundsDeducted(_fee, address(this).balance);\n  }\n\n  function _addRelayer(address _relayer) internal {\n    require(!allowedRelayer[_relayer], \"added\");\n\n    allowedRelayer[_relayer] = true;\n    emit RelayerAdded(_relayer);\n  }\n\n  function _removeRelayer(address _relayer) internal {\n    require(allowedRelayer[_relayer], \"!added\");\n\n    allowedRelayer[_relayer] = false;\n    emit RelayerRemoved(_relayer);\n  }\n\n  function _setConnext(address _connext) internal {\n    emit ConnextChanged(_connext, address(connext));\n    connext = IConnext(_connext);\n  }\n\n  function _setSpokeConnector(address _spokeConnector) internal {\n    emit SpokeConnectorChanged(_spokeConnector, address(spokeConnector));\n    spokeConnector = ISpokeConnector(_spokeConnector);\n  }\n\n  function _setGelatoRelayer(address _gelatoRelayer) internal {\n    emit GelatoRelayerChanged(_gelatoRelayer, address(gelatoRelayer));\n    gelatoRelayer = _gelatoRelayer;\n  }\n\n  function _setFeeCollector(address _feeCollector) internal {\n    emit FeeCollectorChanged(_feeCollector, address(feeCollector));\n    feeCollector = _feeCollector;\n  }\n}\n"
    },
    "@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nimport {GelatoRelayBase} from \"./base/GelatoRelayBase.sol\";\n\n// WARNING: Do not use this free fn by itself, always inherit GelatoRelayFeeCollector\n// solhint-disable-next-line func-visibility, private-vars-leading-underscore\nfunction __getFeeCollector() pure returns (address feeCollector) {\n    assembly {\n        feeCollector := shr(96, calldataload(sub(calldatasize(), 20)))\n    }\n}\n\n/**\n * @dev Context variant with only feeCollector appended to msg.data\n * Expects calldata encoding:\n *   abi.encodePacked(bytes data, address feeCollectorAddress)\n * Therefore, we're expecting 20bytes to be appended to normal msgData\n * 20bytes start offsets from calldatasize:\n *    feeCollector: -20\n */\n/// @dev Do not use with GelatoRelayFeeCollector - pick only one\nabstract contract GelatoRelayFeeCollector is GelatoRelayBase {\n    // Do not confuse with OZ Context.sol _msgData()\n    function __msgData() internal view returns (bytes calldata) {\n        return\n            _isGelatoRelay(msg.sender)\n                ? msg.data[:msg.data.length - 20]\n                : msg.data;\n    }\n\n    // Only use with GelatoRelayBase onlyGelatoRelay or `_isGelatoRelay` checks\n    function _getFeeCollector() internal pure returns (address) {\n        return __getFeeCollector();\n    }\n}\n"
    },
    "@gelatonetwork/relay-context/contracts/base/GelatoRelayBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\nimport {GELATO_RELAY} from \"../constants/GelatoRelay.sol\";\n\nabstract contract GelatoRelayBase {\n    modifier onlyGelatoRelay() {\n        require(\n            _isGelatoRelay(msg.sender),\n            \"GelatoRelayContext.onlyGelatoRelay\"\n        );\n        _;\n    }\n\n    function _isGelatoRelay(address _forwarder) internal pure returns (bool) {\n        return _forwarder == GELATO_RELAY;\n    }\n}\n"
    },
    "@gelatonetwork/relay-context/contracts/constants/GelatoRelay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.1;\n\naddress constant GELATO_RELAY = 0xaBcC9b596420A9E9172FD5938620E265a0f9Df92;\n"
    },
    "contracts/core/connext/helpers/RelayerProxyHub.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {GelatoRelayFeeCollector} from \"@gelatonetwork/relay-context/contracts/GelatoRelayFeeCollector.sol\";\n\nimport {ProposedOwnable} from \"../../../shared/ProposedOwnable.sol\";\nimport {IRootManager} from \"../../../messaging/interfaces/IRootManager.sol\";\nimport {RelayerProxy} from \"./RelayerProxy.sol\";\n\n/**\n * @title RelayerProxyHub\n * @author Connext Labs, Inc.\n * @notice This is a temporary contract that wraps the Connext RootManager's propagate() function so that it can be called by\n * Gelato's legacy relayer network. The contract stores native assets and pays them to the relayer on function call.\n */\ncontract RelayerProxyHub is RelayerProxy {\n  // ============ Properties ============\n\n  IRootManager public rootManager;\n\n  // ============ Events ============\n  event RootManagerChanged(address rootManager, address oldRootManager);\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Creates a new RelayerProxyHub instance.\n   * @param _connext The address of the Connext on this domain.\n   * @param _spokeConnector The address of the SpokeConnector on this domain.\n   * @param _gelatoRelayer The address of the Gelato relayer on this domain.\n   * @param _feeCollector The address of the Gelato Fee Collector on this domain.\n   * @param _rootManager The address of the Root Manager on this domain.\n   */\n  constructor(\n    address _connext,\n    address _spokeConnector,\n    address _gelatoRelayer,\n    address _feeCollector,\n    address _rootManager\n  ) RelayerProxy(_connext, _spokeConnector, _gelatoRelayer, _feeCollector) {\n    _setRootManager(_rootManager);\n  }\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Updates the RootManager address.\n   * @param _rootManager The address of the new RootManager on this domain.\n   */\n  function setRootManager(address _rootManager) external onlyOwner definedAddress(_rootManager) {\n    _setRootManager(_rootManager);\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Wraps the call to propagate() on RootManager and pays either the caller or hardcoded relayer\n   * from this contract's balance for completing the transaction.\n   *\n   * @param _connectors Array of connectors: should match exactly the array of `connectors` in storage;\n   * used here to reduce gas costs, and keep them static regardless of number of supported domains.\n   * @param _messageFees Array of fees in native token for an AMB if required\n   * @param _encodedData Array of encodedData: extra params for each AMB if required\n   * @param _relayerFee Fee to be paid to relayer\n   */\n  function propagate(\n    address[] calldata _connectors,\n    uint256[] calldata _messageFees,\n    bytes[] memory _encodedData,\n    uint256 _relayerFee\n  ) external onlyRelayer nonReentrant {\n    uint256 sum = 0;\n    uint256 length = _connectors.length;\n    for (uint32 i; i < length; ) {\n      sum += _messageFees[i];\n      unchecked {\n        ++i;\n      }\n    }\n\n    rootManager.propagate{value: sum}(_connectors, _messageFees, _encodedData);\n    emit FundsDeducted(sum, address(this).balance);\n    transferRelayerFee(_relayerFee);\n  }\n\n  // ============ Internal Functions ============\n  function _setRootManager(address _rootManager) internal {\n    emit RootManagerChanged(_rootManager, address(rootManager));\n    rootManager = IRootManager(_rootManager);\n  }\n}\n"
    },
    "contracts/core/connext/helpers/ConnextPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IPriceOracle} from \"../interfaces/IPriceOracle.sol\";\n\nimport {Constants} from \"../libraries/Constants.sol\";\n\nimport {ProposedOwnable} from \"../../../shared/ProposedOwnable.sol\";\nimport {PriceOracle} from \"./PriceOracle.sol\";\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\n/**\n * @title ConnextPriceOracle\n * @notice Simple interface for querying a variety of price feeds\n *\n * @dev If ownership is renounced, the direct price, aggregators, and price oracles\n * can no longer be updated\n */\ncontract ConnextPriceOracle is PriceOracle, ProposedOwnable {\n  address public wrapped;\n  address public v1PriceOracle;\n\n  /// @notice Price sources\n  enum PriceSource {\n    NA,\n    DIRECT,\n    CHAINLINK,\n    V1_ORACLE\n  }\n\n  /// @notice Chainlink Aggregators\n  mapping(address => AggregatorV3Interface) public aggregators;\n\n  struct Price {\n    uint256 updatedAt;\n    uint256 price;\n  }\n\n  mapping(address => Price) public assetPrices;\n\n  event DirectPriceUpdated(address token, uint256 oldPrice, uint256 newPrice);\n  event AggregatorUpdated(address tokenAddress, address source);\n  event V1PriceOracleUpdated(address oldAddress, address newAddress);\n\n  constructor(address _wrapped) {\n    require(_wrapped != address(0), \"zero wrapped address!\");\n\n    wrapped = _wrapped;\n    _setOwner(msg.sender);\n  }\n\n  function getTokenPrice(address _tokenAddress) public view override returns (uint256, uint256) {\n    address tokenAddress = _tokenAddress;\n\n    // For native tokens, get price of the wrapped token\n    if (_tokenAddress == address(0)) {\n      tokenAddress = wrapped;\n    }\n\n    // First check the direct price which stored in contract. Only owner can set direct price.\n    uint256 tokenPrice = assetPrices[tokenAddress].price;\n    // only accept up to and not including Constants.ORACLE_VALID_PERIOD time deviation\n    if (tokenPrice != 0 && ((block.timestamp - assetPrices[tokenAddress].updatedAt) < Constants.ORACLE_VALID_PERIOD)) {\n      return (tokenPrice, uint256(PriceSource.DIRECT));\n    }\n\n    // Second, check ChainLink aggregator, If current token is supported by chainlink, return\n    tokenPrice = getPriceFromOracle(tokenAddress);\n    if (tokenPrice != 0) {\n      return (tokenPrice, uint256(PriceSource.CHAINLINK));\n    }\n\n    // Third, If v1 oracle price contract is set, check v1 price\n    if (v1PriceOracle != address(0)) {\n      tokenPrice = IPriceOracle(v1PriceOracle).getTokenPrice(tokenAddress);\n      if (tokenPrice != 0) {\n        return (tokenPrice, uint256(PriceSource.V1_ORACLE));\n      }\n    }\n\n    return (0, uint256(PriceSource.NA));\n  }\n\n  function getPriceFromOracle(address _tokenAddress) public view returns (uint256) {\n    uint256 chainLinkPrice = getPriceFromChainlink(_tokenAddress);\n    return chainLinkPrice;\n  }\n\n  function getPriceFromChainlink(address _tokenAddress) public view returns (uint256) {\n    AggregatorV3Interface aggregator = aggregators[_tokenAddress];\n    if (address(aggregator) != address(0)) {\n      try aggregator.latestRoundData() returns (\n        uint80 roundId,\n        int256 answer,\n        uint256,\n        uint256 updateAt,\n        uint80 answeredInRound\n      ) {\n        // It's fine for price to be 0. We have more price feeds.\n        if (\n          answer == 0 ||\n          answeredInRound < roundId ||\n          updateAt == 0 ||\n          block.timestamp > updateAt + Constants.ORACLE_VALID_PERIOD\n        ) {\n          // answeredInRound > roundId ===> ChainLink Error: Stale price\n          // updatedAt = 0 ===> ChainLink Error: Round not complete\n          // block.timestamp - updateAt > Constants.ORACLE_VALID_PERIOD ===> too old data\n          return 0;\n        }\n\n        uint256 retVal = uint256(answer);\n        uint256 price;\n        // Make the decimals to 1e18.\n        uint256 aggregatorDecimals = uint256(aggregator.decimals());\n        if (aggregatorDecimals > Constants.DEFAULT_NORMALIZED_DECIMALS) {\n          price = retVal / (10**(aggregatorDecimals - Constants.DEFAULT_NORMALIZED_DECIMALS));\n        } else {\n          price = retVal * (10**(Constants.DEFAULT_NORMALIZED_DECIMALS - aggregatorDecimals));\n        }\n\n        return price;\n      } catch {\n        // return 0 to be able to fetch the price from next oracles\n        return 0;\n      }\n    }\n\n    return 0;\n  }\n\n  function setDirectPrice(\n    address _token,\n    uint256 _price,\n    uint256 _timestamp\n  ) external onlyOwner {\n    require(_price != 0, \"bad price\");\n    if (block.timestamp > _timestamp) {\n      // reject stale price\n      require(block.timestamp - _timestamp < Constants.ORACLE_VALID_PERIOD, \"bad timestamp\");\n    } else {\n      // reject future timestamp (<3s is allowed)\n      require(_timestamp - block.timestamp < Constants.FUTURE_TIME_BUFFER, \"in future\");\n      _timestamp = block.timestamp;\n    }\n\n    emit DirectPriceUpdated(_token, assetPrices[_token].price, _price);\n\n    assetPrices[_token].price = _price;\n    assetPrices[_token].updatedAt = _timestamp;\n  }\n\n  function setV1PriceOracle(address _v1PriceOracle) external onlyOwner {\n    emit V1PriceOracleUpdated(v1PriceOracle, _v1PriceOracle);\n    v1PriceOracle = _v1PriceOracle;\n  }\n\n  function setAggregators(address[] calldata tokenAddresses, address[] calldata sources) external onlyOwner {\n    uint256 numTokens = tokenAddresses.length;\n    for (uint256 i; i < numTokens; ) {\n      aggregators[tokenAddresses[i]] = AggregatorV3Interface(sources[i]);\n      emit AggregatorUpdated(tokenAddresses[i], sources[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n}\n"
    },
    "contracts/core/connext/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IPriceOracle {\n  /**\n   * @notice Get the price of a token\n   * @param token The token to get the price of\n   * @return The asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getTokenPrice(address token) external view returns (uint256);\n\n  /**\n   * @notice Get the price of a token from ChainLink\n   * @param token The token to get the price of\n   * @return The asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getPriceFromChainlink(address token) external view returns (uint256);\n}\n"
    },
    "contracts/core/connext/helpers/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nabstract contract PriceOracle {\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  bool public constant isPriceOracle = true;\n\n  /**\n   * @notice Get the price of a token\n   * @param token The token to get the price of\n   * @return The asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   * @return The source of the price. enum (NA, DIRECT, CHAINLINK, DEX, V1_ORACLE)\n   */\n  function getTokenPrice(address token) external view virtual returns (uint256, uint256);\n}\n"
    },
    "contracts/core/connext/facets/RoutersFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {TypeCasts} from \"../../../shared/libraries/TypeCasts.sol\";\n\nimport {Constants} from \"../libraries/Constants.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {RouterConfig} from \"../libraries/LibConnextStorage.sol\";\nimport {TokenId} from \"../libraries/TokenId.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\n/**\n * @notice\n * This contract is designed to manage router access, meaning it maintains the\n * router recipients, owners, and the router allowlist itself.\n *\n * As a router, there are three important permissions:\n * `router` - this is the address that will sign bids sent to the sequencer\n * `routerRecipient` - this is the address that receives funds when liquidity is withdrawn\n * `routerOwner` - this is the address permitted to update recipients and propose new owners\n *\n * In cases where the owner is not set, the caller should be the `router` itself. In cases where the\n * `routerRecipient` is not set, the funds can be removed to anywhere.\n *\n * When setting a new `routerOwner`, the current owner (or router) must create a proposal, which\n * can be accepted by the proposed owner after the delay period. If the proposed owner is the empty\n * address, then it must be accepted by the current owner.\n */\ncontract RoutersFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error RoutersFacet__acceptProposedRouterOwner_notElapsed();\n  error RoutersFacet__acceptProposedRouterOwner_badCaller();\n  error RoutersFacet__initializeRouter_configNotEmpty();\n  error RoutersFacet__setRouterRecipient_notNewRecipient();\n  error RoutersFacet__onlyRouterOwner_notRouterOwner();\n  error RoutersFacet__unapproveRouter_routerEmpty();\n  error RoutersFacet__unapproveRouter_notAdded();\n  error RoutersFacet__approveRouter_routerEmpty();\n  error RoutersFacet__approveRouter_alreadyAdded();\n  error RoutersFacet__proposeRouterOwner_notNewOwner();\n  error RoutersFacet__proposeRouterOwner_badRouter();\n  error RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\n  error RoutersFacet__addLiquidityForRouter_routerEmpty();\n  error RoutersFacet__addLiquidityForRouter_amountIsZero();\n  error RoutersFacet__addLiquidityForRouter_badRouter();\n  error RoutersFacet__addLiquidityForRouter_capReached();\n  error RoutersFacet__removeRouterLiquidity_recipientEmpty();\n  error RoutersFacet__removeRouterLiquidity_amountIsZero();\n  error RoutersFacet__removeRouterLiquidity_insufficientFunds();\n  error RoutersFacet__removeRouterLiquidityFor_notOwner();\n  error RoutersFacet__setLiquidityFeeNumerator_tooSmall();\n  error RoutersFacet__setLiquidityFeeNumerator_tooLarge();\n  error RoutersFacet__approveRouterForPortal_notAdded();\n  error RoutersFacet__approveRouterForPortal_alreadyApproved();\n  error RoutersFacet__unapproveRouterForPortal_notApproved();\n  error RoutersFacet__setRouterOwner_noChange();\n\n  // ============ Properties ============\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new router is added\n   * @param router - The address of the added router\n   * @param caller - The account that called the function\n   */\n  event RouterAdded(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when an existing router is removed\n   * @param router - The address of the removed router\n   * @param caller - The account that called the function\n   */\n  event RouterRemoved(address indexed router, address caller);\n\n  /**\n   * @notice Emitted when the recipient of router is updated\n   * @param router - The address of the added router\n   * @param prevRecipient  - The address of the previous recipient of the router\n   * @param newRecipient  - The address of the new recipient of the router\n   */\n  event RouterRecipientSet(address indexed router, address indexed prevRecipient, address indexed newRecipient);\n\n  /**\n   * @notice Emitted when the owner of router is proposed\n   * @param router - The address of the added router\n   * @param prevProposed  - The address of the previous proposed\n   * @param newProposed  - The address of the new proposed\n   */\n  event RouterOwnerProposed(address indexed router, address indexed prevProposed, address indexed newProposed);\n\n  /**\n   * @notice Emitted when the owner of router is accepted\n   * @param router - The address of the added router\n   * @param prevOwner  - The address of the previous owner of the router\n   * @param newOwner  - The address of the new owner of the router\n   */\n  event RouterOwnerAccepted(address indexed router, address indexed prevOwner, address indexed newOwner);\n\n  /**\n   * @notice Emitted when a router adds a config via `addRouterConfig`\n   * @dev This does not confer permissions onto the router, only the configuration\n   * @param router The router initialized\n   *\n   */\n  event RouterInitialized(address indexed router);\n\n  /**\n   * @notice Emitted when the maxRoutersPerTransfer variable is updated\n   * @param maxRoutersPerTransfer - The maxRoutersPerTransfer new value\n   * @param caller - The account that called the function\n   */\n  event MaxRoutersPerTransferUpdated(uint256 maxRoutersPerTransfer, address caller);\n\n  /**\n   * @notice Emitted when the LIQUIDITY_FEE_NUMERATOR variable is updated\n   * @param liquidityFeeNumerator - The LIQUIDITY_FEE_NUMERATOR new value\n   * @param caller - The account that called the function\n   */\n  event LiquidityFeeNumeratorUpdated(uint256 liquidityFeeNumerator, address caller);\n\n  /**\n   * @notice Emitted when a router is approved for Portal\n   * @param router - The address of the approved router\n   * @param caller - The account that called the function\n   */\n  event RouterApprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router is disapproved for Portal\n   * @param router - The address of the disapproved router\n   * @param caller - The account that called the function\n   */\n  event RouterUnapprovedForPortal(address router, address caller);\n\n  /**\n   * @notice Emitted when a router adds liquidity to the contract\n   * @param router - The address of the router the funds were credited to\n   * @param local - The address of the token added (all liquidity held in local asset)\n   * @param key - The hash of the canonical id and domain\n   * @param amount - The amount of liquidity added\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityAdded(address indexed router, address local, bytes32 key, uint256 amount, address caller);\n\n  /**\n   * @notice Emitted when a router withdraws liquidity from the contract\n   * @param router - The router you are removing liquidity from\n   * @param to - The address the funds were withdrawn to\n   * @param local - The address of the token withdrawn\n   * @param amount - The amount of liquidity withdrawn\n   * @param caller - The account that called the function\n   */\n  event RouterLiquidityRemoved(\n    address indexed router,\n    address to,\n    address local,\n    bytes32 key,\n    uint256 amount,\n    address caller\n  );\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Asserts caller is the router owner\n   */\n  modifier onlyRouterOwner(address _router) {\n    if (s.routerConfigs[_router].owner != msg.sender) revert RoutersFacet__onlyRouterOwner_notRouterOwner();\n    _;\n  }\n\n  // ============ Getters ==============\n\n  function LIQUIDITY_FEE_NUMERATOR() public view returns (uint256) {\n    return s.LIQUIDITY_FEE_NUMERATOR;\n  }\n\n  function LIQUIDITY_FEE_DENOMINATOR() public pure returns (uint256) {\n    return Constants.BPS_FEE_DENOMINATOR;\n  }\n\n  /**\n   * @notice Returns the approved router for the given router address\n   * @param _router The relevant router address\n   */\n  function getRouterApproval(address _router) public view returns (bool) {\n    return s.routerConfigs[_router].approved;\n  }\n\n  /**\n   * @notice Returns the recipient for the specified router\n   * @dev The recipient (if set) receives all funds when router liquidity is removed\n   * @param _router The relevant router address\n   */\n  function getRouterRecipient(address _router) public view returns (address) {\n    return s.routerConfigs[_router].recipient;\n  }\n\n  /**\n   * @notice Returns the router owner if it is set, or the router itself if not\n   * @param _router The relevant router address\n   */\n  function getRouterOwner(address _router) public view returns (address) {\n    return s.routerConfigs[_router].owner;\n  }\n\n  /**\n   * @notice Returns the currently proposed router owner\n   * @dev All routers must wait for the delay timeout before accepting a new owner\n   * @param _router The relevant router address\n   */\n  function getProposedRouterOwner(address _router) public view returns (address) {\n    return s.routerConfigs[_router].proposed;\n  }\n\n  /**\n   * @notice Returns the currently proposed router owner timestamp\n   * @dev All routers must wait for the delay timeout before accepting a new owner\n   * @param _router The relevant router address\n   */\n  function getProposedRouterOwnerTimestamp(address _router) public view returns (uint256) {\n    return s.routerConfigs[_router].proposedTimestamp;\n  }\n\n  function maxRoutersPerTransfer() public view returns (uint256) {\n    return s.maxRoutersPerTransfer;\n  }\n\n  function routerBalances(address _router, address _asset) public view returns (uint256) {\n    return s.routerBalances[_router][_asset];\n  }\n\n  /**\n   * @notice Returns whether the router is approved for portals or not\n   * @param _router The relevant router address\n   */\n  function getRouterApprovalForPortal(address _router) public view returns (bool) {\n    return s.routerConfigs[_router].portalApproved;\n  }\n\n  // ============ Admin methods ==============\n\n  /**\n   * @notice Used to allowlist a given router\n   * @param _router Router address to setup\n   */\n  function approveRouter(address _router) external onlyOwnerOrRouter {\n    // Sanity check: not empty\n    if (_router == address(0)) revert RoutersFacet__approveRouter_routerEmpty();\n\n    // Sanity check: needs approval\n    if (s.routerConfigs[_router].approved) revert RoutersFacet__approveRouter_alreadyAdded();\n\n    // Approve router\n    s.routerConfigs[_router].approved = true;\n\n    // Emit event\n    emit RouterAdded(_router, msg.sender);\n  }\n\n  /**\n   * @notice Used to remove routers that can transact crosschain\n   * @param _router Router address to remove\n   */\n  function unapproveRouter(address _router) external onlyOwnerOrRouter {\n    // Sanity check: not empty\n    if (_router == address(0)) revert RoutersFacet__unapproveRouter_routerEmpty();\n\n    // Sanity check: needs removal\n    RouterConfig memory config = s.routerConfigs[_router];\n    if (!config.approved) revert RoutersFacet__unapproveRouter_notAdded();\n\n    // Update approvals in config mapping\n    delete s.routerConfigs[_router].approved;\n    delete s.routerConfigs[_router].portalApproved;\n\n    // Emit event\n    emit RouterRemoved(_router, msg.sender);\n  }\n\n  /**\n   * @notice Used to set the max amount of routers a payment can be routed through\n   * @param _newMaxRouters The new max amount of routers\n   */\n  function setMaxRoutersPerTransfer(uint256 _newMaxRouters) external onlyOwnerOrAdmin {\n    if (_newMaxRouters == 0 || _newMaxRouters == s.maxRoutersPerTransfer)\n      revert RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\n\n    emit MaxRoutersPerTransferUpdated(_newMaxRouters, msg.sender);\n\n    s.maxRoutersPerTransfer = _newMaxRouters;\n  }\n\n  /**\n   * @notice Sets the LIQUIDITY_FEE_NUMERATOR\n   * @dev Admin can set LIQUIDITY_FEE_NUMERATOR variable, Liquidity fee should be less than 5%\n   * @param _numerator new LIQUIDITY_FEE_NUMERATOR\n   */\n  function setLiquidityFeeNumerator(uint256 _numerator) external onlyOwnerOrAdmin {\n    // Slightly misleading: the liquidity fee numerator is not the amount charged,\n    // but the amount received after fees are deducted (e.g. 9995/10000 would be .005%).\n    uint256 denominator = Constants.BPS_FEE_DENOMINATOR;\n    if (_numerator < (denominator * 95) / 100) revert RoutersFacet__setLiquidityFeeNumerator_tooSmall();\n\n    if (_numerator > denominator) revert RoutersFacet__setLiquidityFeeNumerator_tooLarge();\n    s.LIQUIDITY_FEE_NUMERATOR = _numerator;\n\n    emit LiquidityFeeNumeratorUpdated(_numerator, msg.sender);\n  }\n\n  /**\n   * @notice Allow router to use Portals\n   * @param _router - The router address to approve\n   */\n  function approveRouterForPortal(address _router) external onlyOwnerOrAdmin {\n    RouterConfig memory config = s.routerConfigs[_router];\n    if (!config.approved && !_isRouterAllowlistRemoved()) revert RoutersFacet__approveRouterForPortal_notAdded();\n    if (config.portalApproved) revert RoutersFacet__approveRouterForPortal_alreadyApproved();\n\n    s.routerConfigs[_router].portalApproved = true;\n\n    emit RouterApprovedForPortal(_router, msg.sender);\n  }\n\n  /**\n   * @notice Remove router access to use Portals\n   * @param _router - The router address to remove approval\n   */\n  function unapproveRouterForPortal(address _router) external onlyOwnerOrAdmin {\n    if (!s.routerConfigs[_router].portalApproved) revert RoutersFacet__unapproveRouterForPortal_notApproved();\n\n    delete s.routerConfigs[_router].portalApproved;\n\n    emit RouterUnapprovedForPortal(_router, msg.sender);\n  }\n\n  // ============ Public methods ==============\n\n  /**\n   * @notice Sets the designated recipient for a router\n   * @dev Router should only be able to set this once otherwise if router key compromised,\n   * no problem is solved since attacker could just update recipient\n   * @param _router Router address to set recipient\n   * @param _recipient Recipient Address to set to router\n   */\n  function setRouterRecipient(address _router, address _recipient) external onlyRouterOwner(_router) {\n    _setRouterRecipient(_router, _recipient, s.routerConfigs[_router].recipient);\n  }\n\n  /**\n   * @notice Current owner or router may propose a new router owner\n   * @dev If routers burn their ownership, they can no longer update the recipient\n   * @param _router Router address to set recipient\n   * @param _proposed Proposed owner Address to set to router\n   */\n  function proposeRouterOwner(address _router, address _proposed) external onlyRouterOwner(_router) {\n    // NOTE: If routers burn their ownership, they can no longer update the recipient\n\n    // Check that proposed is different than current owner\n    RouterConfig memory config = s.routerConfigs[_router];\n    if (config.owner == _proposed) revert RoutersFacet__proposeRouterOwner_notNewOwner();\n\n    // Check that proposed is different than current proposed\n    if (config.proposed == _proposed) revert RoutersFacet__proposeRouterOwner_badRouter();\n\n    // Set proposed owner + timestamp\n    s.routerConfigs[_router].proposed = _proposed;\n    s.routerConfigs[_router].proposedTimestamp = block.timestamp;\n\n    // Emit event\n    emit RouterOwnerProposed(_router, config.proposed, _proposed);\n  }\n\n  /**\n   * @notice New router owner must accept role, or previous if proposed is 0x0\n   * @param _router Router address to set recipient\n   */\n  function acceptProposedRouterOwner(address _router) external {\n    RouterConfig memory config = s.routerConfigs[_router];\n\n    // Check timestamp has passed\n    if (block.timestamp - config.proposedTimestamp <= Constants.GOVERNANCE_DELAY)\n      revert RoutersFacet__acceptProposedRouterOwner_notElapsed();\n\n    // Check the caller\n    address expected = config.proposed == address(0) ? config.owner : config.proposed;\n    if (msg.sender != expected) {\n      revert RoutersFacet__acceptProposedRouterOwner_badCaller();\n    }\n\n    // Update the current owner\n    _setRouterOwner(_router, config.proposed, config.owner);\n\n    // Reset proposal + timestamp\n    if (config.proposed != address(0)) {\n      delete s.routerConfigs[_router].proposed;\n    }\n    delete s.routerConfigs[_router].proposedTimestamp;\n  }\n\n  /**\n   * @notice Can be called by anyone to set a config for their router (the msg.sender)\n   * @dev Does not set allowlisting permissions, only owner and recipient\n   * @param _owner The owner (can change recipient, proposes new owners)\n   * @param _recipient Where liquidity will be withdrawn to\n   */\n  function initializeRouter(address _owner, address _recipient) external {\n    // Ensure the config is empty\n    RouterConfig memory config = s.routerConfigs[msg.sender];\n    if (\n      config.owner != address(0) ||\n      config.recipient != address(0) ||\n      config.proposed != address(0) ||\n      config.proposedTimestamp > 0\n    ) {\n      revert RoutersFacet__initializeRouter_configNotEmpty();\n    }\n\n    // Default owner should be router\n    if (_owner == address(0)) {\n      _owner = msg.sender;\n    }\n    // Update routerOwner (zero address possible)\n    _setRouterOwner(msg.sender, _owner, address(0));\n\n    // Update router recipient (fine to have no recipient provided)\n    if (_recipient != address(0)) {\n      _setRouterRecipient(msg.sender, _recipient, address(0));\n    }\n\n    // Emit event\n    emit RouterInitialized(msg.sender);\n  }\n\n  /**\n   * @notice This is used by anyone to increase a router's available liquidity for a given asset.\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _router The router you are adding liquidity on behalf of\n   */\n  function addRouterLiquidityFor(\n    uint256 _amount,\n    address _local,\n    address _router\n  ) external payable nonReentrant whenNotPaused {\n    _addLiquidityForRouter(_amount, _local, _router);\n  }\n\n  /**\n   * @notice This is used by any router to increase their available liquidity for a given asset.\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\n   * native asset, routers may use `address(0)` or the wrapped asset\n   */\n  function addRouterLiquidity(uint256 _amount, address _local) external payable nonReentrant whenNotPaused {\n    _addLiquidityForRouter(_amount, _local, msg.sender);\n  }\n\n  /**\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\n   * @dev Using the `_canonical` information in the interface instead of the local asset to allow\n   * routers to remove liquidity even if the asset is delisted\n   * @param _canonical The canonical token information in plaintext\n   * @param _amount - The amount of liquidity to remove for the router\n   * native asset, routers may use `address(0)` or the wrapped asset\n   * @param _to The address that will receive the liquidity being removed\n   * @param _router The address of the router\n   */\n  function removeRouterLiquidityFor(\n    TokenId memory _canonical,\n    uint256 _amount,\n    address payable _to,\n    address _router\n  ) external nonReentrant whenNotPaused {\n    // Caller must be the router owner, if defined, else the router\n    address owner = s.routerConfigs[_router].owner;\n    address permissioned = owner == address(0) ? _router : owner;\n    if (msg.sender != permissioned) revert RoutersFacet__removeRouterLiquidityFor_notOwner();\n    // Remove liquidity\n    _removeLiquidityForRouter(_amount, _canonical, _to, _router);\n  }\n\n  /**\n   * @notice This is used by any router to decrease their available liquidity for a given asset.\n   * @dev Using the `_canonical` information in the interface instead of the local asset to allow\n   * routers to remove liquidity even if the asset is delisted\n   * @param _canonical The canonical token information in plaintext\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _to The address that will receive the liquidity being removed if no router recipient exists.\n   */\n  function removeRouterLiquidity(\n    TokenId memory _canonical,\n    uint256 _amount,\n    address payable _to\n  ) external nonReentrant whenNotPaused {\n    _removeLiquidityForRouter(_amount, _canonical, _to, msg.sender);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Sets the router recipient\n   * @param _router The router to set the recipient for\n   * @param _updated The recipient to set\n   * @param _previous The existing recipient\n   */\n  function _setRouterRecipient(\n    address _router,\n    address _updated,\n    address _previous\n  ) internal {\n    // Check recipient is changing\n    if (_previous == _updated) revert RoutersFacet__setRouterRecipient_notNewRecipient();\n\n    // Set new recipient\n    s.routerConfigs[_router].recipient = _updated;\n\n    // Emit event\n    emit RouterRecipientSet(_router, _previous, _updated);\n  }\n\n  /**\n   * @notice Sets the router owner\n   * @param _router The router to set the owner for\n   * @param _updated The owner to set\n   * @param _previous The existing owner\n   */\n  function _setRouterOwner(\n    address _router,\n    address _updated,\n    address _previous\n  ) internal {\n    // Check owner is changing\n    if (_previous == _updated) revert RoutersFacet__setRouterOwner_noChange();\n\n    // Set new owner\n    s.routerConfigs[_router].owner = _updated;\n\n    // Emit event\n    emit RouterOwnerAccepted(_router, _previous, _updated);\n  }\n\n  /**\n   * @notice Contains the logic to verify + increment a given routers liquidity\n   * @dev The liquidity will be held in the local asset, which is the representation if you\n   * are *not* on the canonical domain, and the canonical asset otherwise.\n   * @param _amount - The amount of liquidity to add for the router\n   * @param _local - The address of the bridge representation of the asset\n   * @param _router - The router you are adding liquidity on behalf of\n   */\n  function _addLiquidityForRouter(\n    uint256 _amount,\n    address _local,\n    address _router\n  ) internal {\n    // Sanity check: router is sensible.\n    if (_router == address(0)) revert RoutersFacet__addLiquidityForRouter_routerEmpty();\n\n    // Sanity check: nonzero amounts.\n    if (_amount == 0) revert RoutersFacet__addLiquidityForRouter_amountIsZero();\n\n    // Get the canonical asset ID from the representation.\n    // NOTE: not using `_getApprovedCanonicalId` because candidate can *only* be local\n    TokenId memory canonical = s.representationToCanonical[_local];\n    if (canonical.domain == 0 && canonical.id == bytes32(0)) {\n      // Assume you are on the canonical domain, which does not update the above mapping\n      // If this is an incorrect assumption, the approval should fail\n      canonical.domain = s.domain;\n      canonical.id = TypeCasts.addressToBytes32(_local);\n    }\n    bytes32 key = AssetLogic.calculateCanonicalHash(canonical.id, canonical.domain);\n    if (!s.tokenConfigs[key].approval) {\n      revert BaseConnextFacet__getApprovedCanonicalId_notAllowlisted();\n    }\n\n    // Sanity check: router is approved.\n    if (!_isRouterAllowlistRemoved() && !getRouterApproval(_router))\n      revert RoutersFacet__addLiquidityForRouter_badRouter();\n\n    // Transfer funds to contract.\n    AssetLogic.handleIncomingAsset(_local, _amount);\n\n    // Update the router balances. Happens after pulling funds to account for\n    // the fee on transfer tokens.\n    s.routerBalances[_router][_local] += _amount;\n\n    emit RouterLiquidityAdded(_router, _local, key, _amount, msg.sender);\n  }\n\n  /**\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\n   * @param _amount - The amount of liquidity to remove for the router\n   * @param _canonical The canonical token information in plaintext\n   * @param _to The address that will receive the liquidity being removed\n   * @param _router The address of the router\n   */\n  function _removeLiquidityForRouter(\n    uint256 _amount,\n    TokenId memory _canonical,\n    address payable _to,\n    address _router\n  ) internal {\n    // Transfer to specified recipient IF recipient not set.\n    address recipient = getRouterRecipient(_router);\n    recipient = recipient == address(0) ? _to : recipient;\n\n    // Sanity check: to is sensible.\n    if (recipient == address(0)) revert RoutersFacet__removeRouterLiquidity_recipientEmpty();\n\n    // Sanity check: nonzero amounts.\n    if (_amount == 0) revert RoutersFacet__removeRouterLiquidity_amountIsZero();\n\n    bool onCanonical = _canonical.domain == s.domain;\n\n    // Get the local asset from canonical\n    // NOTE: allow getting unapproved assets to prevent lockup on approval status change\n    // NOTE: not using `_getCanonicalTokenId` because candidate can *only* be local\n    bytes32 key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n    address local = onCanonical ? TypeCasts.bytes32ToAddress(_canonical.id) : s.tokenConfigs[key].representation;\n\n    // Get existing router balance.\n    uint256 routerBalance = s.routerBalances[_router][local];\n\n    // Sanity check: amount can be deducted for the router.\n    if (routerBalance < _amount) revert RoutersFacet__removeRouterLiquidity_insufficientFunds();\n\n    // Update router balances.\n    unchecked {\n      s.routerBalances[_router][local] = routerBalance - _amount;\n    }\n\n    // Transfer from contract to specified `to` address.\n    AssetLogic.handleOutgoingAsset(local, recipient, _amount);\n\n    emit RouterLiquidityRemoved(_router, recipient, local, key, _amount, msg.sender);\n  }\n}\n"
    },
    "contracts/core/connext/facets/PortalFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {Constants} from \"../libraries/Constants.sol\";\nimport {TransferInfo} from \"../libraries/LibConnextStorage.sol\";\n\ncontract PortalFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error PortalFacet__setAavePortalFee_invalidFee();\n  error PortalFacet__repayAavePortal_assetNotApproved();\n  error PortalFacet__repayAavePortal_insufficientFunds();\n  error PortalFacet__repayAavePortalFor_zeroAmount();\n  error PortalFacet__repayAavePortalFor_invalidAsset();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted `setAavePool` is updated\n   * @param updated - The updated address\n   * @param caller - The account that called the function\n   */\n  event AavePoolUpdated(address updated, address caller);\n\n  /**\n   * @notice Emitted `setAavePortalFee` is updated\n   * @param updated - The updated fee numerator\n   * @param caller - The account that called the function\n   */\n  event AavePortalFeeUpdated(uint256 updated, address caller);\n\n  /**\n   * @notice Emitted when a repayment on an Aave portal loan is made\n   * @param transferId - The transfer debt that was repaid\n   * @param asset - The asset that was repaid\n   * @param amount - The amount that was repaid\n   * @param fee - The fee amount that was repaid\n   */\n  event AavePortalRepayment(bytes32 indexed transferId, address asset, uint256 amount, uint256 fee, address caller);\n\n  // ============ Getters methods ==============\n\n  function getAavePortalDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalDebt[_transferId];\n  }\n\n  function getAavePortalFeeDebt(bytes32 _transferId) external view returns (uint256) {\n    return s.portalFeeDebt[_transferId];\n  }\n\n  function aavePool() external view returns (address) {\n    return s.aavePool;\n  }\n\n  function aavePortalFee() external view returns (uint256) {\n    return s.aavePortalFeeNumerator;\n  }\n\n  // ============ External functions ============\n\n  /**\n   * @notice Sets the Aave Pool contract address.\n   * @dev Allows to set the aavePool to address zero to disable Aave Portal if needed\n   * @param _aavePool The address of the Aave Pool contract\n   */\n  function setAavePool(address _aavePool) external onlyOwnerOrAdmin {\n    s.aavePool = _aavePool;\n    emit AavePoolUpdated(_aavePool, msg.sender);\n  }\n\n  /**\n   * @notice Sets the Aave Portal fee numerator\n   * @param _aavePortalFeeNumerator The new value for the Aave Portal fee numerator\n   */\n  function setAavePortalFee(uint256 _aavePortalFeeNumerator) external onlyOwnerOrAdmin {\n    if (_aavePortalFeeNumerator > Constants.BPS_FEE_DENOMINATOR) revert PortalFacet__setAavePortalFee_invalidFee();\n\n    s.aavePortalFeeNumerator = _aavePortalFeeNumerator;\n    emit AavePortalFeeUpdated(_aavePortalFeeNumerator, msg.sender);\n  }\n\n  /**\n   * @notice Used by routers to perform a manual repayment to Aave Portals to cover any outstanding debt\n   * @dev The router must be approved for portal and with enough liquidity, and must be the caller of this\n   * function. If the asset is not whitelisted, must use the `repayAavePortalFor` function.\n   * @param _params TransferInfo associated with the transfer\n   * @param _backingAmount The principle to be paid (in adopted asset)\n   * @param _feeAmount The fee to be paid (in adopted asset)\n   * @param _maxIn The max value of the local asset to swap for the _backingAmount of adopted asset\n   */\n  function repayAavePortal(\n    TransferInfo calldata _params,\n    uint256 _backingAmount,\n    uint256 _feeAmount,\n    uint256 _maxIn\n  ) external nonReentrant {\n    bytes32 key = AssetLogic.calculateCanonicalHash(_params.canonicalId, _params.canonicalDomain);\n\n    // Ensure the asset is approved\n    if (!s.tokenConfigs[key].approval) {\n      revert PortalFacet__repayAavePortal_assetNotApproved();\n    }\n\n    address local = _getLocalAsset(key, _params.canonicalId, _params.canonicalDomain);\n\n    uint256 routerBalance = s.routerBalances[msg.sender][local];\n    // Sanity check: has that much to spend\n    if (routerBalance < _maxIn) revert PortalFacet__repayAavePortal_insufficientFunds();\n\n    // Here, generate the transfer id. This allows us to ensure the `_local` asset\n    // is the correct one associated with the transfer. Otherwise, anyone could pay back\n    // the loan with the incorrect asset and remove the ability to transfer here. If the\n    // `_local` asset is incorrectly supplied, the generated transferId will also be\n    // incorrect, and the _backLoan call (which manipulates the debt stored) will fail.\n    // Another option is to store the asset associated with the transfer on `execute`, but\n    // this would make an already expensive call even more so.\n    bytes32 transferId = _calculateTransferId(_params);\n\n    // Need to swap into adopted asset or asset that was backing the loan\n    // The router will always be holding collateral in the local asset while the loaned asset\n    // is the adopted asset\n\n    // Swap for exact `totalRepayAmount` of adopted asset to repay aave\n    (uint256 amountDebited, address assetLoaned) = AssetLogic.swapFromLocalAssetIfNeededForExactOut(\n      key,\n      local,\n      _backingAmount + _feeAmount,\n      _maxIn\n    );\n\n    // decrement router balances\n    s.routerBalances[msg.sender][local] = routerBalance - amountDebited;\n\n    // back loan\n    _backLoan(assetLoaned, _backingAmount, _feeAmount, transferId);\n  }\n\n  /**\n   * @notice This allows anyone to repay the portal in the adopted asset for a given router\n   * and transfer\n   *\n   * @dev Should always be paying in the backing asset for the aave loan. NOTE: This will *NOT*\n   * work if an asset is removed.\n   *\n   * @param _params TransferInfo associated with the transfer\n   * @param _portalAsset The asset you borrowed (adopted asset)\n   * @param _backingAmount Amount of principle to repay\n   * @param _feeAmount Amount of fees to repay\n   */\n  function repayAavePortalFor(\n    TransferInfo calldata _params,\n    address _portalAsset,\n    uint256 _backingAmount,\n    uint256 _feeAmount\n  ) external payable nonReentrant {\n    // Get the adopted address\n    // NOTE: using storage directly because if `_getAdoptedAsset` is used, will revert if\n    // the asset is not whitelisted (and this fn should work if asset is removed)\n    address adopted = s\n      .tokenConfigs[AssetLogic.calculateCanonicalHash(_params.canonicalId, _params.canonicalDomain)]\n      .adopted;\n\n    // Verify asset\n    // NOTE: if asset is removed, `adopted` will be `address(0)`, so you cannot verify the asset\n    // but should still allow for portal loans to be repaid.\n    if (adopted != address(0) && _portalAsset != adopted) {\n      revert PortalFacet__repayAavePortalFor_invalidAsset();\n    }\n\n    // Here, generate the transfer id. This allows us to ensure the `_adopted` asset\n    // is the correct one associated with the transfer. Otherwise, anyone could pay back\n    // the loan with the incorrect asset and remove the ability to transfer here. If the\n    // `_adopted` asset is incorrectly supplied, the generated transferId will also be\n    // incorrect, and the _backLoan call (which manipulates the debt stored) will fail.\n    // Another option is to store the asset associated with the transfer on `execute`, but\n    // this would make an already expensive call even more so.\n    bytes32 transferId = _calculateTransferId(_params);\n\n    // Transfer funds to the contract\n    uint256 total = _backingAmount + _feeAmount;\n    if (total == 0) revert PortalFacet__repayAavePortalFor_zeroAmount();\n\n    AssetLogic.handleIncomingAsset(adopted, total);\n\n    // No need to swap because this is the adopted asset. Simply\n    // repay the loan\n    _backLoan(adopted, _backingAmount, _feeAmount, transferId);\n  }\n\n  // ============ Internal functions ============\n\n  /**\n   * @notice Calls backUnbacked on the aave contracts\n   * @dev Assumes funds in adopted asset are already on contract\n   * @param _asset Address of the adopted asset (asset backing the loan)\n   * @param _backing Amount of principle to repay\n   * @param _fee Amount of fees to repay\n   * @param _transferId Corresponding transfer id for the fees\n   */\n  function _backLoan(\n    address _asset,\n    uint256 _backing,\n    uint256 _fee,\n    bytes32 _transferId\n  ) internal {\n    // reduce debt\n    s.portalDebt[_transferId] -= _backing;\n    s.portalFeeDebt[_transferId] -= _fee;\n\n    address aPool = s.aavePool;\n\n    // increase allowance\n    SafeERC20.safeApprove(IERC20(_asset), aPool, 0);\n    SafeERC20.safeIncreaseAllowance(IERC20(_asset), aPool, _backing + _fee);\n\n    // back loan\n    IAavePool(aPool).backUnbacked(_asset, _backing, _fee);\n\n    // emit event\n    emit AavePortalRepayment(_transferId, _asset, _backing, _fee, msg.sender);\n  }\n}\n"
    },
    "contracts/core/connext/interfaces/IAavePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IAavePool {\n  /**\n   * @dev Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   **/\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n}\n"
    },
    "contracts/test/TestAavePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IAavePool} from \"../core/connext/interfaces/IAavePool.sol\";\n\ncontract TestAavePool is IAavePool {\n  bool revertCall;\n\n  function setRevertCall(bool _revert) external {\n    revertCall = _revert;\n  }\n\n  function mintUnbacked(\n    address, //asset,\n    uint256, //amount,\n    address, //onBehalfOf,\n    uint16 //referralCode\n  ) external view {\n    require(!revertCall, \"mintUnbacked reverted\");\n  }\n\n  function backUnbacked(\n    address, //asset,\n    uint256, // amount,\n    uint256 // fee\n  ) external view {\n    require(!revertCall, \"backUnbacked reverted\");\n  }\n\n  function withdraw(\n    address, // asset,\n    uint256 amount,\n    address //to\n  ) external view returns (uint256) {\n    require(!revertCall, \"withdraw reverted\");\n    return amount;\n  }\n}\n"
    },
    "contracts/core/connext/facets/BridgeFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {ExcessivelySafeCall} from \"../../../shared/libraries/ExcessivelySafeCall.sol\";\nimport {TypedMemView} from \"../../../shared/libraries/TypedMemView.sol\";\nimport {TypeCasts} from \"../../../shared/libraries/TypeCasts.sol\";\n\nimport {IOutbox} from \"../../../messaging/interfaces/IOutbox.sol\";\nimport {IConnectorManager} from \"../../../messaging/interfaces/IConnectorManager.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {ExecuteArgs, TransferInfo, DestinationTransferStatus, TokenConfig} from \"../libraries/LibConnextStorage.sol\";\nimport {BridgeMessage} from \"../libraries/BridgeMessage.sol\";\nimport {Constants} from \"../libraries/Constants.sol\";\nimport {TokenId} from \"../libraries/TokenId.sol\";\n\nimport {IXReceiver} from \"../interfaces/IXReceiver.sol\";\nimport {IAavePool} from \"../interfaces/IAavePool.sol\";\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\n\ncontract BridgeFacet is BaseConnextFacet {\n  // ============ Libraries ============\n\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using BridgeMessage for bytes29;\n\n  // ========== Custom Errors ===========\n\n  error BridgeFacet__addRemote_invalidRouter();\n  error BridgeFacet__addRemote_invalidDomain();\n  error BridgeFacet__onlyDelegate_notDelegate();\n  error BridgeFacet__addSequencer_invalidSequencer();\n  error BridgeFacet__addSequencer_alreadyApproved();\n  error BridgeFacet__removeSequencer_notApproved();\n  error BridgeFacet__setXAppConnectionManager_domainsDontMatch();\n  error BridgeFacet__xcall_nativeAssetNotSupported();\n  error BridgeFacet__xcall_emptyTo();\n  error BridgeFacet__xcall_invalidSlippage();\n  error BridgeFacet_xcall__emptyLocalAsset();\n  error BridgeFacet__xcall_capReached();\n  error BridgeFacet__execute_unapprovedSender();\n  error BridgeFacet__execute_wrongDomain();\n  error BridgeFacet__execute_notSupportedSequencer();\n  error BridgeFacet__execute_invalidSequencerSignature();\n  error BridgeFacet__execute_maxRoutersExceeded();\n  error BridgeFacet__execute_notSupportedRouter();\n  error BridgeFacet__execute_invalidRouterSignature();\n  error BridgeFacet__execute_notApprovedForPortals();\n  error BridgeFacet__execute_badFastLiquidityStatus();\n  error BridgeFacet__execute_notReconciled();\n  error BridgeFacet__execute_externalCallFailed();\n  error BridgeFacet__excecute_insufficientGas();\n  error BridgeFacet__executePortalTransfer_insufficientAmountWithdrawn();\n  error BridgeFacet__bumpTransfer_valueIsZero();\n  error BridgeFacet__bumpTransfer_noRelayerVault();\n  error BridgeFacet__forceUpdateSlippage_invalidSlippage();\n  error BridgeFacet__forceUpdateSlippage_notDestination();\n  error BridgeFacet__forceReceiveLocal_notDestination();\n  error BridgeFacet__mustHaveRemote_destinationNotSupported();\n\n  // ============ Properties ============\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `xcall` is called on the origin domain of a transfer.\n   * @param transferId - The unique identifier of the crosschain transfer.\n   * @param nonce - The bridge nonce of the transfer on the origin domain.\n   * @param messageHash - The hash of the message bytes (containing all transfer info) that were bridged.\n   * @param params - The `TransferInfo` provided to the function.\n   * @param asset - The asset sent in with xcall\n   * @param amount - The amount sent in with xcall\n   * @param local - The local asset that is controlled by the bridge and can be burned/minted\n   */\n  event XCalled(\n    bytes32 indexed transferId,\n    uint256 indexed nonce,\n    bytes32 indexed messageHash,\n    TransferInfo params,\n    address asset,\n    uint256 amount,\n    address local\n  );\n\n  /**\n   * @notice Emitted when a transfer has its external data executed\n   * @param transferId - The unique identifier of the crosschain transfer.\n   * @param success - Whether calldata succeeded\n   * @param returnData - Return bytes from the IXReceiver\n   */\n  event ExternalCalldataExecuted(bytes32 indexed transferId, bool success, bytes returnData);\n\n  /**\n   * @notice Emitted when `execute` is called on the destination domain of a transfer.\n   * @dev `execute` may be called when providing fast liquidity or when processing a reconciled (slow) transfer.\n   * @param transferId - The unique identifier of the crosschain transfer.\n   * @param to - The recipient `TransferInfo.to` provided, created as indexed parameter.\n   * @param asset - The asset the recipient is given or the external call is executed with. Should be the\n   * adopted asset on that chain.\n   * @param args - The `ExecuteArgs` provided to the function.\n   * @param local - The local asset that was either supplied by the router for a fast-liquidity transfer or\n   * minted by the bridge in a reconciled (slow) transfer. Could be the same as the adopted `asset` param.\n   * @param amount - The amount of transferring asset the recipient address receives or the external call is\n   * executed with.\n   * @param caller - The account that called the function.\n   */\n  event Executed(\n    bytes32 indexed transferId,\n    address indexed to,\n    address indexed asset,\n    ExecuteArgs args,\n    address local,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when `_bumpTransfer` is called by an user on the origin domain both in\n   * `xcall` and `bumpTransfer`\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param increase - The additional amount fees increased by\n   * @param caller - The account that called the function\n   */\n  event TransferRelayerFeesIncreased(bytes32 indexed transferId, uint256 increase, address caller);\n\n  /**\n   * @notice Emitted when `forceUpdateSlippage` is called by user-delegated EOA\n   * on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param slippage - The updated slippage boundary\n   */\n  event SlippageUpdated(bytes32 indexed transferId, uint256 slippage);\n\n  /**\n   * @notice Emitted when `forceReceiveLocal` is called by a user-delegated EOA\n   * on the destination domain\n   * @param transferId - The unique identifier of the crosschain transaction\n   */\n  event ForceReceiveLocal(bytes32 indexed transferId);\n\n  /**\n   * @notice Emitted when a router used Aave Portal liquidity for fast transfer\n   * @param transferId - The unique identifier of the crosschain transaction\n   * @param router - The authorized router that used Aave Portal liquidity\n   * @param asset - The asset that was provided by Aave Portal\n   * @param amount - The amount of asset that was provided by Aave Portal\n   */\n  event AavePortalMintUnbacked(bytes32 indexed transferId, address indexed router, address asset, uint256 amount);\n\n  /**\n   * @notice Emitted when a new remote instance is added\n   * @param domain - The domain the remote instance is on\n   * @param remote - The address of the remote instance\n   * @param caller - The account that called the function\n   */\n  event RemoteAdded(uint32 domain, address remote, address caller);\n\n  /**\n   * @notice Emitted when a sequencer is added or removed from allowlists\n   * @param sequencer - The sequencer address to be added or removed\n   * @param caller - The account that called the function\n   */\n  event SequencerAdded(address sequencer, address caller);\n\n  /**\n   * @notice Emitted when a sequencer is added or removed from allowlists\n   * @param sequencer - The sequencer address to be added or removed\n   * @param caller - The account that called the function\n   */\n  event SequencerRemoved(address sequencer, address caller);\n\n  /**\n   * @notice Emitted `xAppConnectionManager` is updated\n   * @param updated - The updated address\n   * @param caller - The account that called the function\n   */\n  event XAppConnectionManagerSet(address updated, address caller);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Only accept a transfer's designated delegate.\n   * @param _params The TransferInfo of the transfer.\n   */\n  modifier onlyDelegate(TransferInfo calldata _params) {\n    if (_params.delegate != msg.sender) revert BridgeFacet__onlyDelegate_notDelegate();\n    _;\n  }\n\n  // ============ Getters ============\n\n  function routedTransfers(bytes32 _transferId) public view returns (address[] memory) {\n    return s.routedTransfers[_transferId];\n  }\n\n  function transferStatus(bytes32 _transferId) public view returns (DestinationTransferStatus) {\n    return s.transferStatus[_transferId];\n  }\n\n  function remote(uint32 _domain) public view returns (address) {\n    return TypeCasts.bytes32ToAddress(s.remotes[_domain]);\n  }\n\n  function domain() public view returns (uint32) {\n    return s.domain;\n  }\n\n  function nonce() public view returns (uint256) {\n    return s.nonce;\n  }\n\n  function approvedSequencers(address _sequencer) external view returns (bool) {\n    return s.approvedSequencers[_sequencer];\n  }\n\n  function xAppConnectionManager() public view returns (address) {\n    return address(s.xAppConnectionManager);\n  }\n\n  // ============ Admin Functions ==============\n\n  /**\n   * @notice Used to add an approved sequencer to the allowlist.\n   * @param _sequencer - The sequencer address to add.\n   */\n  function addSequencer(address _sequencer) external onlyOwnerOrAdmin {\n    if (_sequencer == address(0)) revert BridgeFacet__addSequencer_invalidSequencer();\n\n    if (s.approvedSequencers[_sequencer]) revert BridgeFacet__addSequencer_alreadyApproved();\n    s.approvedSequencers[_sequencer] = true;\n\n    emit SequencerAdded(_sequencer, msg.sender);\n  }\n\n  /**\n   * @notice Used to remove an approved sequencer from the allowlist.\n   * @param _sequencer - The sequencer address to remove.\n   */\n  function removeSequencer(address _sequencer) external onlyOwnerOrAdmin {\n    if (!s.approvedSequencers[_sequencer]) revert BridgeFacet__removeSequencer_notApproved();\n    delete s.approvedSequencers[_sequencer];\n\n    emit SequencerRemoved(_sequencer, msg.sender);\n  }\n\n  /**\n   * @notice Modify the contract the xApp uses to validate Replica contracts\n   * @param _xAppConnectionManager The address of the xAppConnectionManager contract\n   */\n  function setXAppConnectionManager(address _xAppConnectionManager) external onlyOwnerOrAdmin {\n    IConnectorManager manager = IConnectorManager(_xAppConnectionManager);\n    if (manager.localDomain() != s.domain) {\n      revert BridgeFacet__setXAppConnectionManager_domainsDontMatch();\n    }\n    emit XAppConnectionManagerSet(_xAppConnectionManager, msg.sender);\n    s.xAppConnectionManager = manager;\n  }\n\n  /**\n   * @notice Register the address of a Router contract for the same xApp on a remote chain\n   * @param _domain The domain of the remote xApp Router\n   * @param _router The address of the remote xApp Router\n   */\n  function enrollRemoteRouter(uint32 _domain, bytes32 _router) external onlyOwnerOrAdmin {\n    if (_router == bytes32(\"\")) revert BridgeFacet__addRemote_invalidRouter();\n\n    // Make sure we aren't setting the current domain (or an empty one) as the connextion.\n    if (_domain == 0 || _domain == s.domain) {\n      revert BridgeFacet__addRemote_invalidDomain();\n    }\n\n    s.remotes[_domain] = _router;\n    emit RemoteAdded(_domain, TypeCasts.bytes32ToAddress(_router), msg.sender);\n  }\n\n  // ============ Public Functions: Bridge ==============\n\n  function xcall(\n    uint32 _destination,\n    address _to,\n    address _asset,\n    address _delegate,\n    uint256 _amount,\n    uint256 _slippage,\n    bytes calldata _callData\n  ) external payable nonXCallReentrant returns (bytes32) {\n    // NOTE: Here, we fill in as much information as we can for the TransferInfo.\n    // Some info is left blank and will be assigned in the internal `_xcall` function (e.g.\n    // `normalizedIn`, `bridgedAmt`, canonical info, etc).\n    TransferInfo memory params = TransferInfo({\n      to: _to,\n      callData: _callData,\n      originDomain: s.domain,\n      destinationDomain: _destination,\n      delegate: _delegate,\n      // `receiveLocal: false` indicates we should always deliver the adopted asset on the\n      // destination chain, swapping from the local asset if needed.\n      receiveLocal: false,\n      slippage: _slippage,\n      originSender: msg.sender,\n      // The following values should be assigned in _xcall.\n      nonce: 0,\n      canonicalDomain: 0,\n      bridgedAmt: 0,\n      normalizedIn: 0,\n      canonicalId: bytes32(0)\n    });\n    return _xcall(params, _asset, _amount);\n  }\n\n  function xcallIntoLocal(\n    uint32 _destination,\n    address _to,\n    address _asset,\n    address _delegate,\n    uint256 _amount,\n    uint256 _slippage,\n    bytes calldata _callData\n  ) external payable nonXCallReentrant returns (bytes32) {\n    // NOTE: Here, we fill in as much information as we can for the TransferInfo.\n    // Some info is left blank and will be assigned in the internal `_xcall` function (e.g.\n    // `normalizedIn`, `bridgedAmt`, canonical info, etc).\n    TransferInfo memory params = TransferInfo({\n      to: _to,\n      callData: _callData,\n      originDomain: s.domain,\n      destinationDomain: _destination,\n      delegate: _delegate,\n      // `receiveLocal: true` indicates we should always deliver the local asset on the\n      // destination chain, and NOT swap into any adopted assets.\n      receiveLocal: true,\n      slippage: _slippage,\n      originSender: msg.sender,\n      // The following values should be assigned in _xcall.\n      nonce: 0,\n      canonicalDomain: 0,\n      bridgedAmt: 0,\n      normalizedIn: 0,\n      canonicalId: bytes32(0)\n    });\n    return _xcall(params, _asset, _amount);\n  }\n\n  /**\n   * @notice Called on a destination domain to disburse correct assets to end recipient and execute any included\n   * calldata.\n   *\n   * @dev Can be called before or after `handle` [reconcile] is called (regarding the same transfer), depending on\n   * whether the fast liquidity route (i.e. funds provided by routers) is being used for this transfer. As a result,\n   * executed calldata (including properties like `originSender`) may or may not be verified depending on whether the\n   * reconcile has been completed (i.e. the optimistic confirmation period has elapsed).\n   *\n   * @param _args - ExecuteArgs arguments.\n   * @return bytes32 - The transfer ID of the crosschain transfer. Should match the xcall's transfer ID in order for\n   * reconciliation to occur.\n   */\n  function execute(ExecuteArgs calldata _args) external nonReentrant whenNotPaused returns (bytes32) {\n    (bytes32 transferId, DestinationTransferStatus status) = _executeSanityChecks(_args);\n\n    DestinationTransferStatus updated = status == DestinationTransferStatus.Reconciled\n      ? DestinationTransferStatus.Completed\n      : DestinationTransferStatus.Executed;\n\n    s.transferStatus[transferId] = updated;\n\n    // Supply assets to target recipient. Use router liquidity when this is a fast transfer, or mint bridge tokens\n    // when this is a slow transfer.\n    // NOTE: Asset will be adopted unless specified to `receiveLocal` in params.\n    (uint256 amountOut, address asset, address local) = _handleExecuteLiquidity(\n      transferId,\n      AssetLogic.calculateCanonicalHash(_args.params.canonicalId, _args.params.canonicalDomain),\n      updated != DestinationTransferStatus.Completed,\n      _args\n    );\n\n    // Execute the transaction using the designated calldata.\n    uint256 amount = _handleExecuteTransaction(\n      _args,\n      amountOut,\n      asset,\n      transferId,\n      updated == DestinationTransferStatus.Completed\n    );\n\n    // Emit event.\n    emit Executed(transferId, _args.params.to, asset, _args, local, amount, msg.sender);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Anyone can call this function on the origin domain to increase the relayer fee for a transfer.\n   * @param _transferId - The unique identifier of the crosschain transaction\n   */\n  function bumpTransfer(bytes32 _transferId) external payable nonReentrant whenNotPaused {\n    if (msg.value == 0) revert BridgeFacet__bumpTransfer_valueIsZero();\n    _bumpTransfer(_transferId);\n  }\n\n  function _bumpTransfer(bytes32 _transferId) internal {\n    address relayerVault = s.relayerFeeVault;\n    if (relayerVault == address(0)) revert BridgeFacet__bumpTransfer_noRelayerVault();\n    Address.sendValue(payable(relayerVault), msg.value);\n\n    emit TransferRelayerFeesIncreased(_transferId, msg.value, msg.sender);\n  }\n\n  /**\n   * @notice Allows a user-specified account to update the slippage they are willing\n   * to take on destination transfers.\n   *\n   * @param _params TransferInfo associated with the transfer\n   * @param _slippage The updated slippage\n   */\n  function forceUpdateSlippage(TransferInfo calldata _params, uint256 _slippage) external onlyDelegate(_params) {\n    // Sanity check slippage\n    if (_slippage > Constants.BPS_FEE_DENOMINATOR) {\n      revert BridgeFacet__forceUpdateSlippage_invalidSlippage();\n    }\n\n    // Should only be called on destination domain\n    if (_params.destinationDomain != s.domain) {\n      revert BridgeFacet__forceUpdateSlippage_notDestination();\n    }\n\n    // Get transferId\n    bytes32 transferId = _calculateTransferId(_params);\n\n    // Store overrides\n    s.slippage[transferId] = _slippage;\n\n    // Emit event\n    emit SlippageUpdated(transferId, _slippage);\n  }\n\n  /**\n   * @notice Allows a user-specified account to withdraw the local asset directly\n   * @dev Calldata will still be executed with the local asset. `IXReceiver` contracts\n   * should be able to handle local assets in event of failures.\n   * @param _params TransferInfo associated with the transfer\n   */\n  function forceReceiveLocal(TransferInfo calldata _params) external onlyDelegate(_params) {\n    // Should only be called on destination domain\n    if (_params.destinationDomain != s.domain) {\n      revert BridgeFacet__forceReceiveLocal_notDestination();\n    }\n\n    // Get transferId\n    bytes32 transferId = _calculateTransferId(_params);\n\n    // Store overrides\n    s.receiveLocalOverride[transferId] = true;\n\n    // Emit event\n    emit ForceReceiveLocal(transferId);\n  }\n\n  // ============ Internal: Bridge ============\n\n  /**\n   * @notice Initiates a cross-chain transfer of funds and/or calldata\n   *\n   * @dev For ERC20 transfers, this contract must have approval to transfer the input (transacting) assets. The adopted\n   * assets will be swapped for their local asset counterparts (i.e. bridgeable tokens) via the configured AMM if\n   * necessary. In the event that the adopted assets *are* local bridge assets, no swap is needed. The local tokens will\n   * then be sent via the bridge router. If the local assets are representational for an asset on another chain, we will\n   * burn the tokens here. If the local assets are canonical (meaning that the adopted<>local asset pairing is native\n   * to this chain), we will custody the tokens here.\n   *\n   * @param _params - The TransferInfo arguments.\n   * @return bytes32 - The transfer ID of the newly created crosschain transfer.\n   */\n  function _xcall(\n    TransferInfo memory _params,\n    address _asset,\n    uint256 _amount\n  ) internal whenNotPaused returns (bytes32) {\n    // Sanity checks.\n    bytes32 remoteInstance;\n    {\n      // Not native asset.\n      // NOTE: We support using address(0) as an intuitive default if you are sending a 0-value\n      // transfer. In that edge case, address(0) will not be registered as a supported asset, but should\n      // pass the `isLocalOrigin` check\n      if (_asset == address(0) && _amount != 0) {\n        revert BridgeFacet__xcall_nativeAssetNotSupported();\n      }\n\n      // Destination domain is supported.\n      // NOTE: This check implicitly also checks that `_params.destinationDomain != s.domain`, because the index\n      // `s.domain` of `s.remotes` should always be `bytes32(0)`.\n      remoteInstance = _mustHaveRemote(_params.destinationDomain);\n\n      // Recipient defined.\n      if (_params.to == address(0)) {\n        revert BridgeFacet__xcall_emptyTo();\n      }\n\n      if (_params.slippage > Constants.BPS_FEE_DENOMINATOR) {\n        revert BridgeFacet__xcall_invalidSlippage();\n      }\n    }\n\n    // NOTE: The local asset will stay address(0) if input asset is address(0) in the event of a\n    // 0-value transfer. Otherwise, the local address will be retrieved below\n    address local;\n    bytes32 transferId;\n    TokenId memory canonical;\n    bool isCanonical;\n    {\n      // Check that the asset is supported -- can be either adopted or local.\n      // NOTE: Above we check that you can only have `address(0)` as the input asset if this is a\n      // 0-value transfer. Because 0-value transfers short-circuit all checks on mappings keyed on\n      // hash(canonicalId, canonicalDomain), this is safe even when the address(0) asset is not\n      // allowlisted.\n      if (_asset != address(0)) {\n        // Retrieve the canonical token information.\n        bytes32 key;\n        (canonical, key) = _getApprovedCanonicalId(_asset);\n\n        // Get the token config.\n        TokenConfig storage config = AssetLogic.getConfig(key);\n\n        // Set boolean flag\n        isCanonical = _params.originDomain == canonical.domain;\n\n        // Get the local address\n        local = isCanonical ? TypeCasts.bytes32ToAddress(canonical.id) : config.representation;\n        if (local == address(0)) {\n          revert BridgeFacet_xcall__emptyLocalAsset();\n        }\n\n        {\n          // Enforce liquidity caps.\n          // NOTE: Safe to do this before the swap because canonical domains do\n          // not hit the AMMs (local == canonical).\n          uint256 cap = config.cap;\n          if (isCanonical && cap > 0) {\n            // NOTE: this method includes router liquidity as part of the caps,\n            // not only the minted amount\n            uint256 newCustodiedAmount = config.custodied + _amount;\n            if (newCustodiedAmount > cap) {\n              revert BridgeFacet__xcall_capReached();\n            }\n            s.tokenConfigs[key].custodied = newCustodiedAmount;\n          }\n        }\n\n        // Update TransferInfo to reflect the canonical token information.\n        _params.canonicalDomain = canonical.domain;\n        _params.canonicalId = canonical.id;\n\n        if (_amount > 0) {\n          // Transfer funds of input asset to the contract from the user.\n          AssetLogic.handleIncomingAsset(_asset, _amount);\n\n          // Swap to the local asset from adopted if applicable.\n          _params.bridgedAmt = AssetLogic.swapToLocalAssetIfNeeded(key, _asset, local, _amount, _params.slippage);\n\n          // Get the normalized amount in (amount sent in by user in 18 decimals).\n          // NOTE: when getting the decimals from `_asset`, you don't know if you are looking for\n          // adopted or local assets\n          _params.normalizedIn = AssetLogic.normalizeDecimals(\n            _asset == local ? config.representationDecimals : config.adoptedDecimals,\n            Constants.DEFAULT_NORMALIZED_DECIMALS,\n            _amount\n          );\n        }\n      }\n\n      // Calculate the transfer ID.\n      _params.nonce = s.nonce++;\n      transferId = _calculateTransferId(_params);\n    }\n\n    // Handle the relayer fee.\n    // NOTE: This has to be done *after* transferring in + swapping assets because\n    // the transfer id uses the amount that is bridged (i.e. amount in local asset).\n    if (msg.value > 0) {\n      _bumpTransfer(transferId);\n    }\n\n    // Send the crosschain message.\n    bytes32 messageHash = _sendMessage(\n      transferId,\n      _params.destinationDomain,\n      remoteInstance,\n      canonical,\n      local,\n      _params.bridgedAmt,\n      isCanonical\n    );\n\n    // emit event\n    emit XCalled(transferId, _params.nonce, messageHash, _params, _asset, _amount, local);\n\n    return transferId;\n  }\n\n  /**\n   * @notice Holds the logic to recover the signer from an encoded payload.\n   * @dev Will hash and convert to an eth signed message.\n   * @param _signed The hash that was signed.\n   * @param _sig The signature from which we will recover the signer.\n   */\n  function _recoverSignature(bytes32 _signed, bytes calldata _sig) internal pure returns (address) {\n    // Recover\n    return ECDSA.recover(ECDSA.toEthSignedMessageHash(_signed), _sig);\n  }\n\n  /**\n   * @notice Performs some sanity checks for `execute`.\n   * @dev Need this to prevent stack too deep.\n   * @param _args ExecuteArgs that were passed in to the `execute` call.\n   */\n  function _executeSanityChecks(ExecuteArgs calldata _args) private view returns (bytes32, DestinationTransferStatus) {\n    // If the sender is not approved relayer, revert\n    if (!s.approvedRelayers[msg.sender] && msg.sender != _args.params.delegate) {\n      revert BridgeFacet__execute_unapprovedSender();\n    }\n\n    // If this is not the destination domain revert\n    if (_args.params.destinationDomain != s.domain) {\n      revert BridgeFacet__execute_wrongDomain();\n    }\n\n    // Path length refers to the number of facilitating routers. A transfer is considered 'multipath'\n    // if multiple routers provide liquidity (in even 'shares') for it.\n    uint256 pathLength = _args.routers.length;\n\n    // Derive transfer ID based on given arguments.\n    bytes32 transferId = _calculateTransferId(_args.params);\n\n    // Retrieve the reconciled record.\n    DestinationTransferStatus status = s.transferStatus[transferId];\n\n    if (pathLength != 0) {\n      // Make sure number of routers is below the configured maximum.\n      if (pathLength > s.maxRoutersPerTransfer) revert BridgeFacet__execute_maxRoutersExceeded();\n\n      // Check to make sure the transfer has not been reconciled (no need for routers if the transfer is\n      // already reconciled; i.e. if there are routers provided, the transfer must *not* be reconciled).\n      if (status != DestinationTransferStatus.None) revert BridgeFacet__execute_badFastLiquidityStatus();\n\n      // NOTE: The sequencer address may be empty and no signature needs to be provided in the case of the\n      // slow liquidity route (i.e. no routers involved). Additionally, the sequencer does not need to be the\n      // msg.sender.\n      // Check to make sure the sequencer address provided is approved\n      if (!s.approvedSequencers[_args.sequencer]) {\n        revert BridgeFacet__execute_notSupportedSequencer();\n      }\n      // Check to make sure the sequencer provided did sign the transfer ID and router path provided.\n      // NOTE: when caps are enforced, this signature also acts as protection from malicious routers looking\n      // to block the network. routers could `execute` a fake transaction, and use up the rest of the `custodied`\n      // bandwidth, causing future `execute`s to fail. this would also cause a break in the accounting, where the\n      // `custodied` balance no longer tracks representation asset minting / burning\n      if (\n        _args.sequencer != _recoverSignature(keccak256(abi.encode(transferId, _args.routers)), _args.sequencerSignature)\n      ) {\n        revert BridgeFacet__execute_invalidSequencerSignature();\n      }\n\n      // Hash the payload for which each router should have produced a signature.\n      // Each router should have signed the `transferId` (which implicitly signs call params,\n      // amount, and tokenId) as well as the `pathLength`, or the number of routers with which\n      // they are splitting liquidity provision.\n      bytes32 routerHash = keccak256(abi.encode(transferId, pathLength));\n\n      for (uint256 i; i < pathLength; ) {\n        // Make sure the router is approved, if applicable.\n        // If router ownership is renounced (_RouterOwnershipRenounced() is true), then the router allowlist\n        // no longer applies and we can skip this approval step.\n        if (!_isRouterAllowlistRemoved() && !s.routerConfigs[_args.routers[i]].approved) {\n          revert BridgeFacet__execute_notSupportedRouter();\n        }\n\n        // Validate the signature. We'll recover the signer's address using the expected payload and basic ECDSA\n        // signature scheme recovery. The address for each signature must match the router's address.\n        if (_args.routers[i] != _recoverSignature(routerHash, _args.routerSignatures[i])) {\n          revert BridgeFacet__execute_invalidRouterSignature();\n        }\n\n        unchecked {\n          ++i;\n        }\n      }\n    } else {\n      // If there are no routers for this transfer, this `execute` must be a slow liquidity route; in which\n      // case, we must make sure the transfer's been reconciled.\n      if (status != DestinationTransferStatus.Reconciled) revert BridgeFacet__execute_notReconciled();\n    }\n\n    return (transferId, status);\n  }\n\n  /**\n   * @notice Calculates fast transfer amount.\n   * @param _amount Transfer amount\n   * @param _numerator Numerator\n   * @param _denominator Denominator\n   */\n  function _muldiv(\n    uint256 _amount,\n    uint256 _numerator,\n    uint256 _denominator\n  ) private pure returns (uint256) {\n    return (_amount * _numerator) / _denominator;\n  }\n\n  /**\n   * @notice Execute liquidity process used when calling `execute`.\n   * @dev Will revert with underflow if any router in the path has insufficient liquidity to provide\n   * for the transfer.\n   * @dev Need this to prevent stack too deep.\n   */\n  function _handleExecuteLiquidity(\n    bytes32 _transferId,\n    bytes32 _key,\n    bool _isFast,\n    ExecuteArgs calldata _args\n  )\n    private\n    returns (\n      uint256,\n      address,\n      address\n    )\n  {\n    // Save the addresses of all routers providing liquidity for this transfer.\n    s.routedTransfers[_transferId] = _args.routers;\n\n    // Get the local asset contract address (if applicable).\n    address local;\n    if (_args.params.canonicalDomain != 0) {\n      local = _getLocalAsset(_key, _args.params.canonicalId, _args.params.canonicalDomain);\n    }\n\n    // If this is a zero-value transfer, short-circuit remaining logic.\n    if (_args.params.bridgedAmt == 0) {\n      return (0, local, local);\n    }\n\n    // Get the receive local status\n    bool receiveLocal = _args.params.receiveLocal || s.receiveLocalOverride[_transferId];\n\n    uint256 toSwap = _args.params.bridgedAmt;\n    // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.\n    // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),\n    // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state\n    // (since the amount is hashed in the transfer ID itself) - thus, no updates are required.\n    if (_isFast) {\n      uint256 pathLen = _args.routers.length;\n\n      // Calculate amount that routers will provide with the fast-liquidity fee deducted.\n      toSwap = _muldiv(_args.params.bridgedAmt, s.LIQUIDITY_FEE_NUMERATOR, Constants.BPS_FEE_DENOMINATOR);\n\n      if (pathLen == 1) {\n        // If router does not have enough liquidity, try to use Aave Portals.\n        // NOTE: Only one router should be responsible for taking on this credit risk, and it should only deal\n        // with transfers expecting adopted assets (to avoid introducing runtime slippage).\n        if (!receiveLocal && s.routerBalances[_args.routers[0]][local] < toSwap && s.aavePool != address(0)) {\n          if (!s.routerConfigs[_args.routers[0]].portalApproved) revert BridgeFacet__execute_notApprovedForPortals();\n\n          // Portals deliver the adopted asset directly; return after portal execution is completed.\n          (uint256 portalDeliveredAmount, address adoptedAsset) = _executePortalTransfer(\n            _transferId,\n            _key,\n            toSwap,\n            _args.routers[0]\n          );\n          return (portalDeliveredAmount, adoptedAsset, local);\n        } else {\n          // Decrement the router's liquidity.\n          s.routerBalances[_args.routers[0]][local] -= toSwap;\n        }\n      } else {\n        // For each router, assert they are approved, and deduct liquidity.\n        uint256 routerAmount = toSwap / pathLen;\n        for (uint256 i; i < pathLen - 1; ) {\n          // Decrement router's liquidity.\n          // NOTE: If any router in the path has insufficient liquidity, this will revert with an underflow error.\n          s.routerBalances[_args.routers[i]][local] -= routerAmount;\n\n          unchecked {\n            ++i;\n          }\n        }\n        // The last router in the multipath will sweep the remaining balance to account for remainder dust.\n        uint256 toSweep = routerAmount + (toSwap % pathLen);\n        s.routerBalances[_args.routers[pathLen - 1]][local] -= toSweep;\n      }\n    }\n\n    // If it is the canonical domain, decrease custodied value\n    if (s.domain == _args.params.canonicalDomain && AssetLogic.getConfig(_key).cap > 0) {\n      // NOTE: safe to use the amount here instead of post-swap because there are no\n      // AMMs on the canonical domain (assuming canonical == adopted on canonical domain)\n      s.tokenConfigs[_key].custodied -= toSwap;\n    }\n\n    // If the local asset is specified, or the adopted asset was overridden (e.g. when user facing slippage\n    // conditions outside of their boundaries), exit without swapping.\n    if (receiveLocal) {\n      // Delete override\n      delete s.receiveLocalOverride[_transferId];\n\n      return (toSwap, local, local);\n    }\n\n    // Swap out of representational asset into adopted asset if needed.\n    uint256 slippageOverride = s.slippage[_transferId];\n    // delete for gas refund\n    delete s.slippage[_transferId];\n\n    (uint256 amount, address adopted) = AssetLogic.swapFromLocalAssetIfNeeded(\n      _key,\n      local,\n      toSwap,\n      slippageOverride != 0 ? slippageOverride : _args.params.slippage,\n      _args.params.normalizedIn\n    );\n    return (amount, adopted, local);\n  }\n\n  /**\n   * @notice Process the transfer, and calldata if needed, when calling `execute`\n   * @dev Need this to prevent stack too deep\n   */\n  function _handleExecuteTransaction(\n    ExecuteArgs calldata _args,\n    uint256 _amountOut,\n    address _asset, // adopted (or local if specified)\n    bytes32 _transferId,\n    bool _reconciled\n  ) private returns (uint256) {\n    // transfer funds to recipient\n    AssetLogic.handleOutgoingAsset(_asset, _args.params.to, _amountOut);\n\n    // execute the calldata\n    _executeCalldata(_transferId, _amountOut, _asset, _reconciled, _args.params);\n\n    return _amountOut;\n  }\n\n  /**\n   * @notice Executes external calldata.\n   * \n   * @dev Once a transfer is reconciled (i.e. data is authenticated), external calls will\n   * fail gracefully. This means errors will be emitted in an event, but the function itself\n   * will not revert.\n\n   * In the case where a transaction is *not* reconciled (i.e. data is unauthenticated), this\n   * external call will fail loudly. This allows all functions that rely on authenticated data\n   * (using a specific check on the origin sender), to be forced into the slow path for\n   * execution to succeed.\n   * \n   */\n  function _executeCalldata(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    bool _reconciled,\n    TransferInfo calldata _params\n  ) internal {\n    // execute the calldata\n    if (keccak256(_params.callData) == Constants.EMPTY_HASH) {\n      // no call data, return amount out\n      return;\n    }\n\n    (bool success, bytes memory returnData) = ExcessivelySafeCall.excessivelySafeCall(\n      _params.to,\n      gasleft() - Constants.EXECUTE_CALLDATA_RESERVE_GAS,\n      0, // native asset value (always 0)\n      Constants.DEFAULT_COPY_BYTES, // only copy 256 bytes back as calldata\n      abi.encodeWithSelector(\n        IXReceiver.xReceive.selector,\n        _transferId,\n        _amount,\n        _asset,\n        _reconciled ? _params.originSender : address(0), // use passed in value iff authenticated\n        _params.originDomain,\n        _params.callData\n      )\n    );\n\n    if (!_reconciled && !success) {\n      // See above devnote, reverts if unsuccessful on fast path\n      revert BridgeFacet__execute_externalCallFailed();\n    }\n\n    emit ExternalCalldataExecuted(_transferId, success, returnData);\n  }\n\n  /**\n   * @notice Uses Aave Portals to provide fast liquidity\n   */\n  function _executePortalTransfer(\n    bytes32 _transferId,\n    bytes32 _key,\n    uint256 _fastTransferAmount,\n    address _router\n  ) internal returns (uint256, address) {\n    // Calculate local to adopted swap output if needed\n    address adopted = _getAdoptedAsset(_key);\n\n    IAavePool(s.aavePool).mintUnbacked(adopted, _fastTransferAmount, address(this), Constants.AAVE_REFERRAL_CODE);\n\n    // Improvement: Instead of withdrawing to address(this), withdraw directly to the user or executor to save 1 transfer\n    uint256 amountWithdrawn = IAavePool(s.aavePool).withdraw(adopted, _fastTransferAmount, address(this));\n\n    if (amountWithdrawn < _fastTransferAmount) revert BridgeFacet__executePortalTransfer_insufficientAmountWithdrawn();\n\n    // Store principle debt\n    s.portalDebt[_transferId] = _fastTransferAmount;\n\n    // Store fee debt\n    s.portalFeeDebt[_transferId] = (s.aavePortalFeeNumerator * _fastTransferAmount) / Constants.BPS_FEE_DENOMINATOR;\n\n    emit AavePortalMintUnbacked(_transferId, _router, adopted, _fastTransferAmount);\n\n    return (_fastTransferAmount, adopted);\n  }\n\n  // ============ Internal: Send ============\n\n  /**\n   * @notice Format and send transfer message to a remote chain.\n   *\n   * @param _transferId Unique identifier for the transfer.\n   * @param _destination The destination domain.\n   * @param _connextion The connext instance on the destination domain.\n   * @param _canonical The canonical token ID/domain info.\n   * @param _local The local token address.\n   * @param _amount The token amount.\n   * @param _isCanonical Whether or not the local token is the canonical asset (i.e. this is the token's\n   * \"home\" chain).\n   */\n  function _sendMessage(\n    bytes32 _transferId,\n    uint32 _destination,\n    bytes32 _connextion,\n    TokenId memory _canonical,\n    address _local,\n    uint256 _amount,\n    bool _isCanonical\n  ) private returns (bytes32) {\n    // Remove tokens from circulation on this chain if applicable.\n    if (_amount > 0) {\n      if (!_isCanonical) {\n        // If the token originates on a remote chain, burn the representational tokens on this chain.\n        IBridgeToken(_local).burn(address(this), _amount);\n      }\n      // IFF the token IS the canonical token (i.e. originates on this chain), we lock the input tokens in escrow\n      // in this contract, as an equal amount of representational assets will be minted on the destination chain.\n      // NOTE: The tokens should be in the contract already at this point from xcall.\n    }\n\n    bytes memory _messageBody = abi.encodePacked(\n      _canonical.domain,\n      _canonical.id,\n      BridgeMessage.Types.Transfer,\n      _amount,\n      _transferId\n    );\n\n    // Send message to destination chain bridge router.\n    bytes32 _messageHash = IOutbox(s.xAppConnectionManager.home()).dispatch(_destination, _connextion, _messageBody);\n\n    // return message hash\n    return _messageHash;\n  }\n\n  /**\n   * @notice Assert that the given domain has a xApp Router registered and return its address\n   * @param _domain The domain of the chain for which to get the xApp Router\n   * @return _remote The address of the remote xApp Router on _domain\n   */\n  function _mustHaveRemote(uint32 _domain) internal view returns (bytes32 _remote) {\n    _remote = s.remotes[_domain];\n    if (_remote == bytes32(0)) {\n      revert BridgeFacet__mustHaveRemote_destinationNotSupported();\n    }\n  }\n}\n"
    },
    "contracts/core/connext/interfaces/IXReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IXReceiver {\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external returns (bytes memory);\n}\n"
    },
    "contracts/core/connext/helpers/BridgeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\n\nimport {ERC20} from \"./OZERC20.sol\";\n\ncontract BridgeToken is IBridgeToken, Ownable, ERC20 {\n  // ============ Constructor ============\n  constructor(\n    uint8 decimals_,\n    string memory name_,\n    string memory symbol_\n  ) Ownable() ERC20(decimals_, name_, symbol_, \"1\") {}\n\n  // ============ Events ============\n\n  event UpdateDetails(string indexed name, string indexed symbol);\n\n  // ============ Admin Functions ============\n\n  /**\n   * @notice Destroys `_amnt` tokens from `_from`, reducing the\n   * total supply.\n   * @dev Emits a {Transfer} event with `to` set to the zero address.\n   * Requirements:\n   * - `_from` cannot be the zero address.\n   * - `_from` must have at least `_amnt` tokens.\n   * @param _from The address from which to destroy the tokens\n   * @param _amnt The amount of tokens to be destroyed\n   */\n  function burn(address _from, uint256 _amnt) external override onlyOwner {\n    _burn(_from, _amnt);\n  }\n\n  /** @notice Creates `_amnt` tokens and assigns them to `_to`, increasing\n   * the total supply.\n   * @dev Emits a {Transfer} event with `from` set to the zero address.\n   * Requirements:\n   * - `to` cannot be the zero address.\n   * @param _to The destination address\n   * @param _amnt The amount of tokens to be minted\n   */\n  function mint(address _to, uint256 _amnt) external override onlyOwner {\n    _mint(_to, _amnt);\n  }\n\n  /**\n   * @notice Set the details of a token\n   * @param _newName The new name\n   * @param _newSymbol The new symbol\n   */\n  function setDetails(string calldata _newName, string calldata _newSymbol) external override onlyOwner {\n    // careful with naming convention change here\n    _name = _newName;\n    _symbol = _newSymbol;\n    bytes32 hashedName = keccak256(bytes(_newName));\n    _HASHED_NAME = hashedName;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, _HASHED_VERSION);\n    emit UpdateDetails(_newName, _newSymbol);\n  }\n}\n"
    },
    "contracts/core/connext/facets/TokenFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\n\nimport {TypeCasts} from \"../../../shared/libraries/TypeCasts.sol\";\n\nimport {TokenId} from \"../libraries/TokenId.sol\";\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {TokenConfig} from \"../libraries/LibConnextStorage.sol\";\n\nimport {IStableSwap} from \"../interfaces/IStableSwap.sol\";\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\n\nimport {BridgeToken} from \"../helpers/BridgeToken.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\ncontract TokenFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error TokenFacet__addAssetId_alreadyAdded();\n  error TokenFacet__addAssetId_badMint();\n  error TokenFacet__addAssetId_badBurn();\n  error TokenFacet__removeAssetId_notAdded();\n  error TokenFacet__removeAssetId_invalidParams();\n  error TokenFacet__removeAssetId_remainsCustodied();\n  error TokenFacet__updateDetails_localNotFound();\n  error TokenFacet__updateDetails_onlyRemote();\n  error TokenFacet__updateDetails_notApproved();\n  error TokenFacet__enrollAdoptedAndLocalAssets_emptyCanonical();\n  error TokenFacet__setupAsset_representationListed();\n  error TokenFacet__setupAsset_invalidCanonicalConfiguration();\n  error TokenFacet__setupAssetWithDeployedRepresentation_invalidRepresentation();\n  error TokenFacet__setupAssetWithDeployedRepresentation_onCanonicalDomain();\n  error TokenFacet__setLiquidityCap_notCanonicalDomain();\n\n  // ============ Events ============\n\n  /**\n   * @notice emitted when a representation token contract is deployed\n   * @param domain the domain of the chain where the canonical asset is deployed\n   * @param id the bytes32 address of the canonical token contract\n   * @param representation the address of the newly locally deployed representation contract\n   */\n  event TokenDeployed(uint32 indexed domain, bytes32 indexed id, address indexed representation);\n\n  /**\n   * @notice Emitted when a new stable-swap AMM is added for the local <> adopted token\n   * @param key - The key in the mapping (hash of canonical id and domain)\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param swapPool - The address of the AMM\n   * @param caller - The account that called the function\n   */\n  event StableSwapAdded(\n    bytes32 indexed key,\n    bytes32 indexed canonicalId,\n    uint32 indexed domain,\n    address swapPool,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when a liquidity cap is updated\n   * @param key - The key in the mapping (hash of canonical id and domain)\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param cap - The newly enforced liquidity cap (if it is 0, no cap is enforced)\n   * @param caller - The account that called the function\n   */\n  event LiquidityCapUpdated(\n    bytes32 indexed key,\n    bytes32 indexed canonicalId,\n    uint32 indexed domain,\n    uint256 cap,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when a new asset is added\n   * @param key - The key in the mapping (hash of canonical id and domain)\n   * @param canonicalId - The canonical identifier of the token the local <> adopted AMM is for\n   * @param domain - The domain of the canonical token for the local <> adopted amm\n   * @param adoptedAsset - The address of the adopted (user-expected) asset\n   * @param localAsset - The address of the local asset\n   * @param caller - The account that called the function\n   */\n  event AssetAdded(\n    bytes32 indexed key,\n    bytes32 indexed canonicalId,\n    uint32 indexed domain,\n    address adoptedAsset,\n    address localAsset,\n    address caller\n  );\n\n  /**\n   * @notice Emitted when an asset is removed from allowlists\n   * @param key - The hash of the canonical identifier and domain of the token removed\n   * @param caller - The account that called the function\n   */\n  event AssetRemoved(bytes32 indexed key, address caller);\n\n  // ============ Getters ============\n\n  function canonicalToAdopted(bytes32 _key) public view returns (address) {\n    return _getAdoptedAsset(_key);\n  }\n\n  function canonicalToAdopted(TokenId calldata _canonical) public view returns (address) {\n    return _getAdoptedAsset(AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain));\n  }\n\n  function adoptedToCanonical(address _adopted) public view returns (TokenId memory) {\n    TokenId memory canonical = TokenId(s.adoptedToCanonical[_adopted].domain, s.adoptedToCanonical[_adopted].id);\n    return canonical;\n  }\n\n  function canonicalToRepresentation(bytes32 _key) public view returns (address) {\n    return _getRepresentationAsset(_key);\n  }\n\n  function canonicalToRepresentation(TokenId calldata _canonical) public view returns (address) {\n    return _getRepresentationAsset(AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain));\n  }\n\n  function representationToCanonical(address _representation) public view returns (TokenId memory) {\n    TokenId memory canonical = TokenId(\n      s.representationToCanonical[_representation].domain,\n      s.representationToCanonical[_representation].id\n    );\n    return canonical;\n  }\n\n  function getTokenId(address _candidate) public view returns (TokenId memory) {\n    return _getCanonicalTokenId(_candidate);\n  }\n\n  function getLocalAndAdoptedToken(bytes32 _id, uint32 _domain) public view returns (address, address) {\n    return _getLocalAndAdoptedToken(AssetLogic.calculateCanonicalHash(_id, _domain), _id, _domain);\n  }\n\n  function approvedAssets(bytes32 _key) public view returns (bool) {\n    return s.tokenConfigs[_key].approval;\n  }\n\n  function approvedAssets(TokenId calldata _canonical) public view returns (bool) {\n    return approvedAssets(AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain));\n  }\n\n  function adoptedToLocalExternalPools(bytes32 _key) public view returns (IStableSwap) {\n    return IStableSwap(s.tokenConfigs[_key].adoptedToLocalExternalPools);\n  }\n\n  function adoptedToLocalExternalPools(TokenId calldata _canonical) public view returns (IStableSwap) {\n    return adoptedToLocalExternalPools(AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain));\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Used to add supported assets. This is an admin only function\n   *\n   * @dev When allowlisting the canonical asset, all representational assets would be\n   * allowlisted as well. In the event you have a different adopted asset (i.e. PoS USDC\n   * on polygon), you should *not* allowlist the adopted asset. The stable swap pool\n   * address used should allow you to swap between the local <> adopted asset.\n   *\n   * If a representation has been deployed at any point, `setupAssetWithDeployedRepresentation`\n   * should be used instead.\n   *\n   * The following can only be added on *REMOTE* domains:\n   * - `_adoptedAssetId`\n   * - `_stableSwapPool`\n   *\n   * Whereas the `_cap` can only be added on the canonical domain\n   *\n   * @param _canonical - The canonical asset to add by id and domain. All representations\n   * will be allowlisted as well\n   * @param _canonicalDecimals - The decimals of the canonical asset (will be used for deployed\n   * representation)\n   * @param _representationName - The name to be used for the deployed asset\n   * @param _representationSymbol - The symbol used for the deployed asset\n   * @param _adoptedAssetId - The used asset id for this domain (e.g. PoS USDC for\n   * polygon)\n   * @param _stableSwapPool - The address of the local stableswap pool, if it exists.\n   */\n  function setupAsset(\n    TokenId calldata _canonical,\n    uint8 _canonicalDecimals,\n    string memory _representationName,\n    string memory _representationSymbol,\n    address _adoptedAssetId,\n    address _stableSwapPool,\n    uint256 _cap\n  ) external onlyOwnerOrAdmin returns (address _local) {\n    // Calculate the canonical key.\n    bytes32 key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n\n    bool onCanonical = _canonical.domain == s.domain;\n    if (onCanonical) {\n      // On the canonical domain, the local is the canonical address.\n      _local = TypeCasts.bytes32ToAddress(_canonical.id);\n\n      // Sanity check: ensure adopted asset ID == canonical address (or empty).\n      // This could reflect a user error or miscalculation and lead to unexpected behavior.\n      // NOTE: Since we're on canonical domain, there should be no stableswap pool provided.\n      if ((_adoptedAssetId != address(0) && _adoptedAssetId != _local) || _stableSwapPool != address(0)) {\n        revert TokenFacet__setupAsset_invalidCanonicalConfiguration();\n      }\n\n      // Enroll the asset. Pass in address(0) for adopted: it should use the local asset (i.e. the\n      // canonical asset in this case) instead for both adopted and local.\n      _enrollAdoptedAndLocalAssets(true, _canonicalDecimals, address(0), _local, address(0), _canonical, _cap, key);\n    } else {\n      // Cannot already have an assigned representation.\n      // NOTE: *If* it does, it can still be replaced with `setupAssetWithDeployedRepresentation`\n      if (s.tokenConfigs[key].representation != address(0) || s.tokenConfigs[key].representationDecimals != 0) {\n        revert TokenFacet__setupAsset_representationListed();\n      }\n\n      // On remote, deploy a local representation.\n      _local = _deployRepresentation(\n        _canonical.id,\n        _canonical.domain,\n        _canonicalDecimals,\n        _representationName,\n        _representationSymbol\n      );\n      // Enroll the asset.\n      _enrollAdoptedAndLocalAssets(\n        false,\n        _canonicalDecimals,\n        _adoptedAssetId,\n        _local,\n        _stableSwapPool,\n        _canonical,\n        0,\n        key\n      );\n    }\n  }\n\n  /**\n   * @notice Used to add supported assets, without deploying a unique representation\n   * asset, and instead using what admins have provided. This is an admin only function\n   *\n   * @dev This function does very minimal checks to ensure the correct `_representation`\n   * token is used. The only enforced checks are:\n   * - Bridge can mint, and balance of bridge will increase\n   * - Bridge can burn, and balance of bridge will decrease\n   *\n   * However, there are many things that must be checked manually to avoid enrolling a bad\n   * representation:\n   * - decimals must always be equal to canonical decimals\n   * - regular `mint`, `burn`, `ERC20` functionality could be implemented improperly\n   * - the required interface functions (see `IBridgeToken`) may not be implemented\n   * - upgradeability could interfere with required functionality\n   *\n   * Using this method allows admins to override existing local tokens, and should be used\n   * carefully.\n   *\n   * @param _canonical - The canonical asset to add by id and domain. All representations\n   * will be whitelisted as well\n   * @param _representation - The address of the representative asset\n   * @param _adoptedAssetId - The used asset id for this domain (e.g. PoS USDC for\n   * polygon)\n   * @param _stableSwapPool - The address of the local stableswap pool, if it exists.\n   */\n  function setupAssetWithDeployedRepresentation(\n    TokenId calldata _canonical,\n    address _representation,\n    address _adoptedAssetId,\n    address _stableSwapPool\n  ) external onlyOwnerOrAdmin returns (address) {\n    if (_representation == address(0)) {\n      revert TokenFacet__setupAssetWithDeployedRepresentation_invalidRepresentation();\n    }\n\n    if (_canonical.domain == s.domain) {\n      revert TokenFacet__setupAssetWithDeployedRepresentation_onCanonicalDomain();\n    }\n\n    // Calculate the canonical key.\n    bytes32 key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n\n    _enrollAdoptedAndLocalAssets(\n      false,\n      IERC20Metadata(_representation).decimals(),\n      _adoptedAssetId,\n      _representation,\n      _stableSwapPool,\n      _canonical,\n      0,\n      key\n    );\n\n    return _representation;\n  }\n\n  /**\n   * @notice Adds a stable swap pool for the local <> adopted asset.\n   * @dev Must pass in the _canonical information so it can be emitted in event\n   */\n  function addStableSwapPool(TokenId calldata _canonical, address _stableSwapPool) external onlyOwnerOrAdmin {\n    bytes32 key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n    _addStableSwapPool(_canonical, _stableSwapPool, key);\n  }\n\n  /**\n   * @notice Adds a stable swap pool for the local <> adopted asset.\n   * @dev Must pass in the _canonical information so it can be emitted in event\n   */\n  function updateLiquidityCap(TokenId calldata _canonical, uint256 _updated) external onlyOwnerOrAdmin {\n    bytes32 key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n    _setLiquidityCap(_canonical, _updated, key);\n  }\n\n  /**\n   * @notice Used to remove assets from the allowlist\n   * @param _key - The hash of the canonical id and domain to remove (mapping key)\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n      * @param _representation - Corresponding representation asset to remove\n\n   */\n  function removeAssetId(\n    bytes32 _key,\n    address _adoptedAssetId,\n    address _representation\n  ) external onlyOwnerOrAdmin {\n    TokenId memory canonical = s.adoptedToCanonical[_adoptedAssetId];\n    _removeAssetId(_key, _adoptedAssetId, _representation, canonical);\n  }\n\n  /**\n   * @notice Used to remove assets from the allowlist\n   * @param _canonical - The canonical id and domain to remove\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n   * @param _representation - Corresponding representation asset to remove\n   */\n  function removeAssetId(\n    TokenId calldata _canonical,\n    address _adoptedAssetId,\n    address _representation\n  ) external onlyOwnerOrAdmin {\n    bytes32 key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n    _removeAssetId(key, _adoptedAssetId, _representation, _canonical);\n  }\n\n  /**\n   * @notice Used to update the name and symbol of a local token\n   * @param _canonical - The canonical id and domain to remove\n   * @param _name - The new name\n   * @param _symbol - The new symbol\n   */\n  function updateDetails(\n    TokenId calldata _canonical,\n    string memory _name,\n    string memory _symbol\n  ) external onlyOwnerOrAdmin {\n    bytes32 key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\n    address local = AssetLogic.getConfig(key).representation;\n    if (local == address(0)) {\n      revert TokenFacet__updateDetails_localNotFound();\n    }\n\n    // Can only happen on remote domains\n    if (s.domain == _canonical.domain) {\n      revert TokenFacet__updateDetails_onlyRemote();\n    }\n\n    // ensure asset is currently approved because `s.canonicalToRepresentation` does\n    // not get cleared when asset is removed from allowlist\n    if (!s.tokenConfigs[key].approval) {\n      revert TokenFacet__updateDetails_notApproved();\n    }\n\n    // make sure the asset is still active\n    IBridgeToken(local).setDetails(_name, _symbol);\n  }\n\n  // ============ Private Functions ============\n\n  function _enrollAdoptedAndLocalAssets(\n    bool _onCanonical,\n    uint8 _localDecimals,\n    address _adopted,\n    address _local,\n    address _stableSwapPool,\n    TokenId calldata _canonical,\n    uint256 _cap,\n    bytes32 _key\n  ) internal {\n    // Sanity check: canonical ID and domain are not 0.\n    if (_canonical.domain == 0 || _canonical.id == bytes32(\"\")) {\n      revert TokenFacet__enrollAdoptedAndLocalAssets_emptyCanonical();\n    }\n\n    // Get true adopted\n    bool adoptedIsLocal = _adopted == address(0);\n    address adopted = adoptedIsLocal ? _local : _adopted;\n\n    // Get whether you are on canonical\n    bool onCanonical = s.domain == _canonical.domain;\n\n    // Sanity check: needs approval\n    if (s.tokenConfigs[_key].approval) revert TokenFacet__addAssetId_alreadyAdded();\n\n    // Sanity check: bridge can mint / burn on remote\n    if (!onCanonical) {\n      IBridgeToken candidate = IBridgeToken(_local);\n      uint256 starting = candidate.balanceOf(address(this));\n      candidate.mint(address(this), 1);\n      if (candidate.balanceOf(address(this)) != starting + 1) {\n        revert TokenFacet__addAssetId_badMint();\n      }\n      candidate.burn(address(this), 1);\n      if (candidate.balanceOf(address(this)) != starting) {\n        revert TokenFacet__addAssetId_badBurn();\n      }\n    }\n\n    // Generate Config\n    // NOTE: Using address(0) for stable swap, then using `_addStableSwap`. Slightly less\n    // efficient, but preserves events. Same case for cap / custodied.\n    // NOTE: IFF on canonical domain, `representation` must *always* be address(0)!\n    s.tokenConfigs[_key] = TokenConfig(\n      _onCanonical ? address(0) : _local, // representation\n      _localDecimals, // representationDecimals\n      adopted, // adopted\n      adoptedIsLocal ? _localDecimals : IERC20Metadata(adopted).decimals(), // adoptedDecimals\n      address(0), // adoptedToLocalExternalPools, see note\n      true, // approval\n      0, // cap, see note\n      0 // custodied, see note\n    );\n\n    // Update reverse lookups\n    // Update the adopted mapping using convention of local == adopted iff (_adopted == address(0))\n    s.adoptedToCanonical[adopted].domain = _canonical.domain;\n    s.adoptedToCanonical[adopted].id = _canonical.id;\n\n    if (!_onCanonical) {\n      // Update the local <> canonical. Representations only exist on non-canonical domains.\n      s.representationToCanonical[_local].domain = _canonical.domain;\n      s.representationToCanonical[_local].id = _canonical.id;\n      // Update swap (on the canonical domain, there is no representation / pool).\n      _addStableSwapPool(_canonical, _stableSwapPool, _key);\n    } else if (_cap > 0) {\n      // Update cap (only on canonical domain).\n      _setLiquidityCap(_canonical, _cap, _key);\n    }\n\n    // Emit event\n    emit AssetAdded(_key, _canonical.id, _canonical.domain, adopted, _local, msg.sender);\n  }\n\n  /**\n   * @notice Used to add an AMM for adopted <> local assets\n   * @param _canonical - The canonical TokenId to add (domain and id)\n   * @param _stableSwap - The address of the amm to add\n   * @param _key - The hash of the canonical id and domain\n   */\n  function _addStableSwapPool(\n    TokenId calldata _canonical,\n    address _stableSwap,\n    bytes32 _key\n  ) internal {\n    // Update the pool mapping\n    s.tokenConfigs[_key].adoptedToLocalExternalPools = _stableSwap;\n\n    // Emit event\n    emit StableSwapAdded(_key, _canonical.id, _canonical.domain, _stableSwap, msg.sender);\n  }\n\n  /**\n   * @notice Used to add a cap on amount of custodied canonical asset\n   * @dev The `custodied` amount will only increase in real time as router liquidity\n   * and xcall are used and the cap is set (i.e. if cap is removed, `custodied` values are\n   * no longer updated or enforced).\n   *\n   * When the `cap` is updated, the `custodied` value is set to the balance of the contract,\n   * which is distinct from *retrievable* funds from the contracts (i.e. could include the\n   * value someone just sent directly to the contract). Whenever you are updating the cap, you\n   * should set the value with this in mind.\n   *\n   * @param _canonical - The canonical TokenId to add (domain and id)\n   * @param _updated - The updated liquidity cap value\n   * @param _key - The hash of the canonical id and domain\n   */\n  function _setLiquidityCap(\n    TokenId calldata _canonical,\n    uint256 _updated,\n    bytes32 _key\n  ) internal {\n    if (s.domain != _canonical.domain) {\n      revert TokenFacet__setLiquidityCap_notCanonicalDomain();\n    }\n    // Update the stored cap\n    s.tokenConfigs[_key].cap = _updated;\n\n    if (_updated > 0) {\n      // Update the custodied value to be the balance of this contract\n      address canonical = TypeCasts.bytes32ToAddress(_canonical.id);\n      s.tokenConfigs[_key].custodied = IERC20Metadata(canonical).balanceOf(address(this));\n    }\n\n    emit LiquidityCapUpdated(_key, _canonical.id, _canonical.domain, _updated, msg.sender);\n  }\n\n  /**\n   * @notice Used to remove assets from the allowlist\n   *\n   * @dev When you are removing an asset, `xcall` will fail but `handle` and `execute` will not to\n   * allow for inflight transfers to be addressed. Similarly, the `repayAavePortal` function will\n   * work.\n   *\n   * @param _key - The hash of the canonical id and domain to remove (mapping key)\n   * @param _adoptedAssetId - Corresponding adopted asset to remove\n   * @param _representation - Corresponding representation asset (i.e. bridged asset) to remove.\n   * @param _canonical - The TokenId (canonical ID and domain) of the asset.\n   */\n  function _removeAssetId(\n    bytes32 _key,\n    address _adoptedAssetId,\n    address _representation,\n    TokenId memory _canonical\n  ) internal {\n    TokenConfig storage config = s.tokenConfigs[_key];\n    // Sanity check: already approval\n    if (!config.approval) revert TokenFacet__removeAssetId_notAdded();\n\n    // Sanity check: consistent set of params\n    if (config.adopted != _adoptedAssetId || config.representation != _representation)\n      revert TokenFacet__removeAssetId_invalidParams();\n\n    bool onCanonical = s.domain == _canonical.domain;\n    if (onCanonical) {\n      // Sanity check: no value custodied if on canonical domain\n      address canonicalAsset = TypeCasts.bytes32ToAddress(_canonical.id);\n      // Check custodied amount for the given canonical asset address.\n      // NOTE: if the `cap` is not set, the `custodied` value will not continue to be updated,\n      // so you must use the `balanceOf` for accurate accounting. If there are funds held\n      // on these contracts, then when you remove the asset id, the assets cannot be bridged back and\n      // become worthless. This means the bridged assets would become worthless.\n      // An attacker could prevent admins from removing an asset by sending funds to this contract,\n      // but all of the liquidity should already be removed before this function is called.\n      if (IERC20Metadata(canonicalAsset).balanceOf(address(this)) > 0) {\n        revert TokenFacet__removeAssetId_remainsCustodied();\n      }\n    } else {\n      // Sanity check: supply is 0 if on remote domain.\n      if (IBridgeToken(_representation).totalSupply() > 0) {\n        revert TokenFacet__removeAssetId_remainsCustodied();\n      }\n    }\n\n    // Delete token config from configs mapping.\n    // NOTE: we do NOT delete the representation entries from the config. This is\n    // done to prevent multiple representations being deployed in `setupAsset`\n    delete s.tokenConfigs[_key].adopted;\n    delete s.tokenConfigs[_key].adoptedDecimals;\n    delete s.tokenConfigs[_key].adoptedToLocalExternalPools;\n    delete s.tokenConfigs[_key].approval;\n    delete s.tokenConfigs[_key].cap;\n    // NOTE: custodied will always be 0 at this point\n\n    // Delete from reverse lookups\n    delete s.representationToCanonical[_representation];\n    delete s.adoptedToCanonical[_adoptedAssetId];\n\n    // Emit event\n    emit AssetRemoved(_key, msg.sender);\n  }\n\n  /**\n   * @notice Deploy and initialize a new token contract\n   * @dev Each token contract is a proxy which\n   * points to the token upgrade beacon\n   * @return _token the address of the token contract\n   */\n  function _deployRepresentation(\n    bytes32 _id,\n    uint32 _domain,\n    uint8 _decimals,\n    string memory _name,\n    string memory _symbol\n  ) internal returns (address _token) {\n    // deploy the token contract\n    _token = address(new BridgeToken(_decimals, _name, _symbol));\n    // emit event upon deploying new token\n    emit TokenDeployed(_domain, _id, _token);\n  }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n"
    },
    "contracts/core/connext/facets/InboxFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {TypedMemView} from \"../../../shared/libraries/TypedMemView.sol\";\n\nimport {AssetLogic} from \"../libraries/AssetLogic.sol\";\nimport {BridgeMessage} from \"../libraries/BridgeMessage.sol\";\nimport {DestinationTransferStatus} from \"../libraries/LibConnextStorage.sol\";\n\nimport {IBridgeToken} from \"../interfaces/IBridgeToken.sol\";\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\n/**\n * @title InboxFacet\n * @notice This is the facet that holds all the functionality needed for Connext's messaging layer to\n * reconcile cross-chain transfers. Authenticated (proven) message data is delivered to the `reconcile`\n * function, where it is parsed to determine the message action. Tokens are credited (representational\n * assets are minted, canonical tokens are unlocked from escrow) if applicable.\n *\n */\ncontract InboxFacet is BaseConnextFacet {\n  // ============ Libraries ============\n\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using BridgeMessage for bytes29;\n\n  // ========== Custom Errors ===========\n\n  error InboxFacet__onlyReplica_notReplica();\n  error InboxFacet__onlyRemoteRouter_notRemote();\n  error InboxFacet__handle_notTransfer();\n  error InboxFacet__reconcile_alreadyReconciled();\n  error InboxFacet__reconcile_noPortalRouter();\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when `reconciled` is called by the bridge on the destination domain.\n   * @param transferId - The unique identifier of the transfer.\n   * @param originDomain - The originating domain of the transfer.\n   * @param local - The local asset that was provided by the bridge.\n   * @param routers - The routers that were reimbursed the bridged token, if fast liquidity was\n   * provided for the given transfer.\n   * @param amount - The amount that was provided by the bridge.\n   * @param caller - The account that called the function\n   */\n  event Reconciled(\n    bytes32 indexed transferId,\n    uint32 indexed originDomain,\n    address indexed local,\n    address[] routers,\n    uint256 amount,\n    address caller\n  );\n\n  /**\n   * @notice emitted when tokens are dispensed to an account on this domain\n   *         emitted both when fast liquidity is provided, and when the\n   *         transfer ultimately settles\n   * @param originAndNonce Domain where the transfer originated and the\n   *        unique identifier for the message from origin to destination,\n   *        combined in a single field ((origin << 32) & nonce)\n   * @param token The address of the local token contract being received\n   * @param recipient The address receiving the tokens; the original\n   *        recipient of the transfer\n   * @param liquidityProvider The account providing liquidity\n   * @param amount The amount of tokens being received\n   */\n  event Receive(\n    uint64 indexed originAndNonce,\n    address indexed token,\n    address indexed recipient,\n    address liquidityProvider,\n    uint256 amount\n  );\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Only accept messages from a registered inbox contract.\n   */\n  modifier onlyReplica() {\n    if (!_isReplica(msg.sender)) {\n      revert InboxFacet__onlyReplica_notReplica();\n    }\n    _;\n  }\n\n  /**\n   * @notice Only accept messages from a remote Router contract.\n   * @param _origin The domain the message is coming from.\n   * @param _router The address the message is coming from.\n   */\n  modifier onlyRemoteHandler(uint32 _origin, bytes32 _router) {\n    if (!_isRemoteHandler(_origin, _router)) {\n      revert InboxFacet__onlyRemoteRouter_notRemote();\n    }\n    _;\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Handles an incoming cross-chain message.\n   *\n   * @param _origin The origin domain.\n   * @param _nonce The unique identifier for the message from origin to destination.\n   * @param _sender The sender address.\n   * @param _message The message body.\n   */\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external onlyReplica onlyRemoteHandler(_origin, _sender) {\n    // Parse token ID and action from message body.\n    bytes29 _msg = _message.ref(0).mustBeMessage();\n    bytes29 _tokenId = _msg.tokenId();\n    bytes29 _action = _msg.action();\n\n    // Sanity check: action must be a valid transfer.\n    if (!_action.isTransfer()) {\n      revert InboxFacet__handle_notTransfer();\n    }\n\n    // If applicable, mint the local asset that corresponds with the message's token ID in the\n    // amount specified by the message.\n    // Returns the local asset address and message's amount.\n    (address _token, uint256 _amount) = _creditTokens(_origin, _nonce, _tokenId, _action);\n\n    // Reconcile the transfer.\n    _reconcile(_action.transferId(), _origin, _token, _amount);\n  }\n\n  // ============ Internal Functions ============\n\n  /**\n   * @notice Reconcile the transfer, marking the transfer ID in storage as authenticated. Reimburses\n   * routers with local asset if it was a fast-liquidity transfer (i.e. it was previously executed).\n   * @param _transferId Unique identifier of the transfer.\n   * @param _origin Origin domain of the transfer.\n   * @param _asset Local asset address (representational or canonical).\n   * @param _amount The amount of the local asset.\n   */\n  function _reconcile(\n    bytes32 _transferId,\n    uint32 _origin,\n    address _asset,\n    uint256 _amount\n  ) internal {\n    // Ensure the transfer has not already been handled (i.e. previously reconciled).\n    // Will be previously reconciled IFF status == reconciled -or- status == executed\n    // and there is no path length on the transfers (no fast liquidity)\n    DestinationTransferStatus status = s.transferStatus[_transferId];\n    if (status != DestinationTransferStatus.None && status != DestinationTransferStatus.Executed) {\n      revert InboxFacet__reconcile_alreadyReconciled();\n    }\n\n    // Mark the transfer as reconciled.\n    s.transferStatus[_transferId] = status == DestinationTransferStatus.None\n      ? DestinationTransferStatus.Reconciled\n      : DestinationTransferStatus.Completed;\n\n    // If the transfer was executed using fast-liquidity provided by routers, then this value would be set\n    // to the participating routers.\n    // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for\n    // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).\n    address[] memory routers = s.routedTransfers[_transferId];\n\n    // If fast transfer was made using portal liquidity, portal debt must be repaid first.\n    // NOTE: Routers can repay any-amount out-of-band using the `repayAavePortal` method\n    // or by interacting with the aave contracts directly.\n    uint256 portalTransferAmount = s.portalDebt[_transferId] + s.portalFeeDebt[_transferId];\n\n    uint256 pathLen = routers.length;\n    // Sanity check: ensure a router took on the credit risk.\n    if (portalTransferAmount != 0 && pathLen != 1) {\n      revert InboxFacet__reconcile_noPortalRouter();\n    }\n\n    if (pathLen != 0) {\n      // Credit each router that provided liquidity their due 'share' of the asset.\n      uint256 routerAmount = _amount / pathLen;\n      for (uint256 i; i < pathLen - 1; ) {\n        s.routerBalances[routers[i]][_asset] += routerAmount;\n        unchecked {\n          ++i;\n        }\n      }\n      // The last router in the multipath will sweep the remaining balance to account for remainder dust.\n      uint256 toSweep = routerAmount + (_amount % pathLen);\n      s.routerBalances[routers[pathLen - 1]][_asset] += toSweep;\n    }\n\n    emit Reconciled(_transferId, _origin, _asset, routers, _amount, msg.sender);\n  }\n\n  /**\n   * @notice Determine whether _potentialReplica is an enrolled Replica from the xAppConnectionManager\n   * @return True if _potentialReplica is an enrolled Replica\n   */\n  function _isReplica(address _potentialReplica) internal view returns (bool) {\n    return s.xAppConnectionManager.isReplica(_potentialReplica);\n  }\n\n  /**\n   * @notice Return true if the given domain / router is the address of a remote xApp Router\n   * @param _domain The domain of the potential remote xApp Router\n   * @param _xAppHandler The address of the potential remote xApp handler\n   */\n  function _isRemoteHandler(uint32 _domain, bytes32 _xAppHandler) internal view returns (bool) {\n    return s.remotes[_domain] == _xAppHandler && _xAppHandler != bytes32(0);\n  }\n\n  /**\n   * @notice If applicable, mints tokens corresponding to the inbound message action.\n   * @dev IFF the asset is representational (i.e. originates from a remote chain), tokens will be minted.\n   * Otherwise, the token must be canonical (i.e. we are on the token's home chain), and the corresponding\n   * amount will already be available in escrow in this contract.\n   *\n   * @param _origin The domain of the chain from which the transfer originated.\n   * @param _nonce The unique identifier for the message from origin to destination.\n   * @param _tokenId The canonical token identifier to credit.\n   * @param _action The contents of the transfer message.\n   * @return _token The address of the local token contract.\n   */\n  function _creditTokens(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes29 _tokenId,\n    bytes29 _action\n  ) internal returns (address, uint256) {\n    bytes32 _canonicalId = _tokenId.id();\n    uint32 _canonicalDomain = _tokenId.domain();\n\n    // Load amount once.\n    uint256 _amount = _action.amnt();\n\n    // Check for the empty case -- if it is 0 value there is no strict requirement for the\n    // canonical information be defined (i.e. you can supply address(0) to xcall). If this\n    // is the case, return _token as address(0)\n    if (_amount == 0 && _canonicalDomain == 0 && _canonicalId == bytes32(0)) {\n      // Emit Receive event and short-circuit remaining logic: no tokens need to be delivered.\n      emit Receive(_originAndNonce(_origin, _nonce), address(0), address(this), address(0), _amount);\n      return (address(0), 0);\n    }\n\n    // Get the token contract for the given tokenId on this chain.\n    address _token = _getLocalAsset(\n      AssetLogic.calculateCanonicalHash(_canonicalId, _canonicalDomain),\n      _canonicalId,\n      _canonicalDomain\n    );\n\n    if (_amount == 0) {\n      // Emit Receive event and short-circuit remaining logic: no tokens need to be delivered.\n      emit Receive(_originAndNonce(_origin, _nonce), _token, address(this), address(0), _amount);\n      return (_token, 0);\n    }\n\n    // Mint the tokens into circulation on this chain.\n    if (!_isLocalOrigin(_token)) {\n      // If the token is of remote origin, mint the representational asset into circulation here.\n      // NOTE: The bridge tokens should be distributed to their intended recipient outside\n      IBridgeToken(_token).mint(address(this), _amount);\n    }\n    // NOTE: If the tokens are locally originating - meaning they are the canonical asset - then they\n    // would be held in escrow in this contract. If we're receiving this message, it must mean\n    // corresponding representational assets circulating on a remote chain were burnt when it was sent.\n\n    // Emit Receive event.\n    emit Receive(_originAndNonce(_origin, _nonce), _token, address(this), address(0), _amount);\n    return (_token, _amount);\n  }\n}\n"
    },
    "contracts/messaging/connectors/arbitrum/ArbitrumHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {LibArbitrumL1} from \"@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL1.sol\";\n\nimport {TypedMemView} from \"../../../shared/libraries/TypedMemView.sol\";\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {IArbitrumInbox} from \"../../interfaces/ambs/arbitrum/IArbitrumInbox.sol\";\nimport {IArbitrumOutbox} from \"../../interfaces/ambs/arbitrum/IArbitrumOutbox.sol\";\nimport {IArbitrumRollup, Node} from \"../../interfaces/ambs/arbitrum/IArbitrumRollup.sol\";\n\nimport {HubConnector} from \"../HubConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\nstruct L2Message {\n  address l2Sender;\n  address to;\n  uint256 l2Block;\n  uint256 l1Block;\n  uint256 l2Timestamp;\n  uint256 value;\n  bytes callData;\n}\n\ncontract ArbitrumHubConnector is HubConnector {\n  // ============ Libraries ============\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // ============ Storage ============\n\n  IArbitrumOutbox public outbox;\n  IArbitrumRollup public rollup;\n\n  /**\n   * @notice Sets cap on maxSubmissionCost used in `createRetryableTicket`\n   * @dev The value used in `createRetryableTicket` is the lesser of the cap or\n   * a value passed in via `_encodedData` in `_sendMessage`.\n   *\n   * This value represents amount of ETH allocated to pay for the base submission fee\n   */\n  uint256 public maxSubmissionCostCap;\n\n  /**\n   * @notice Sets cap on maxGas used in `createRetryableTicket`\n   * @dev The value used in `createRetryableTicket` is the lesser of the cap or\n   * a value passed in via `_encodedData` in `_sendMessage`.\n   *\n   * This value represents gas limit for immediate L2 execution attempt\n   */\n  uint256 public maxGasCap;\n\n  /**\n   * @notice Sets cap on gasPrice used in `createRetryableTicket`\n   * @dev The value used in `createRetryableTicket` is the lesser of the cap or\n   * a value passed in via `_encodedData` in `_sendMessage`.\n   *\n   * This value represents L2 gas price bid for immediate L2 execution attempt\n   */\n  uint256 public gasPriceCap;\n\n  /**\n   * @notice Tracks which messages have been processed from bridge\n   */\n  mapping(uint256 => bool) public processed;\n\n  // ============ Events ============\n  // TODO: do we need any other information from the ticket to link to message?\n  event RetryableTicketCreated(uint256 indexed ticketId);\n\n  /**\n   * @notice Emitted when admin updates the maxSubmissionCap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event MaxSubmissionCapUpdated(uint256 _previous, uint256 _updated);\n\n  /**\n   * @notice Emitted when admin updates the maxGasCap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event MaxGasCapUpdated(uint256 _previous, uint256 _updated);\n\n  /**\n   * @notice Emitted when admin updates the gasPriceCap\n   * @param _previous The starting value\n   * @param _updated The final value\n   */\n  event GasPriceCapUpdated(uint256 _previous, uint256 _updated);\n\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    address _outbox,\n    uint256 _maxSubmissionCostCap,\n    uint256 _maxGasCap,\n    uint256 _gasPriceCap\n  ) HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) {\n    outbox = IArbitrumOutbox(_outbox);\n    rollup = IArbitrumRollup(outbox.rollup());\n\n    // Set initial caps for L1 -> L2 messages\n    maxSubmissionCostCap = _maxSubmissionCostCap;\n    maxGasCap = _maxGasCap;\n    gasPriceCap = _gasPriceCap;\n  }\n\n  // ============ Admin fns ============\n\n  /**\n   * @notice Used (by admin) to update the maxSubmissionCostCap\n   * @param _updated The new value\n   */\n  function setMaxSubmissionCostCap(uint256 _updated) public onlyOwner {\n    emit MaxSubmissionCapUpdated(maxSubmissionCostCap, _updated);\n    maxSubmissionCostCap = _updated;\n  }\n\n  /**\n   * @notice Used (by admin) to update the maxGasCap\n   * @param _updated The new value\n   */\n  function setMaxGasCap(uint256 _updated) public onlyOwner {\n    emit MaxGasCapUpdated(maxGasCap, _updated);\n    maxGasCap = _updated;\n  }\n\n  /**\n   * @notice Used (by admin) to update the gasPriceCap\n   * @param _updated The new value\n   */\n  function setGasPriceCap(uint256 _updated) public onlyOwner {\n    emit GasPriceCapUpdated(maxSubmissionCostCap, _updated);\n    gasPriceCap = _updated;\n  }\n\n  // ============ Private fns ============\n\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _expected == LibArbitrumL1.crossChainSender(AMB);\n  }\n\n  /**\n   * @notice Helper to return the lesser of two values\n   * @param _a Some number\n   * @param _b Some number\n   */\n  function _lesserOf(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    return _a < _b ? _a : _b;\n  }\n\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be dispatching the aggregate root\n    require(_data.length == 32, \"!length\");\n    // Get the calldata\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\n\n    // Should include specialized calldata\n    require(_encodedData.length == (32 * 3), \"!data length\");\n\n    // Decode all of the gas-related parameters\n    (uint256 maxSubmissionCost, uint256 maxGas, uint256 gasPrice) = abi.decode(\n      _encodedData,\n      (uint256, uint256, uint256)\n    );\n\n    // dispatch to l2\n    uint256 ticketID = IArbitrumInbox(AMB).createRetryableTicket{value: msg.value}(\n      mirrorConnector, // destAddr\n      0, // arbTxCallValue\n      _lesserOf(maxSubmissionCost, maxSubmissionCostCap), // maxSubmissionCost: Amount of ETH allocated to pay for the base submission fee\n      mirrorConnector, // submissionRefundAddress: Address to which all excess gas is credited on L2\n      mirrorConnector, // valueRefundAddress: Address to which CallValue will be credited to on L2 if the retryable ticket times out or is cancelled\n      _lesserOf(maxGas, maxGasCap), // maxGas: Gas limit for immediate L2 execution attempt\n      _lesserOf(gasPrice, gasPriceCap), // gasPriceBid: L2 Gas price bid for immediate L2 execution attempt\n      _calldata // data\n    );\n    emit RetryableTicketCreated(ticketID);\n  }\n\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\n  // `processMessageFromRoot` flow.\n\n  function processMessageFromRoot(\n    uint64 _nodeNum,\n    bytes32 _sendRoot,\n    bytes32 _blockHash,\n    bytes32[] calldata _proof,\n    uint256 _index,\n    L2Message calldata _message\n  ) external {\n    // Ensure the send root corresponds to an arbitrum node that exists onchain\n    _validateSendRoot(_nodeNum, _sendRoot, _blockHash);\n\n    // Ensure the given l2 message is included in the send root\n    _validateMessage(_sendRoot, _proof, _index, _message);\n\n    // Message has been proven within the send root, process the message\n    // data itself. The message data is defined in the spoke connector as:\n    //\n    // `abi.encodeWithSelector(Connector.processMessage.selector, _data);`\n    //\n    // so to get the root data, we need to decode the _calldata. we can do this\n    // by dropping the 4-byte selector, then using the rest as the raw _data.\n    require(_message.callData.length == 36, \"!length\");\n\n    // NOTE: TypedMemView only loads 32-byte chunks onto stack, which is fine in this case\n    bytes32 _data = _message.callData.ref(0).index(4, 32);\n\n    // Update root manager\n    IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, _data);\n\n    // Emit event\n    emit MessageProcessed(_message.callData, msg.sender);\n  }\n\n  function _validateSendRoot(\n    uint64 _nodeNum,\n    bytes32 _sendRoot,\n    bytes32 _blockHash\n  ) internal view {\n    // Get the confirm data to ensure the node has been put on L1 with\n    // the given block hash and send root\n    bytes32 confirmData = _confirmHash(_blockHash, _sendRoot);\n\n    // Validate inputs by checking against the stored none confirm data\n    Node memory node = rollup.getNode(_nodeNum);\n    require(node.confirmData == confirmData, \"!confirmData\");\n\n    // Validate the node is staked / not in dispute\n    // NOTE: a dispute can happen at any point within the timeout window, so the closest\n    // we can get is to ensure the staker count > 0 and that there have been stakes on child\n    // nodes as well, meaning the node is less likely to be staked incorrectly (and thus less\n    // likely to be disputed)\n    require(node.stakerCount > 0 && node.childStakerCount > 0, \"!staked\");\n  }\n\n  // prove the message was included in the given send root\n  function _validateMessage(\n    bytes32 _sendRoot,\n    bytes32[] calldata _proof,\n    uint256 _index,\n    L2Message calldata _msg\n  ) internal {\n    // Check that the l2sender is the mirror connector\n    require(_msg.l2Sender == mirrorConnector, \"!mirrorConnector\");\n\n    // Generate the message sent through from L2 (included in sendRoot)\n    bytes32 userTx = outbox.calculateItemHash(\n      _msg.l2Sender,\n      _msg.to,\n      _msg.l2Block,\n      _msg.l1Block,\n      _msg.l2Timestamp,\n      _msg.value,\n      _msg.callData\n    );\n\n    // Prove message is included in the send root\n    _recordOutputAsSpent(_proof, _index, userTx, _sendRoot);\n  }\n\n  // taken from: https://github.com/OffchainLabs/nitro/blob/208d9d50f250e9b4948f867d3795548256583b17/contracts/src/rollup/RollupLib.sol#L128-L130\n  function _confirmHash(bytes32 _blockHash, bytes32 _sendRoot) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_blockHash, _sendRoot));\n  }\n\n  // modified from: https://github.com/OffchainLabs/nitro/blob/fbaa96d6d6246b427629be176499e1d5c5013d89/contracts/src/bridge/Outbox.sol#L219-L235\n  function _recordOutputAsSpent(\n    bytes32[] memory _proof,\n    uint256 _index,\n    bytes32 _item,\n    bytes32 _sendRoot\n  ) internal {\n    require(_proof.length < 256, \"proof length\");\n    require((_index >> _proof.length) == 0, \"!minimal proof\");\n\n    // NOTE: in the arbitrum contracts, they check that the message index is not yet spent\n    // Because the spoke connector calls `processMessage`, which does nothing, it is important\n    // to check out own internal mapping to ensure the message is not played twice. this forces\n    // all messages from l2 to be processed using the `processMessageFromRoot` fn path.\n    require(!processed[_index], \"spent\");\n\n    // Calculate the root\n    bytes32 calcRoot = outbox.calculateMerkleRoot(_proof, _index, _item);\n\n    // Assert the sendRoot is correct\n    // NOTE: this send root will *not* yet be stored on the `Outbox`\n    // contract (fraud period has not yet elapsed);\n    require(calcRoot == _sendRoot, \"!proof\");\n\n    // Mark as spent\n    processed[_index] = true;\n  }\n}\n"
    },
    "contracts/messaging/interfaces/ambs/arbitrum/IArbitrumInbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice Interface for sending L1 -> L2 messagesto Arbitrum.\n * @dev Arbitrum uses an inbox to aggregate messages going from L1 -> L2, source:\n * https://github.com/OffchainLabs/nitro/blob/master/contracts/src/bridge/Inbox.sol\n *\n */\ninterface IArbitrumInbox {\n  function createRetryableTicket(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n}\n"
    },
    "contracts/messaging/interfaces/ambs/arbitrum/IArbitrumOutbox.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @notice Interface for sending L1 -> L2 messagesto Arbitrum.\n * @dev Arbitrum uses an inbox to aggregate messages going from L1 -> L2, source:\n * https://github.com/OffchainLabs/nitro/blob/master/contracts/src/bridge/Inbox.sol\n *\n */\ninterface IArbitrumOutbox {\n  event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);\n  event OutBoxTransactionExecuted(\n    address indexed to,\n    address indexed l2Sender,\n    uint256 indexed zero,\n    uint256 transactionIndex\n  );\n\n  function rollup() external view returns (address); // the rollup contract\n\n  // function bridge() external view returns (IBridge); // the bridge contract\n\n  function spent(uint256) external view returns (bytes32); // packed spent bitmap\n\n  function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\n\n  // solhint-disable-next-line func-name-mixedcase\n  function OUTBOX_VERSION() external view returns (uint128); // the outbox version\n\n  function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\n\n  /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n  ///         When the return value is zero, that means this is a system message\n  /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n  function l2ToL1Sender() external view returns (address);\n\n  /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n  function l2ToL1Block() external view returns (uint256);\n\n  /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n  function l2ToL1EthBlock() external view returns (uint256);\n\n  /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n  function l2ToL1Timestamp() external view returns (uint256);\n\n  /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\n  function l2ToL1OutputId() external view returns (bytes32);\n\n  /**\n   * @notice Executes a messages in an Outbox entry.\n   * @dev Reverts if dispute period hasn't expired, since the outbox entry\n   *      is only created once the rollup confirms the respective assertion.\n   * @dev it is not possible to execute any L2-to-L1 transaction which contains data\n   *      to a contract address without any code (as enforced by the Bridge contract).\n   * @param proof Merkle proof of message inclusion in send root\n   * @param index Merkle path to message\n   * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n   * @param to destination address for L1 contract call\n   * @param l2Block l2 block number at which sendTxToL1 call was made\n   * @param l1Block l1 block number at which sendTxToL1 call was made\n   * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n   * @param value wei in L1 message\n   * @param data abi-encoded L1 message data\n   */\n  function executeTransaction(\n    bytes32[] calldata proof,\n    uint256 index,\n    address l2Sender,\n    address to,\n    uint256 l2Block,\n    uint256 l1Block,\n    uint256 l2Timestamp,\n    uint256 value,\n    bytes calldata data\n  ) external;\n\n  /**\n   *  @dev function used to simulate the result of a particular function call from the outbox\n   *       it is useful for things such as gas estimates. This function includes all costs except for\n   *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\n   *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\n   *       We can't include the cost of proof validation since this is intended to be used to simulate txs\n   *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\n   *       to confirm a pending merkle root, but that would be less pratical for integrating with tooling.\n   *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\n   *       unless under simulation in an eth_call or eth_estimateGas\n   */\n  function executeTransactionSimulation(\n    uint256 index,\n    address l2Sender,\n    address to,\n    uint256 l2Block,\n    uint256 l1Block,\n    uint256 l2Timestamp,\n    uint256 value,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @param index Merkle path to message\n   * @return true if the message has been spent\n   */\n  function isSpent(uint256 index) external view returns (bool);\n\n  function calculateItemHash(\n    address l2Sender,\n    address to,\n    uint256 l2Block,\n    uint256 l1Block,\n    uint256 l2Timestamp,\n    uint256 value,\n    bytes calldata data\n  ) external pure returns (bytes32);\n\n  function calculateMerkleRoot(\n    bytes32[] memory proof,\n    uint256 path,\n    bytes32 item\n  ) external pure returns (bytes32);\n}\n"
    },
    "contracts/messaging/interfaces/ambs/arbitrum/IArbitrumRollup.sol": {
      "content": "pragma solidity 0.8.17;\n\n// modified from: https://github.com/OffchainLabs/nitro/blob/master/contracts/src/rollup/Node.sol\nstruct Node {\n  // Hash of the state of the chain as of this node\n  bytes32 stateHash;\n  // Hash of the data that can be challenged\n  bytes32 challengeHash;\n  // Hash of the data that will be committed if this node is confirmed\n  bytes32 confirmData;\n  // Index of the node previous to this one\n  uint64 prevNum;\n  // Deadline at which this node can be confirmed\n  uint64 deadlineBlock;\n  // Deadline at which a child of this node can be confirmed\n  uint64 noChildConfirmedBeforeBlock;\n  // Number of stakers staked on this node. This includes real stakers and zombies\n  uint64 stakerCount;\n  // Number of stakers staked on a child node. This includes real stakers and zombies\n  uint64 childStakerCount;\n  // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\n  uint64 firstChildBlock;\n  // The number of the latest child of this node to be created\n  uint64 latestChildNumber;\n  // The block number when this node was created\n  uint64 createdAtBlock;\n  // A hash of all the data needed to determine this node's validity, to protect against reorgs\n  bytes32 nodeHash;\n}\n\n// modified from: https://github.com/OffchainLabs/nitro/blob/master/contracts/src/rollup/IRollupCore.sol\ninterface IArbitrumRollup {\n  /**\n   * @notice Get the Node for the given index.\n   */\n  function getNode(uint64 nodeNum) external view returns (Node memory);\n}\n"
    },
    "@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (crosschain/arbitrum/LibArbitrumL1.sol)\n\npragma solidity ^0.8.4;\n\nimport {IBridge as ArbitrumL1_Bridge} from \"../../vendor/arbitrum/IBridge.sol\";\nimport {IOutbox as ArbitrumL1_Outbox} from \"../../vendor/arbitrum/IOutbox.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for\n * https://arbitrum.io/[Arbitrum].\n *\n * This version should only be used on L1 to process cross-chain messages\n * originating from L2. For the other side, use {LibArbitrumL2}.\n */\nlibrary LibArbitrumL1 {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by the `bridge`.\n     */\n    function isCrossChain(address bridge) internal view returns (bool) {\n        return msg.sender == bridge;\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through the `bridge`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address bridge) internal view returns (address) {\n        if (!isCrossChain(bridge)) revert NotCrossChainCall();\n\n        address sender = ArbitrumL1_Outbox(ArbitrumL1_Bridge(bridge).activeOutbox()).l2ToL1Sender();\n        require(sender != address(0), \"LibArbitrumL1: system messages without sender\");\n\n        return sender;\n    }\n}\n"
    },
    "@openzeppelin/contracts/crosschain/errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (crosschain/errors.sol)\n\npragma solidity ^0.8.4;\n\nerror NotCrossChainCall();\nerror InvalidCrossChainSender(address actual, address expected);\n"
    },
    "@openzeppelin/contracts/vendor/arbitrum/IBridge.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts (last updated v4.8.0) (vendor/arbitrum/IBridge.sol)\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 baseFeeL1,\n        uint64 timestamp\n    );\n\n    event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data);\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    event SequencerInboxUpdated(address newSequencerInbox);\n\n    function allowedDelayedInboxList(uint256) external returns (address);\n\n    function allowedOutboxList(uint256) external returns (address);\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function delayedInboxAccs(uint256) external view returns (bytes32);\n\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\n\n    // OpenZeppelin: changed return type from IOwnable\n    function rollup() external view returns (address);\n\n    function sequencerInbox() external view returns (address);\n\n    function activeOutbox() external view returns (address);\n\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function sequencerReportedSubMessageCount() external view returns (uint256);\n\n    /**\n     * @dev Enqueue a message in the delayed inbox accumulator.\n     *      These messages are later sequenced in the SequencerInbox, either\n     *      by the sequencer as part of a normal batch, or by force inclusion.\n     */\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function delayedMessageCount() external view returns (uint256);\n\n    function sequencerMessageCount() external view returns (uint256);\n\n    // ---------- onlySequencerInbox functions ----------\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        );\n\n    /**\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\n     *      every delayed inbox or every sequencer inbox call.\n     */\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) external returns (uint256 msgNum);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    function setDelayedInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // ---------- initializer ----------\n\n    // OpenZeppelin: changed rollup_ type from IOwnable\n    function initialize(address rollup_) external;\n}\n"
    },
    "@openzeppelin/contracts/vendor/arbitrum/IOutbox.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts (last updated v4.8.0) (vendor/arbitrum/IOutbox.sol)\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\n\ninterface IOutbox {\n    event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);\n    event OutBoxTransactionExecuted(\n        address indexed to,\n        address indexed l2Sender,\n        uint256 indexed zero,\n        uint256 transactionIndex\n    );\n\n    function rollup() external view returns (address); // the rollup contract\n\n    function bridge() external view returns (IBridge); // the bridge contract\n\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\n\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\n\n    // solhint-disable-next-line func-name-mixedcase\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\n\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\n\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n    ///         When the return value is zero, that means this is a system message\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function l2ToL1Sender() external view returns (address);\n\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Block() external view returns (uint256);\n\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    /**\n     * @notice Executes a messages in an Outbox entry.\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\n     *      is only created once the rollup confirms the respective assertion.\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\n     *      to a contract address without any code (as enforced by the Bridge contract).\n     * @param proof Merkle proof of message inclusion in send root\n     * @param index Merkle path to message\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @param to destination address for L1 contract call\n     * @param l2Block l2 block number at which sendTxToL1 call was made\n     * @param l1Block l1 block number at which sendTxToL1 call was made\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @param value wei in L1 message\n     * @param data abi-encoded L1 message data\n     */\n    function executeTransaction(\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     *  @dev function used to simulate the result of a particular function call from the outbox\n     *       it is useful for things such as gas estimates. This function includes all costs except for\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\n     *       unless under simulation in an eth_call or eth_estimateGas\n     */\n    function executeTransactionSimulation(\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @param index Merkle path to message\n     * @return true if the message has been spent\n     */\n    function isSpent(uint256 index) external view returns (bool);\n\n    function calculateItemHash(\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external pure returns (bytes32);\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) external pure returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (crosschain/arbitrum/LibArbitrumL2.sol)\n\npragma solidity ^0.8.4;\n\nimport {IArbSys as ArbitrumL2_Bridge} from \"../../vendor/arbitrum/IArbSys.sol\";\nimport \"../errors.sol\";\n\n/**\n * @dev Primitives for cross-chain aware contracts for\n * https://arbitrum.io/[Arbitrum].\n *\n * This version should only be used on L2 to process cross-chain messages\n * originating from L1. For the other side, use {LibArbitrumL1}.\n *\n * WARNING: There is currently a bug in Arbitrum that causes this contract to\n * fail to detect cross-chain calls when deployed behind a proxy. This will be\n * fixed when the network is upgraded to Arbitrum Nitro, currently scheduled for\n * August 31st 2022.\n */\nlibrary LibArbitrumL2 {\n    /**\n     * @dev Returns whether the current function call is the result of a\n     * cross-chain message relayed by `arbsys`.\n     */\n    address public constant ARBSYS = 0x0000000000000000000000000000000000000064;\n\n    function isCrossChain(address arbsys) internal view returns (bool) {\n        return ArbitrumL2_Bridge(arbsys).wasMyCallersAddressAliased();\n    }\n\n    /**\n     * @dev Returns the address of the sender that triggered the current\n     * cross-chain message through `arbsys`.\n     *\n     * NOTE: {isCrossChain} should be checked before trying to recover the\n     * sender, as it will revert with `NotCrossChainCall` if the current\n     * function call is not the result of a cross-chain message.\n     */\n    function crossChainSender(address arbsys) internal view returns (address) {\n        if (!isCrossChain(arbsys)) revert NotCrossChainCall();\n\n        return ArbitrumL2_Bridge(arbsys).myCallersAddressWithoutAliasing();\n    }\n}\n"
    },
    "@openzeppelin/contracts/vendor/arbitrum/IArbSys.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/OffchainLabs/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts (last updated v4.8.0) (vendor/arbitrum/IArbSys.sol)\n\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title System level functionality\n * @notice For use by contracts to interact with core L2-specific functionality.\n * Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064.\n */\ninterface IArbSys {\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint256);\n\n    /**\n     * @notice Get Arbitrum block hash (reverts unless currentBlockNum-256 <= arbBlockNum < currentBlockNum)\n     * @return block hash\n     */\n    function arbBlockHash(uint256 arbBlockNum) external view returns (bytes32);\n\n    /**\n     * @notice Gets the rollup's unique chain identifier\n     * @return Chain identifier as int\n     */\n    function arbChainID() external view returns (uint256);\n\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external view returns (uint256);\n\n    /**\n     * @notice Returns 0 since Nitro has no concept of storage gas\n     * @return uint 0\n     */\n    function getStorageGasAvailable() external view returns (uint256);\n\n    /**\n     * @notice (deprecated) check if current call is top level (meaning it was triggered by an EoA or a L1 contract)\n     * @dev this call has been deprecated and may be removed in a future release\n     * @return true if current execution frame is not a call by another L2 contract\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param unused argument no longer used\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address unused) external pure returns (address);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty data.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint256);\n\n    /**\n     * @notice Send a transaction to L1\n     * @dev it is not possible to execute on the L1 any L2-to-L1 transaction which contains data\n     * to a contract address without any code (as enforced by the Bridge contract).\n     * @param destination recipient address on L1\n     * @param data (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata data) external payable returns (uint256);\n\n    /**\n     * @notice Get send Merkle tree state\n     * @return size number of sends in the history\n     * @return root root hash of the send history\n     * @return partials hashes of partial subtrees in the send history tree\n     */\n    function sendMerkleTreeState()\n        external\n        view\n        returns (\n            uint256 size,\n            bytes32 root,\n            bytes32[] memory partials\n        );\n\n    /**\n     * @notice creates a send txn from L2 to L1\n     * @param position = (level << 192) + leaf = (0 << 192) + leaf = leaf\n     */\n    event L2ToL1Tx(\n        address caller,\n        address indexed destination,\n        uint256 indexed hash,\n        uint256 indexed position,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /// @dev DEPRECATED in favour of the new L2ToL1Tx event above after the nitro upgrade\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint256 indexed uniqueId,\n        uint256 indexed batchNumber,\n        uint256 indexInBatch,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /**\n     * @notice logs a merkle branch for proof synthesis\n     * @param reserved an index meant only to align the 4th index with L2ToL1Transaction's 4th event\n     * @param hash the merkle hash\n     * @param position = (level << 192) + leaf\n     */\n    event SendMerkleUpdate(uint256 indexed reserved, bytes32 indexed hash, uint256 indexed position);\n}\n"
    },
    "contracts/messaging/connectors/arbitrum/ArbitrumSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {LibArbitrumL2} from \"@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL2.sol\";\n\nimport {ArbitrumL2Amb} from \"../../interfaces/ambs/arbitrum/ArbitrumL2Amb.sol\";\n\nimport {SpokeConnector} from \"../SpokeConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\ncontract ArbitrumSpokeConnector is SpokeConnector {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager\n  )\n    SpokeConnector(\n      _domain,\n      _mirrorDomain,\n      _amb,\n      _rootManager,\n      _mirrorConnector,\n      _processGas,\n      _reserveGas,\n      _delayBlocks,\n      _merkle,\n      _watcherManager\n    )\n  {}\n\n  // ============ Private fns ============\n\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _expected == LibArbitrumL2.crossChainSender(AMB);\n  }\n\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be dispatching the aggregate root\n    require(_data.length == 32, \"!length\");\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    // Get the calldata\n    bytes memory _calldata = abi.encodeWithSelector(Connector.processMessage.selector, _data);\n    // Send to L1\n    ArbitrumL2Amb(AMB).sendTxToL1(mirrorConnector, _calldata);\n  }\n\n  function _processMessage(bytes memory _data) internal override {\n    // only callable by mirror connector\n    require(_verifySender(mirrorConnector), \"!mirrorConnector\");\n    // get the data (should be the aggregate root)\n    require(_data.length == 32, \"!length\");\n    // update the aggregate root on the domain\n    receiveAggregateRoot(bytes32(_data));\n  }\n}\n"
    },
    "contracts/messaging/interfaces/ambs/arbitrum/ArbitrumL2Amb.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\ninterface ArbitrumL2Amb {\n  // Send a transaction to L1\n  function sendTxToL1(address destAddr, bytes calldata calldataForL1) external payable;\n}\n"
    },
    "contracts/core/connext/helpers/ConnextProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport {ProxyAdmin} from \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ConnextProxyAdmin is ProxyAdmin {\n  constructor(address owner) ProxyAdmin() {\n    // We just need this for our hardhat tooling right now\n  }\n}\n"
    },
    "contracts/shared/upgrade/UpgradeBeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// ============ External Imports ============\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title UpgradeBeaconProxy\n * @notice\n * Proxy contract which delegates all logic, including initialization,\n * to an implementation contract.\n * The implementation contract is stored within an Upgrade Beacon contract;\n * the implementation contract can be changed by performing an upgrade on the Upgrade Beacon contract.\n * The Upgrade Beacon contract for this Proxy is immutably specified at deployment.\n * @dev This implementation combines the gas savings of keeping the UpgradeBeacon address outside of contract storage\n * found in 0age's implementation:\n * https://github.com/dharma-eng/dharma-smart-wallet/blob/master/contracts/proxies/smart-wallet/UpgradeBeaconProxyV1.sol\n * With the added safety checks that the UpgradeBeacon and implementation are contracts at time of deployment\n * found in OpenZeppelin's implementation:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol\n */\ncontract UpgradeBeaconProxy {\n  // ============ Immutables ============\n\n  // Upgrade Beacon address is immutable (therefore not kept in contract storage)\n  address private immutable upgradeBeacon;\n\n  // ============ Constructor ============\n\n  /**\n   * @notice Validate that the Upgrade Beacon is a contract, then set its\n   * address immutably within this contract.\n   * Validate that the implementation is also a contract,\n   * Then call the initialization function defined at the implementation.\n   * The deployment will revert and pass along the\n   * revert reason if the initialization function reverts.\n   * @param _upgradeBeacon Address of the Upgrade Beacon to be stored immutably in the contract\n   * @param _initializationCalldata Calldata supplied when calling the initialization function\n   */\n  constructor(address _upgradeBeacon, bytes memory _initializationCalldata) payable {\n    // Validate the Upgrade Beacon is a contract\n    require(Address.isContract(_upgradeBeacon), \"beacon !contract\");\n    // set the Upgrade Beacon\n    upgradeBeacon = _upgradeBeacon;\n    // Validate the implementation is a contract\n    address _implementation = _getImplementation(_upgradeBeacon);\n    require(Address.isContract(_implementation), \"beacon implementation !contract\");\n    // Call the initialization function on the implementation\n    if (_initializationCalldata.length > 0) {\n      _initialize(_implementation, _initializationCalldata);\n    }\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Forwards all calls with data to _fallback()\n   * No public functions are declared on the contract, so all calls hit fallback\n   */\n  fallback() external payable {\n    _fallback();\n  }\n\n  /**\n   * @notice Forwards all calls with no data to _fallback()\n   */\n  receive() external payable {\n    _fallback();\n  }\n\n  // ============ Private Functions ============\n\n  /**\n   * @notice Call the initialization function on the implementation\n   * Used at deployment to initialize the proxy\n   * based on the logic for initialization defined at the implementation\n   * @param _implementation - Contract to which the initalization is delegated\n   * @param _initializationCalldata - Calldata supplied when calling the initialization function\n   */\n  function _initialize(address _implementation, bytes memory _initializationCalldata) private {\n    // Delegatecall into the implementation, supplying initialization calldata.\n    (bool _ok, ) = _implementation.delegatecall(_initializationCalldata);\n    // Revert and include revert data if delegatecall to implementation reverts.\n    if (!_ok) {\n      assembly {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Delegates function calls to the implementation contract returned by the Upgrade Beacon\n   */\n  function _fallback() private {\n    _delegate(_getImplementation());\n  }\n\n  /**\n   * @notice Delegate function execution to the implementation contract\n   * @dev This is a low level function that doesn't return to its internal\n   * call site. It will return whatever is returned by the implementation to the\n   * external caller, reverting and returning the revert data if implementation\n   * reverts.\n   * @param _implementation - Address to which the function execution is delegated\n   */\n  function _delegate(address _implementation) private {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n      // Delegatecall to the implementation, supplying calldata and gas.\n      // Out and outsize are set to zero - instead, use the return buffer.\n      let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\n      // Copy the returned data from the return buffer.\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      // Delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @notice Call the Upgrade Beacon to get the current implementation contract address\n   * @return _implementation Address of the current implementation.\n   */\n  function _getImplementation() private view returns (address _implementation) {\n    _implementation = _getImplementation(upgradeBeacon);\n  }\n\n  /**\n   * @notice Call the Upgrade Beacon to get the current implementation contract address\n   * @dev _upgradeBeacon is passed as a parameter so that\n   * we can also use this function in the constructor,\n   * where we can't access immutable variables.\n   * @param _upgradeBeacon Address of the UpgradeBeacon storing the current implementation\n   * @return _implementation Address of the current implementation.\n   */\n  function _getImplementation(address _upgradeBeacon) private view returns (address _implementation) {\n    // Get the current implementation address from the upgrade beacon.\n    (bool _ok, bytes memory _returnData) = _upgradeBeacon.staticcall(\"\");\n    // Revert and pass along revert message if call to upgrade beacon reverts.\n    require(_ok, string(_returnData));\n    // Set the implementation to the address returned from the upgrade beacon.\n    _implementation = abi.decode(_returnData, (address));\n  }\n}\n"
    },
    "contracts/messaging/connectors/gnosis/GnosisHubConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {IRootManager} from \"../../interfaces/IRootManager.sol\";\nimport {GnosisAmb} from \"../../interfaces/ambs/GnosisAmb.sol\";\n\nimport {Connector} from \"../Connector.sol\";\nimport {HubConnector} from \"../HubConnector.sol\";\n\nimport {GnosisBase} from \"./GnosisBase.sol\";\n\ncontract GnosisHubConnector is HubConnector, GnosisBase {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _gasCap,\n    uint256 _mirrorChainId\n  ) HubConnector(_domain, _mirrorDomain, _amb, _rootManager, _mirrorConnector) GnosisBase(_gasCap, _mirrorChainId) {}\n\n  // https://docs.gnosischain.com/bridges/tutorials/using-amb\n  function executeSignatures(bytes memory _data, bytes memory _signatures) external {\n    GnosisAmb(AMB).executeSignatures(_data, _signatures);\n  }\n\n  // ============ Private fns ============\n  /**\n   * @dev Asserts the sender of a cross domain message\n   */\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _verifySender(AMB, _expected, GnosisAmb(AMB).sourceChainId());\n  }\n\n  /**\n   * @dev Messaging uses this function to send data to l2 via amb\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be dispatching the aggregate root\n    require(_data.length == 32, \"!length\");\n\n    // send message via AMB, should call \"processMessage\" which will update aggregate root\n    GnosisAmb(AMB).requireToPassMessage(\n      mirrorConnector,\n      abi.encodeWithSelector(Connector.processMessage.selector, _data),\n      _getGasFromEncoded(_encodedData)\n    );\n  }\n\n  /**\n   * @dev L2 connector calls this function to pass down latest outbound root\n   */\n  function _processMessage(bytes memory _data) internal override {\n    // ensure the l1 connector sent the message\n    require(_verifySender(mirrorConnector), \"!l2Connector\");\n    // ensure it is headed to this domain\n    require(GnosisAmb(AMB).destinationChainId() == block.chainid, \"!destinationChain\");\n    // get the data (should be the outbound root)\n    require(_data.length == 32, \"!length\");\n    // update the root on the root manager\n    IRootManager(ROOT_MANAGER).aggregate(MIRROR_DOMAIN, bytes32(_data));\n  }\n}\n"
    },
    "contracts/messaging/interfaces/ambs/GnosisAmb.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\n// Taken from: https://github.com/omni/tokenbridge-contracts/blob/master/contracts/interfaces/IAMB.sol\ninterface GnosisAmb {\n  function messageSender() external view returns (address);\n\n  function maxGasPerTx() external view returns (uint256);\n\n  function transactionHash() external view returns (bytes32);\n\n  function messageId() external view returns (bytes32);\n\n  function messageSourceChainId() external view returns (bytes32);\n\n  function messageCallStatus(bytes32 _messageId) external view returns (bool);\n\n  function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);\n\n  function failedMessageReceiver(bytes32 _messageId) external view returns (address);\n\n  function failedMessageSender(bytes32 _messageId) external view returns (address);\n\n  function requireToPassMessage(\n    address _contract,\n    bytes memory _data,\n    uint256 _gas\n  ) external returns (bytes32);\n\n  function requireToConfirmMessage(\n    address _contract,\n    bytes memory _data,\n    uint256 _gas\n  ) external returns (bytes32);\n\n  function requireToGetInformation(bytes32 _requestSelector, bytes memory _data) external returns (bytes32);\n\n  function sourceChainId() external view returns (uint256);\n\n  function destinationChainId() external view returns (uint256);\n\n  function executeSignatures(bytes memory _data, bytes memory _signatures) external;\n\n  function safeExecuteSignaturesWithAutoGasLimit(bytes memory _data, bytes memory _signatures) external;\n}\n"
    },
    "contracts/messaging/connectors/gnosis/GnosisBase.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {GnosisAmb} from \"../../interfaces/ambs/GnosisAmb.sol\";\n\nimport {GasCap} from \"../GasCap.sol\";\n\nabstract contract GnosisBase is GasCap {\n  // ============ Storage ============\n  uint256 public immutable MIRROR_CHAIN_ID;\n\n  // ============ Constructor ============\n  constructor(uint256 _gasCap, uint256 _mirrorChainId) GasCap(_gasCap) {\n    MIRROR_CHAIN_ID = _mirrorChainId;\n  }\n\n  // ============ Private fns ============\n\n  /**\n   * @dev Asserts the sender of a cross domain message\n   */\n  function _verifySender(\n    address _amb,\n    address _expected,\n    uint256 _sourceChain\n  ) internal view returns (bool) {\n    require(msg.sender == _amb, \"!bridge\");\n    require(_sourceChain == MIRROR_CHAIN_ID, \"!source\");\n    return GnosisAmb(_amb).messageSender() == _expected;\n  }\n\n  /**\n   * @notice Using Gnosis AMB, the gas is provided to `sendMessage` as an encoded uint\n   */\n  function _getGasFromEncoded(bytes memory _encodedData) internal view returns (uint256 _gas) {\n    // Should include gssas info in specialized calldata\n    require(_encodedData.length == 32, \"!data length\");\n\n    // Get the gas, if it is more than the cap use the cap\n    _gas = _getGas(abi.decode(_encodedData, (uint256)));\n  }\n}\n"
    },
    "contracts/messaging/connectors/gnosis/GnosisSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {GnosisAmb} from \"../../interfaces/ambs/GnosisAmb.sol\";\n\nimport {SpokeConnector, ProposedOwnable} from \"../SpokeConnector.sol\";\nimport {Connector} from \"../Connector.sol\";\n\nimport {GnosisBase} from \"./GnosisBase.sol\";\n\ncontract GnosisSpokeConnector is SpokeConnector, GnosisBase {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager,\n    uint256 _gasCap, // gas to be provided on L1 execution\n    uint256 _mirrorChainId\n  )\n    SpokeConnector(\n      _domain,\n      _mirrorDomain,\n      _amb,\n      _rootManager,\n      _mirrorConnector,\n      _processGas,\n      _reserveGas,\n      _delayBlocks,\n      _merkle,\n      _watcherManager\n    )\n    GnosisBase(_gasCap, _mirrorChainId)\n  {}\n\n  /**\n   * @notice Should not be able to renounce ownership\n   */\n  function renounceOwnership() public virtual override(SpokeConnector, ProposedOwnable) onlyOwner {}\n\n  // ============ Private fns ============\n  /**\n   * @dev Asserts the sender of a cross domain message\n   */\n  function _verifySender(address _expected) internal view override returns (bool) {\n    return _verifySender(AMB, _expected, GnosisAmb(AMB).sourceChainId());\n  }\n\n  /**\n   * @dev Messaging uses this function to send data to mainnet via amb\n   * @param _encodedData Should be encoding of gas to be provided in execution of the method call on\n   * the mirror domain\n   */\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should always be dispatching the outbound root\n    require(_data.length == 32, \"!length\");\n\n    // Should include gas info in specialized calldata\n    require(_encodedData.length == 32, \"!data length\");\n\n    // send the message to the l1 connector by calling `processMessage`\n    GnosisAmb(AMB).requireToPassMessage(\n      mirrorConnector,\n      abi.encodeWithSelector(Connector.processMessage.selector, _data),\n      _getGasFromEncoded(_encodedData)\n    );\n  }\n\n  /**\n   * @dev AMB calls this function to store aggregate root that is sent up by the root manager\n   */\n  function _processMessage(bytes memory _data) internal override {\n    // get the data (should be the aggregate root)\n    require(_data.length == 32, \"!length\");\n    // ensure the l1 connector sent the message\n    require(_verifySender(mirrorConnector), \"!mirrorConnector\");\n    // ensure it is headed to this domain\n    require(GnosisAmb(AMB).destinationChainId() == block.chainid, \"!destinationChain\");\n    // update the aggregate root on the domain\n    receiveAggregateRoot(bytes32(_data));\n  }\n}\n"
    },
    "contracts/messaging/connectors/polygon/PolygonSpokeConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\nimport {FxBaseChildTunnel} from \"./tunnel/FxBaseChildTunnel.sol\";\n\nimport {SpokeConnector} from \"../SpokeConnector.sol\";\n\n// address constant MUMBAI_FX_CHILD = 0xCf73231F28B7331BBe3124B907840A94851f9f11;\n// address constant GOERLI_CHECKPOINT_MANAGER = 0x2890bA17EfE978480615e330ecB65333b880928e;\n// address constant GOERLI_FX_ROOT = 0x3d1d3E34f7fB6D26245E6640E1c50710eFFf15bA;\n\n// address constant MAINNET_FX_CHILD = 0x8397259c983751DAf40400790063935a11afa28a;\n// address constant MAINNET_CHECKPOINT_MANAGER = 0x86E4Dc95c7FBdBf52e33D563BbDB00823894C287;\n// address constant MAINNET_FX_ROOT = 0xfe5e5D361b2ad62c541bAb87C45a0B9B018389a2;\n\ncontract PolygonSpokeConnector is SpokeConnector, FxBaseChildTunnel {\n  // ============ Constructor ============\n  constructor(\n    uint32 _domain,\n    uint32 _mirrorDomain,\n    address _amb,\n    address _rootManager,\n    address _mirrorConnector,\n    uint256 _processGas,\n    uint256 _reserveGas,\n    uint256 _delayBlocks,\n    address _merkle,\n    address _watcherManager\n  )\n    SpokeConnector(\n      _domain,\n      _mirrorDomain,\n      _amb,\n      _rootManager,\n      _mirrorConnector,\n      _processGas,\n      _reserveGas,\n      _delayBlocks,\n      _merkle,\n      _watcherManager\n    )\n    FxBaseChildTunnel(_amb)\n  {}\n\n  // ============ Private fns ============\n\n  function _verifySender(address _expected) internal pure override returns (bool) {\n    // NOTE: Always return false here because we cannot verify sender except in\n    // _processMessageFromRoot, where it is exposed in plaintext\n    return false;\n  }\n\n  function _sendMessage(bytes memory _data, bytes memory _encodedData) internal override {\n    // Should not include specialized calldata\n    require(_encodedData.length == 0, \"!data length\");\n    _sendMessageToRoot(_data);\n  }\n\n  function _processMessageFromRoot(\n    uint256, /* stateId */\n    address sender,\n    bytes memory data\n  ) internal override validateSender(sender) {\n    // NOTE: Don't need to check that sender is mirrorConnector as this is checked in validateSender()\n    // get the data (should be the aggregate root)\n    require(data.length == 32, \"!length\");\n    // update the aggregate root on the domain\n    receiveAggregateRoot(bytes32(data));\n\n    emit MessageProcessed(data, msg.sender);\n  }\n\n  // DO NOT override _processMessage, should revert from `Connector` class. All messages must use the\n  // `processMessageFromRoot` flow.\n\n  function _setMirrorConnector(address _mirrorConnector) internal override {\n    // NOTE: FxBaseChildTunnel has the following code in their `setFxRootTunnel`:\n    // ```\n    // require(setFxRootTunnel == address(0x0), \"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\");\n    // ```\n    // Which means this function will revert if updating the `mirrorConnector`. In that case, in\n    // changes the spoke connector should also be redeployed\n    super._setMirrorConnector(_mirrorConnector);\n\n    setFxRootTunnel(_mirrorConnector);\n  }\n}\n"
    },
    "contracts/messaging/connectors/polygon/tunnel/FxBaseChildTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// https://github.com/fx-portal/contracts/blob/main/contracts/tunnel/FxBaseChildTunnel.sol\npragma solidity 0.8.17;\n\n// IFxMessageProcessor represents interface to process message\ninterface IFxMessageProcessor {\n  function processMessageFromRoot(\n    uint256 stateId,\n    address rootMessageSender,\n    bytes calldata data\n  ) external;\n}\n\n/**\n * @notice Mock child tunnel contract to receive and send message from L2\n */\nabstract contract FxBaseChildTunnel is IFxMessageProcessor {\n  // MessageTunnel on L1 will get data from this event\n  event MessageSent(bytes message);\n\n  // fx child\n  address public fxChild;\n\n  // fx root tunnel\n  address public fxRootTunnel;\n\n  constructor(address _fxChild) {\n    fxChild = _fxChild;\n  }\n\n  // Sender must be fxRootTunnel in case of ERC20 tunnel\n  modifier validateSender(address sender) {\n    require(sender == fxRootTunnel, \"FxBaseChildTunnel: INVALID_SENDER_FROM_ROOT\");\n    _;\n  }\n\n  // set fxRootTunnel if not set already\n  function setFxRootTunnel(address _fxRootTunnel) internal virtual {\n    require(fxRootTunnel == address(0x0), \"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\");\n    fxRootTunnel = _fxRootTunnel;\n  }\n\n  function processMessageFromRoot(\n    uint256 stateId,\n    address rootMessageSender,\n    bytes calldata data\n  ) external override {\n    require(msg.sender == fxChild, \"FxBaseChildTunnel: INVALID_SENDER\");\n    _processMessageFromRoot(stateId, rootMessageSender, data);\n  }\n\n  /**\n   * @notice Emit message that can be received on Root Tunnel\n   * @dev Call the internal function when need to emit message\n   * @param message bytes message that will be sent to Root Tunnel\n   * some message examples -\n   *   abi.encode(tokenId);\n   *   abi.encode(tokenId, tokenMetadata);\n   *   abi.encode(messageType, messageData);\n   */\n  function _sendMessageToRoot(bytes memory message) internal {\n    emit MessageSent(message);\n  }\n\n  /**\n   * @notice Process message received from Root Tunnel\n   * @dev function needs to be implemented to handle message as per requirement\n   * This is called by onStateReceive function.\n   * Since it is called via a system call, any event will not be emitted during its execution.\n   * @param stateId unique state id\n   * @param sender root message sender\n   * @param message bytes message that was sent from Root Tunnel\n   */\n  function _processMessageFromRoot(\n    uint256 stateId,\n    address sender,\n    bytes memory message\n  ) internal virtual;\n}\n"
    },
    "contracts/core/connext/facets/RelayerFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport {BaseConnextFacet} from \"./BaseConnextFacet.sol\";\n\ncontract RelayerFacet is BaseConnextFacet {\n  // ========== Custom Errors ===========\n  error RelayerFacet__setRelayerFeeVault_invalidRelayerFeeVault();\n  error RelayerFacet__addRelayer_alreadyApproved();\n  error RelayerFacet__removeRelayer_notApproved();\n\n  // ========== Events ===========\n  /**\n   * @notice Emitted when the relayerFeeVault variable is updated\n   * @param oldVault - The relayerFeeVault old value\n   * @param newVault - The relayerFeeVault new value\n   * @param caller - The account that called the function\n   */\n  event RelayerFeeVaultUpdated(address oldVault, address newVault, address caller);\n\n  /**\n   * @notice Emitted when a relayer is added or removed from allowlists\n   * @param relayer - The relayer address to be added or removed\n   * @param caller - The account that called the function\n   */\n  event RelayerAdded(address relayer, address caller);\n\n  /**\n   * @notice Emitted when a relayer is added or removed from allowlists\n   * @param relayer - The relayer address to be added or removed\n   * @param caller - The account that called the function\n   */\n  event RelayerRemoved(address relayer, address caller);\n\n  // ============ Modifiers ============\n\n  // ============ Getters ============\n\n  function approvedRelayers(address _relayer) public view returns (bool) {\n    return s.approvedRelayers[_relayer];\n  }\n\n  function relayerFeeVault() external view returns (address) {\n    return s.relayerFeeVault;\n  }\n\n  // ============ Admin functions ============\n\n  /**\n   * @notice Updates the relayer fee router\n   * @param _relayerFeeVault The address of the new router\n   */\n  function setRelayerFeeVault(address _relayerFeeVault) external onlyOwnerOrAdmin {\n    address old = address(s.relayerFeeVault);\n    if (old == _relayerFeeVault) revert RelayerFacet__setRelayerFeeVault_invalidRelayerFeeVault();\n\n    s.relayerFeeVault = _relayerFeeVault;\n    emit RelayerFeeVaultUpdated(old, _relayerFeeVault, msg.sender);\n  }\n\n  /**\n   * @notice Used to add approved relayer\n   * @param _relayer - The relayer address to add\n   */\n  function addRelayer(address _relayer) external onlyOwnerOrAdmin {\n    if (s.approvedRelayers[_relayer]) revert RelayerFacet__addRelayer_alreadyApproved();\n    s.approvedRelayers[_relayer] = true;\n\n    emit RelayerAdded(_relayer, msg.sender);\n  }\n\n  /**\n   * @notice Used to remove approved relayer\n   * @param _relayer - The relayer address to remove\n   */\n  function removeRelayer(address _relayer) external onlyOwnerOrAdmin {\n    if (!s.approvedRelayers[_relayer]) revert RelayerFacet__removeRelayer_notApproved();\n    delete s.approvedRelayers[_relayer];\n\n    emit RelayerRemoved(_relayer, msg.sender);\n  }\n}\n"
    },
    "contracts/messaging/interfaces/IMessageRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity 0.8.17;\n\ninterface IMessageRecipient {\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external;\n}\n"
    },
    "contracts/test/TestAggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\n/*\n * This aggregator is ONLY useful for testing\n */\ncontract TestAggregator {\n  uint8 public decimals = 18;\n\n  string public description = \"Chainlink Test Aggregator\";\n\n  uint256 public version = 1;\n\n  uint80 _mockRoundId = 1;\n\n  int256 _mockAnswer = 1;\n\n  uint256 _mockUpdateAt;\n\n  uint80 _mockAnsweredInRound = 1;\n\n  bool stopped;\n  // This error is used for only testing\n  error TestAggregator_Stopped();\n\n  constructor(uint8 _decimals) {\n    decimals = _decimals;\n    _mockUpdateAt = block.timestamp;\n  }\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    if (stopped) {\n      revert TestAggregator_Stopped();\n    }\n    return (_roundId, _mockAnswer * int256(10**decimals), 0, _mockUpdateAt, _mockAnsweredInRound);\n  }\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    if (stopped) {\n      revert TestAggregator_Stopped();\n    }\n    return (_mockRoundId, _mockAnswer * int256(10**decimals), 0, _mockUpdateAt, _mockAnsweredInRound);\n  }\n\n  function updateMockAnswer(int256 _answer) external {\n    _mockAnswer = _answer;\n  }\n\n  function updateMockData(\n    uint80 _roundId,\n    int256 _answer,\n    uint256 _updateAt,\n    uint80 _answeredInRound\n  ) external {\n    _mockRoundId = _roundId;\n    _mockAnswer = _answer;\n    _mockUpdateAt = _updateAt;\n    _mockAnsweredInRound = _answeredInRound;\n  }\n\n  function stop() external {\n    stopped = true;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}